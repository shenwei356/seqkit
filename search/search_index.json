{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Documents: http://bioinf.shenwei.me/seqkit ( Usage , FAQ , Tutorial , and Benchmark ) Source code: https://github.com/shenwei356/seqkit Latest version: Please cite : Introduction FASTA and FASTQ are basic and ubiquitous formats for storing nucleotide and protein sequences. Common manipulations of FASTA/Q file include converting, searching, filtering, deduplication, splitting, shuffling, and sampling. Existing tools only implement some of these manipulations, and not particularly efficiently, and some are only available for certain operating systems. Furthermore, the complicated installation process of required packages and running environments can render these programs less user friendly. This project describes a cross-platform ultrafast comprehensive toolkit for FASTA/Q processing. SeqKit provides executable binary files for all major operating systems, including Windows, Linux, and Mac OS X, and can be directly used without any dependencies or pre-configurations. SeqKit demonstrates competitive performance in execution time and memory usage compared to similar tools. The efficiency and usability of SeqKit enable researchers to rapidly accomplish common FASTA/Q file manipulations. Table of Contents Features Subcommands Installation Bash-completion Technical details and guides for use Usage && Examples Benchmark Citation Contributors Acknowledgements Contact License Features Cross-platform (Linux/Windows/Mac OS X/OpenBSD/FreeBSD, see download ) Light weight and out-of-the-box, no dependencies, no compilation, no configuration (see download ) UltraFast (see benchmark ), multiple-CPUs supported Practical functions supported by 28 subcommands (see subcommands and usage ) Supporting Bash-completion Well documented (detailed usage and benchmark ) Seamlessly parsing both FASTA and FASTQ formats Supporting STDIN and gzipped input/output file, easy being used in pipe , writing gzip file is very fast (10X of gzip , 4X of pigz ) by using package pgzip Supporting custom sequence ID regular expression (especially useful for searching with ID list) Reproducible results (configurable rand seed in sample and shuffle ) Well organized source code, friendly to use and easy to extend Features comparison Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats support Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation Yes Yes Yes Yes Yes -- Filtering by size Yes Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 1 : See version information of the softwares. Note 2 : See usage for detailed options of seqkit. Subcommands 32 functional subcommands in total. Sequence and subsequence seq transform sequences (revserse, complement, extract ID...) subseq get subsequences by region/gtf/bed, including flanking sequences sliding sliding sequences, circular genome supported stats simple statistics of FASTA/Q files faidx create FASTA index file and extract subsequence watch monitoring and online histograms of sequence features sana sanitize broken single line fastq files Format conversion fx2tab convert FASTA/Q to tabular format (and length/GC content/GC skew) tab2fx convert tabular format to FASTA/Q format fq2fa convert FASTQ to FASTA convert convert FASTQ quality encoding between Sanger, Solexa and Illumina translate translate DNA/RNA to protein sequence (supporting ambiguous bases) Searching grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed locate locate subsequences/motifs, mismatch allowed fish look for short sequences in larger sequences using local alignment amplicon retrieve amplicon (or specific region around it) via primer(s) BAM processing and monitoring bam monitoring and online histograms of BAM record features Set operations head print first N FASTA/Q records range print FASTA/Q records in a range (start:end) sample sample sequences by number or proportion rmdup remove duplicated sequences by id/name/sequence duplicate duplicate sequences N times common find common sequences of multiple files by id/name/sequence split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) Edit replace replace name/sequence by regular expression rename rename duplicated IDs restart reset start position for circular genome concat concatenate sequences with same ID from multiple files mutate edit sequence (point mutation, insertion, deletion) Ordering shuffle shuffle sequences sort sort sequences by id/name/sequence Misc version print version information and check for update genautocomplete generate shell autocompletion script Installation Go to Download Page for more download options and changelogs. SeqKit is implemented in Go programming language, executable binary files for most popular operating systems are freely available in release page. Method 1: Download binaries (latest stable/dev version) Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 . Method 2: Install via conda (latest stable version) conda install -c bioconda seqkit Method 3: Install via homebrew (latest stable version) brew install brewsci/bio/seqkit Method 4: For Go developer (latest stable/dev version) go get -u github.com/shenwei356/seqkit/seqkit Method 5: Docker based installation (latest stable/dev version) Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest Bash-completion Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: run: seqkit genautocomplete create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done Technical details and guides for use FASTA/Q format parsing SeqKit uses author's lightweight and high-performance bioinformatics packages bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Seqkit calls pigz (much faster than gzip ) or gzip to decompress .gz file if they are available. So please install pigz to gain better parsing performance for gzipped data . Seqkit does not call pigz or gzip any more since v0.8.1, Because it does not always increase the speed. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . Seqkit uses package pgzip to write gzip file, which is very fast ( 10X of gzip , 4X of pigz ) and the gzip file would be slighty larger. Sequence formats and types SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked. Sequence ID By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . FASTA index For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is slightly different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key. Parallelization of CPU intensive jobs The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 1 for single-CPU PC, 2 for others). Memory occupation Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands need to store sequences or heads in memory, but there are strategy to reduce memory occupation, including rmdup and common . When comparing with sequences, MD5 digest could be used to replace sequence by flag -m ( --md5 ). Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation. Reproducibility Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed. Usage && Examples Usage and examples Tutorial Benchmark More details: http://bioinf.shenwei.me/seqkit/benchmark/ Datasets: $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100 SeqKit version: v0.3.1.1 FASTA: FASTQ: Citation W Shen* , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE***. doi:10.1371/journal.pone.0163962 . Contributors Wei Shen Botond Sipos for commands: bam, fish, sana, watch. others Acknowledgements We thank Lei Zhang for testing of SeqKit, and also thank Jim Hester , author of fasta_utilities , for advice on early performance improvements of for FASTA parsing and Brian Bushnell , author of BBMaps , for advice on naming SeqKit and adding accuracy evaluation in benchmarks. We also thank Nicholas C. Wu from the Scripps Research Institute, USA for commenting on the manuscript and Guangchuang Yu from State Key Laboratory of Emerging Infectious Diseases, The University of Hong Kong, HK for advice on the manuscript. We thank Li Peng for reporting many bugs. Contact Email me for any problem when using seqkit. shenwei356(at)gmail.com Create an issue to report bugs, propose new functions or ask for help. License MIT License","title":"Home"},{"location":"#seqkit-a-cross-platform-and-ultrafast-toolkit-for-fastaq-file-manipulation","text":"Documents: http://bioinf.shenwei.me/seqkit ( Usage , FAQ , Tutorial , and Benchmark ) Source code: https://github.com/shenwei356/seqkit Latest version: Please cite :","title":"SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation"},{"location":"#introduction","text":"FASTA and FASTQ are basic and ubiquitous formats for storing nucleotide and protein sequences. Common manipulations of FASTA/Q file include converting, searching, filtering, deduplication, splitting, shuffling, and sampling. Existing tools only implement some of these manipulations, and not particularly efficiently, and some are only available for certain operating systems. Furthermore, the complicated installation process of required packages and running environments can render these programs less user friendly. This project describes a cross-platform ultrafast comprehensive toolkit for FASTA/Q processing. SeqKit provides executable binary files for all major operating systems, including Windows, Linux, and Mac OS X, and can be directly used without any dependencies or pre-configurations. SeqKit demonstrates competitive performance in execution time and memory usage compared to similar tools. The efficiency and usability of SeqKit enable researchers to rapidly accomplish common FASTA/Q file manipulations.","title":"Introduction"},{"location":"#table-of-contents","text":"Features Subcommands Installation Bash-completion Technical details and guides for use Usage && Examples Benchmark Citation Contributors Acknowledgements Contact License","title":"Table of Contents"},{"location":"#features","text":"Cross-platform (Linux/Windows/Mac OS X/OpenBSD/FreeBSD, see download ) Light weight and out-of-the-box, no dependencies, no compilation, no configuration (see download ) UltraFast (see benchmark ), multiple-CPUs supported Practical functions supported by 28 subcommands (see subcommands and usage ) Supporting Bash-completion Well documented (detailed usage and benchmark ) Seamlessly parsing both FASTA and FASTQ formats Supporting STDIN and gzipped input/output file, easy being used in pipe , writing gzip file is very fast (10X of gzip , 4X of pigz ) by using package pgzip Supporting custom sequence ID regular expression (especially useful for searching with ID list) Reproducible results (configurable rand seed in sample and shuffle ) Well organized source code, friendly to use and easy to extend","title":"Features"},{"location":"#features-comparison","text":"Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats support Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation Yes Yes Yes Yes Yes -- Filtering by size Yes Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 1 : See version information of the softwares. Note 2 : See usage for detailed options of seqkit.","title":"Features comparison"},{"location":"#subcommands","text":"32 functional subcommands in total. Sequence and subsequence seq transform sequences (revserse, complement, extract ID...) subseq get subsequences by region/gtf/bed, including flanking sequences sliding sliding sequences, circular genome supported stats simple statistics of FASTA/Q files faidx create FASTA index file and extract subsequence watch monitoring and online histograms of sequence features sana sanitize broken single line fastq files Format conversion fx2tab convert FASTA/Q to tabular format (and length/GC content/GC skew) tab2fx convert tabular format to FASTA/Q format fq2fa convert FASTQ to FASTA convert convert FASTQ quality encoding between Sanger, Solexa and Illumina translate translate DNA/RNA to protein sequence (supporting ambiguous bases) Searching grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed locate locate subsequences/motifs, mismatch allowed fish look for short sequences in larger sequences using local alignment amplicon retrieve amplicon (or specific region around it) via primer(s) BAM processing and monitoring bam monitoring and online histograms of BAM record features Set operations head print first N FASTA/Q records range print FASTA/Q records in a range (start:end) sample sample sequences by number or proportion rmdup remove duplicated sequences by id/name/sequence duplicate duplicate sequences N times common find common sequences of multiple files by id/name/sequence split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) Edit replace replace name/sequence by regular expression rename rename duplicated IDs restart reset start position for circular genome concat concatenate sequences with same ID from multiple files mutate edit sequence (point mutation, insertion, deletion) Ordering shuffle shuffle sequences sort sort sequences by id/name/sequence Misc version print version information and check for update genautocomplete generate shell autocompletion script","title":"Subcommands"},{"location":"#installation","text":"Go to Download Page for more download options and changelogs. SeqKit is implemented in Go programming language, executable binary files for most popular operating systems are freely available in release page.","title":"Installation"},{"location":"#method-1-download-binaries-latest-stabledev-version","text":"Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 .","title":"Method 1: Download binaries (latest stable/dev version)"},{"location":"#method-2-install-via-conda-latest-stable-version","text":"conda install -c bioconda seqkit","title":"Method 2: Install via conda  (latest stable version)"},{"location":"#method-3-install-via-homebrew-latest-stable-version","text":"brew install brewsci/bio/seqkit","title":"Method 3: Install via homebrew  (latest stable version)"},{"location":"#method-4-for-go-developer-latest-stabledev-version","text":"go get -u github.com/shenwei356/seqkit/seqkit","title":"Method 4: For Go developer (latest stable/dev version)"},{"location":"#method-5-docker-based-installation-latest-stabledev-version","text":"Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest","title":"Method 5: Docker based installation (latest stable/dev version)"},{"location":"#bash-completion","text":"Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: run: seqkit genautocomplete create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done","title":"Bash-completion"},{"location":"#technical-details-and-guides-for-use","text":"","title":"Technical details and guides for use"},{"location":"#fastaq-format-parsing","text":"SeqKit uses author's lightweight and high-performance bioinformatics packages bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Seqkit calls pigz (much faster than gzip ) or gzip to decompress .gz file if they are available. So please install pigz to gain better parsing performance for gzipped data . Seqkit does not call pigz or gzip any more since v0.8.1, Because it does not always increase the speed. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . Seqkit uses package pgzip to write gzip file, which is very fast ( 10X of gzip , 4X of pigz ) and the gzip file would be slighty larger.","title":"FASTA/Q format parsing"},{"location":"#sequence-formats-and-types","text":"SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked.","title":"Sequence formats and types"},{"location":"#sequence-id","text":"By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" .","title":"Sequence ID"},{"location":"#fasta-index","text":"For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is slightly different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key.","title":"FASTA index"},{"location":"#parallelization-of-cpu-intensive-jobs","text":"The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 1 for single-CPU PC, 2 for others).","title":"Parallelization of CPU intensive jobs"},{"location":"#memory-occupation","text":"Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands need to store sequences or heads in memory, but there are strategy to reduce memory occupation, including rmdup and common . When comparing with sequences, MD5 digest could be used to replace sequence by flag -m ( --md5 ). Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation.","title":"Memory occupation"},{"location":"#reproducibility","text":"Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed.","title":"Reproducibility"},{"location":"#usage-examples","text":"Usage and examples Tutorial","title":"Usage &amp;&amp; Examples"},{"location":"#benchmark","text":"More details: http://bioinf.shenwei.me/seqkit/benchmark/ Datasets: $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100 SeqKit version: v0.3.1.1 FASTA: FASTQ:","title":"Benchmark"},{"location":"#citation","text":"W Shen* , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE***. doi:10.1371/journal.pone.0163962 .","title":"Citation"},{"location":"#contributors","text":"Wei Shen Botond Sipos for commands: bam, fish, sana, watch. others","title":"Contributors"},{"location":"#acknowledgements","text":"We thank Lei Zhang for testing of SeqKit, and also thank Jim Hester , author of fasta_utilities , for advice on early performance improvements of for FASTA parsing and Brian Bushnell , author of BBMaps , for advice on naming SeqKit and adding accuracy evaluation in benchmarks. We also thank Nicholas C. Wu from the Scripps Research Institute, USA for commenting on the manuscript and Guangchuang Yu from State Key Laboratory of Emerging Infectious Diseases, The University of Hong Kong, HK for advice on the manuscript. We thank Li Peng for reporting many bugs.","title":"Acknowledgements"},{"location":"#contact","text":"Email me for any problem when using seqkit. shenwei356(at)gmail.com Create an issue to report bugs, propose new functions or ask for help.","title":"Contact"},{"location":"#license","text":"MIT License","title":"License"},{"location":"benchmark/","text":"Benchmark Softwares seqkit . (Go). Version v0.3.1.1 . Compiled with Go 1.7rc5. fasta_utilities . (Perl). Version 3dcc0bc . Lots of dependencies to install. fastx_toolkit . (Perl). Version 0.0.13 . Can't handle multi-line FASTA files. seqmagick . (Python). Version 0.6.1 seqtk . (C). Version 1.1-r92-dirty . Not used: pyfaidx . (Python). Version 0.4.7.1 . Not used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp. A Python script memusg was used to compute running time and peak memory usage of a process. Features Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats support Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation -- Yes Yes Yes Yes -- Filtering by size Indirect Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 2 : See usage for detailed options of seqkit. Datasets All test data is available here: seqkit-benchmark-data.tar.gz (2.2G) dataset_A.fa - large number of short sequences Dataset A is reference genomes DNA sequences of gastrointestinal tract from NIH Human Microbiome Project : Gastrointestinal_tract.nuc.fsa (FASTA format, ~2.7G). dataset_B.fa - small number of large sequences Dataset B is Human genome from ensembl . Genome DNA: Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz (Gzipped FASTA file, ~900M) . Decompress it and rename to dataset_B.fa (~2.9G). GTF file: Homo_sapiens.GRCh38.84.gtf.gz (~44M) BED file: Homo_sapiens.GRCh38.84.bed.gz was converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command $ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c > Homo_sapiens.GRCh38.84.bed.gz dataset_C.fq \u2013 Illumina single end reads (SE100) Dataset C is Illumina single end (SE 100bp) reads file (~2.2G). Summary $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100 Sequence ID list Parts of sequences IDs was sampled and shuffled from original data. They were used in test of extracting sequences by ID list. Commands: $ seqkit sample -p 0.3 dataset_A.fa | seqkit seq --name --only-id | shuf > ids_A.txt $ seqkit sample -p 0.3 dataset_B.fa | seqkit seq --name --only-id | shuf > ids_B.txt $ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf > ids_C.txt Numbers: $ wc -l ids*.txt 20138 ids_A.txt 58 ids_B.txt 2754516 ids_C.txt BED file Only BED data of chromosome 19 was used in test of subsequence with BED file: $ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c > chr19.bed.gz Platform PC: CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads RAM: DDR3 1600MHz, 12GB SSD: SAMSUNG 850 EVO 250G, SATA-3 OS: Fedora 24 (Scientific KDE spin), Kernal: 4.6.4-301.fc24.x86_64 Softwares: Perl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi Python: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2 Tests Automatic benchmark and plotting scripts are available at: https://github.com/shenwei356/seqkit/tree/master/benchmark . All tests were repeated 3 times, and average time and peak memory ware used for plotting. All data were readed once before tests began to minimize the influence of page cache. Output sequences of all softwares were not wrapped to fixed length. Test 1. Reverse Complement revcom_biogo ( source , binary ), a tool written in Golang (compiled with Go 1.6.3) using biogo (Version 7ebd71b ) package, was also used for comparison of FASTA file parsing performance. Note that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others. Commands Test 2. Extracting sequences by ID list Commands Test 3. Sampling by number Note that different softwares have different sampling strategies, the peak memory depends on size of sampled sequences and the results may not be the same. Commands Test 4. Removing duplicates by sequence content Commands Test 5. Subsequence with BED file Commands Results seqkit version: v0.3.1.1 FASTA: FASTQ: Test of multiple threads: From the results, 2 threads/CPU is enough, so the default threads of seqkit is 2. Tests on different file sizes Files are generated by replicating Human genome chr1 for N times. /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Benchmark"},{"location":"benchmark/#benchmark","text":"","title":"Benchmark"},{"location":"benchmark/#softwares","text":"seqkit . (Go). Version v0.3.1.1 . Compiled with Go 1.7rc5. fasta_utilities . (Perl). Version 3dcc0bc . Lots of dependencies to install. fastx_toolkit . (Perl). Version 0.0.13 . Can't handle multi-line FASTA files. seqmagick . (Python). Version 0.6.1 seqtk . (C). Version 1.1-r92-dirty . Not used: pyfaidx . (Python). Version 0.4.7.1 . Not used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp. A Python script memusg was used to compute running time and peak memory usage of a process.","title":"Softwares"},{"location":"benchmark/#features","text":"Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats support Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation -- Yes Yes Yes Yes -- Filtering by size Indirect Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 2 : See usage for detailed options of seqkit.","title":"Features"},{"location":"benchmark/#datasets","text":"All test data is available here: seqkit-benchmark-data.tar.gz (2.2G)","title":"Datasets"},{"location":"benchmark/#dataset_afa-large-number-of-short-sequences","text":"Dataset A is reference genomes DNA sequences of gastrointestinal tract from NIH Human Microbiome Project : Gastrointestinal_tract.nuc.fsa (FASTA format, ~2.7G).","title":"dataset_A.fa - large number of short sequences"},{"location":"benchmark/#dataset_bfa-small-number-of-large-sequences","text":"Dataset B is Human genome from ensembl . Genome DNA: Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz (Gzipped FASTA file, ~900M) . Decompress it and rename to dataset_B.fa (~2.9G). GTF file: Homo_sapiens.GRCh38.84.gtf.gz (~44M) BED file: Homo_sapiens.GRCh38.84.bed.gz was converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command $ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c > Homo_sapiens.GRCh38.84.bed.gz","title":"dataset_B.fa - small number of large sequences"},{"location":"benchmark/#dataset_cfq-illumina-single-end-reads-se100","text":"Dataset C is Illumina single end (SE 100bp) reads file (~2.2G). Summary $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100","title":"dataset_C.fq \u2013 Illumina single end reads (SE100)"},{"location":"benchmark/#sequence-id-list","text":"Parts of sequences IDs was sampled and shuffled from original data. They were used in test of extracting sequences by ID list. Commands: $ seqkit sample -p 0.3 dataset_A.fa | seqkit seq --name --only-id | shuf > ids_A.txt $ seqkit sample -p 0.3 dataset_B.fa | seqkit seq --name --only-id | shuf > ids_B.txt $ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf > ids_C.txt Numbers: $ wc -l ids*.txt 20138 ids_A.txt 58 ids_B.txt 2754516 ids_C.txt","title":"Sequence ID list"},{"location":"benchmark/#bed-file","text":"Only BED data of chromosome 19 was used in test of subsequence with BED file: $ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c > chr19.bed.gz","title":"BED file"},{"location":"benchmark/#platform","text":"PC: CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads RAM: DDR3 1600MHz, 12GB SSD: SAMSUNG 850 EVO 250G, SATA-3 OS: Fedora 24 (Scientific KDE spin), Kernal: 4.6.4-301.fc24.x86_64 Softwares: Perl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi Python: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2","title":"Platform"},{"location":"benchmark/#tests","text":"Automatic benchmark and plotting scripts are available at: https://github.com/shenwei356/seqkit/tree/master/benchmark . All tests were repeated 3 times, and average time and peak memory ware used for plotting. All data were readed once before tests began to minimize the influence of page cache. Output sequences of all softwares were not wrapped to fixed length.","title":"Tests"},{"location":"benchmark/#test-1-reverse-complement","text":"revcom_biogo ( source , binary ), a tool written in Golang (compiled with Go 1.6.3) using biogo (Version 7ebd71b ) package, was also used for comparison of FASTA file parsing performance. Note that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others. Commands","title":"Test 1. Reverse Complement"},{"location":"benchmark/#test-2-extracting-sequences-by-id-list","text":"Commands","title":"Test 2. Extracting sequences by ID list"},{"location":"benchmark/#test-3-sampling-by-number","text":"Note that different softwares have different sampling strategies, the peak memory depends on size of sampled sequences and the results may not be the same. Commands","title":"Test 3. Sampling by number"},{"location":"benchmark/#test-4-removing-duplicates-by-sequence-content","text":"Commands","title":"Test 4. Removing duplicates by sequence content"},{"location":"benchmark/#test-5-subsequence-with-bed-file","text":"Commands","title":"Test 5. Subsequence with BED file"},{"location":"benchmark/#results","text":"seqkit version: v0.3.1.1 FASTA: FASTQ:","title":"Results"},{"location":"benchmark/#test-of-multiple-threads","text":"From the results, 2 threads/CPU is enough, so the default threads of seqkit is 2.","title":"Test of multiple threads:"},{"location":"benchmark/#tests-on-different-file-sizes","text":"Files are generated by replicating Human genome chr1 for N times. /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Tests on different file sizes"},{"location":"bioinf/","text":"","title":"Bioinf"},{"location":"download/","text":"Download SeqKit is implemented in Go programming language, executable binary files for most popular operating systems are freely available in release page. Latest Version SeqKit v0.12.1 seqkit bam : add colorised and pretty printed output, by @bsipos . #110 seqkit locate/grep : fix bug of -m , when query contains letters not in subject sequences. #124 seqkit split2 : new flag -l/--by-length for splitting into chunks of N bases. seqkit fx2tab : new flag -I/--case-sensitive for calculating case sensitive base content. #108 add missing column name for averge quality for -H -q . #115 fix output of -n/--only-name , do not write empty columns of sequence and quality. #104 , #115 seqkit seq : new flag -k/--color : colorize sequences. Please cite W Shen* , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE***. doi:10.1371/journal.pone.0163962 . Links Tips run seqkit version to check update !!! run seqkit genautocomplete to update Bash completion !!! OS Arch File, \u4e2d\u56fd\u955c\u50cf Download Count Linux 32-bit seqkit_linux_386.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux 64-bit seqkit_linux_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf OS X 32-bit seqkit_darwin_386.tar.gz , \u4e2d\u56fd\u955c\u50cf OS X 64-bit seqkit_darwin_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 32-bit seqkit_windows_386.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 64-bit seqkit_windows_amd64.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Installation Method 1: Download binaries (latest stable/dev version) Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 . Method 2: Install via conda (latest stable version) conda install -c bioconda seqkit Method 3: Install via homebrew (latest stable version) brew install brewsci/bio/seqkit Method 4: For Go developer (latest stable/dev version) go get -u github.com/shenwei356/seqkit/seqkit Method 5: Docker based installation (latest stable/dev version) Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest Bash-completion Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: run: seqkit genautocomplete create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done Release History SeqKit v0.12.0 seqkit : fix checking input file existence. new global flag --infile-list for long list of input files, if given, they are appended to files from cli arguments. seqkit faidx : supporting \"truncated\" (no ending newline charactor) file. seqkit seq : do not force switching on -g when using -m/-M . show recommendation if flag -t/--seq-type is not DNA/RNA when computing complement sequence. #103 seqkit translate : supporting multiple frames. #96 seqkit grep/locate : add detection and warning for space existing in search pattern/sequence. speed improvement (2X) for -m/--max-mismatch . shenwei356/bwt/issues/3 seqkit locate : new flag -M/--hide-matched for hiding matched sequences. #98 new flag -r/--use-regexp for explicitly using regular expression, so improve speed of default index operation. And you have to switch this on if using regexp now . #101 new flag -F/--use-fmi for improving search speed for lots of sequence patterns . seqkit rename : making IDs unique across multiple files, and can write into multiple files. #100 seqkit sample : fix stdin checking for flag -2 . #102 . seqkit rename/split/split2 : fix detection of existed outdir. split split : fix bug of seqkit split -i -2 and parallizing it. seqkit version : checking update is optional ( -u ). SeqKit v0.11.0 seqkit : fix hanging when reading from truncated gzip file. new commands: seqkit amplicon : retrieve amplicon (or specific region around it) via primer(s). new commands by @bsipos : seqkit watch : monitoring and online histograms of sequence features. seqkit sana : sanitize broken single line fastq files. seqkit fish : look for short sequences in larger sequences using local alignment. seqkit bam : monitoring and online histograms of BAM record features. seqkit grep/locate : reduce memory occupation when using flag -m/--max-mismatch . seqkit seq : fix panic of computing complement sequence for long sequences containing illegal letters without flag -v on. #84 SeqKit v0.10.2 seqkit : fix bug of parsing sequence ID delimited by tab ( \\t ). #78 seqkit grep : better logic of --delete-matched . seqkit common/rmdup/split : use xxhash to replace MD5 when comparing with sequence, discard flag -m/--md5 . seqkit stats : new flag -b/--basename for outputting basename instead of full path. SeqKit v0.10.1 seqkit fx2tab : new option -q/--avg-qual for outputting average read quality. #60 seqkit grep/locate : fix support of X when using -d/--degenerate . #61 seqkit translate : new flag -M/--init-codon-as-M to translate initial codon at beginning to 'M'. #62 translates --- to - for aligned DNA/RNA, flag -X needed. #63 supports codons containing ambiguous bases, e.g., GGN->G , ATH->I . #64 new flag -l/--list-transl-table to show details of translate table N new flag -l/--list-transl-table-with-amb-codons to show details of translate table N (including ambigugous codons) seqkit split/split2 , fix bug of ignoring -O when reading from stdin. SeqKit v0.10.0 seqkit : report error when input is directory. new command seqkit mutate : edit sequence (point mutation, insertion, deletion). SeqKit v0.9.3 seqkit stats : fix panic for empty file. #57 seqkit translate : add flag -x/--allow-unknown-codon to translate unknown codon to X . #56 SeqKit v0.9.2 seqkit : stricter checking for value of global flag -t/--seq-type . seqkit sliding : fix bug for flag -g/--greedy . #54 seqkit translate : fix bug for frame < 0. #55 seqkit seq : add TAB to default blank characters (flag -G/--gap-letters ), and fix filter result when using flag -g/--remove-gaps along with -m/--min-len or -M/--max-len SeqKit v0.9.1 seqkit faidx : fix bug of retrieving subsequence with multiple regions on same sequence. #48 seqkit sort/shuffle/split : fix bug when using -2/--two-pass to process .gz files. #52 SeqKit v0.9.0 seqkit : better handle of empty file, no error message shown. #36 new subcommand seqkit split2 : split sequences into files by size/parts (FASTA, PE/SE FASTQ). #35 new subcommand seqkit translate : translate DNA/RNA to protein sequence. #28 seqkit sort : fix bug when using -2 -i , and add support for sorting in natural order. #39 seqkit grep and seqkit locate : add experimental support of mismatch when searching subsequences. #14 seqkit stats : add stats of Q20 and Q30 for FASTQ. #45 SeqKit v0.8.1 seqkit : do not call pigz or gzip for decompressing gzipped file any more. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . seqkit subseq : fix bug of missing quality when using --gtf or --bed seqkit stats : parallelize counting files, it's much faster for lots of small files, especially for files on SSD SeqKit v0.8.0 seqkit , stricter FASTA/Q format requirement , i.e., must starting with > or @ . seqkit , fix output format for FASTQ files containing zero-length records , yes this happens . seqkit , add amino acid code O (pyrrolysine) and U (selenocysteine). seqkit replace , add flag --nr-width to fill leading 0s for {nr} , useful for preparing sequence submission (\">strain_00001 XX\", \">strain_00002 XX\"). seqkit subseq , require BED file to be tab-delimited. SeqKit v0.7.2 seqkit tab2fx : fix a concurrency bug that occurs in low proprobability when only 1-column data provided. seqkit stats : add quartiles of sequence length seqkit faidx : add support for retrieving subsequence using seq ID and region, which is similar with \"samtools faidx\" but has some extra features SeqKit v0.7.1 seqkit convert : fix bug of read quality containing only 3 or less values. shenwei356/bio/issues/3 seqkit stats : add option -T/--tabular to output in machine-friendly tabular format. #23 seqkit common : increase speed and decrease memory occupation, and add some notes. fix some typos. #22 suggestion: please install pigz to gain better parsing performance for gzipped data . SeqKit v0.7.0 add new command convert for converting FASTQ quality encoding between Sanger, Solexa and Illumina. Thanks suggestion from @cviner ( #18 ). usage & example . add new command range for printing FASTA/Q records in a range (start:end). #19 . usage & example . add new command concate for concatenating sequences with same ID from multiple files. usage & example . SeqKit v0.6.0 add new command genautocomplete to generate shell autocompletion script! ( #17 ) add new command seqkit dup for duplicating sequences ( #16 ) seqkit stats -a does not show L50 which may brings confusion ( #15 ) seqkit subseq --bed : more robust for bad BED files SeqKit v0.5.5 Increasing speed of reading .gz file by utilizing gzip (1.3X), it would be much faster if you installed pigz (2X). Fixing colorful output in Windows seqkit locate : add flag --gtf and --bed to output GTF/BED6 format, so the result can be used in seqkit subseq . seqkit subseq : fix bug of --bed , add checking coordinate. SeqKit v0.5.4 seqkit subseq --gtf , add flag --gtf-tag to set tag that's outputted as sequence comment fix seqkit split and seqkit sample : forget not to wrap sequence and quality in output for FASTQ format compile with go1.8.1 SeqKit v0.5.3 seqkit grep : fix bug when using seqkit grep -r -f patternfile : all records will be retrived due to failing to discarding the blank pattern ( \"\" ). #11 SeqKit v0.5.2 seqkit stats -a and seqkit seq -g -G : change default gap letters from '- ' to '- .' seqkit subseq : fix bug of range overflow when using -d/--down-stream or -u/--up-stream for retieving subseq using BED ( --beb ) or GTF ( --gtf ) file. seqkit locate : add flag -G/--non-greedy , non-greedy mode, faster but may miss motifs overlaping with others. SeqKit v0.5.1 seqkit restart : fix bug of flag parsing SeqKit v0.5.0 new command seqkit restart , for resetting start position for circular genome . seqkit sliding : add flag -g/--greedy , exporting last subsequences even shorter than windows size. seqkit seq : add flag -m/--min-len and -M/--max-len to filter sequences by length . rename flag -G/--gap-letter to -G/--gap-letters . seqkit stat : renamed to seqkit stats , don't worry, old name is still available as an alias. add new flag -a/all , for all statistics, including sum_gap , N50 , and L50 . SeqKit v0.4.5 seqkit seq : fix bug of failing to reverse quality of FASTQ sequence SeqKit v0.4.4 seqkit locate : fix bug of missing regular-expression motifs containing non-DNA characters (e.g., ACT.{6,7}CGG ) from motif file ( -f ). compiled with go v1.8. SeqKit v0.4.3 fix bug of seqkit stat : min_len always be 0 in versions: v0.4.0, v0.4.1, v0.4.2 SeqKit v0.4.2 fix header information of seqkit subseq when restriving up- and down-steam sequences using GTF/BED file. SeqKit v0.4.1 enchancement: remove redudant regions for seqkit locate . SeqKit v0.4.0 fix bug of seqkit locate , e.g, only find two locations ( 1-4 , 7-10 , missing 4-7 ) of ACGA in ACGACGACGA . better output of seqkit stat for empty file. SeqKit v0.3.9 fix bug of region selection for blank sequences. affected commands include seqkit subseq --region , seqkit grep --region , seqkit split --by-region . compile with go1.8beta1. SeqKit v0.3.8.1 enhancement and bugfix of seqkit common : two or more same files allowed, fix log information of number of extracted sequences in the first file. SeqKit v0.3.8 enhancement of seqkit common : better handling of files containing replicated sequences SeqKit v0.3.7 fix bug in seqkit split --by-id when sequence ID contains invalid characters for system path. add more flags validation for seqkit replace . enhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added. changes: do not wrap sequence and quality in output for FASTQ format. SeqKit v0.3.6 add new feature for seqkit grep : new flag -R ( --region ) for specifying sequence region for searching. SeqKit v0.3.5 fig bug of seqkit grep : flag -i ( --ignore-case ) did not work when not using regular expression SeqKit v0.3.4.1 improve performance of reading (~10%) and writing (100%) gzip-compressed file by using github.com/klauspost/pgzip package add citation SeqKit v0.3.4 bugfix: seq wrongly handles only the first one sequence file when multiple files given new feature: fx2tab can output alphabet letters of a sequence by flag -a ( --alphabet ) new feature: new flag -K ( --keep-key ) for replace , when replacing with key-value file, one can choose keeping the key as value or not. SeqKit v0.3.3 fix bug of seqkit replace , wrongly starting from 2 when using {nr} in -r ( --replacement ) new feature: seqkit replace supports replacement symbols {nr} (record number) and {kv} (corresponding value of the key ($1) by key-value file) SeqKit v0.3.2 fix bug of seqkit split , error when target file is in a directory. improve performance of seqkit spliding for big sequences, and output last part even if it's shorter than window sze, output of FASTQ is also supported. SeqKit v0.3.1.1 compile with go1.7rc5, with higher performance and smaller size of binary file SeqKit v0.3.1 improve speed of seqkit locate SeqKit v0.3.0 use fork of github.com/brentp/xopen, using zcat for speedup of .gz file reading on *nix systems. improve speed of parsing sequence ID when creating FASTA index reduce memory usage of seqkit subseq --gtf fix bug of seqkit subseq when using flag --id-ncbi fix bug of seqkit split , outdir error fix bug of seqkit seq -p , last base is wrongly failed to convert when sequence length is odd. add \"sum_len\" result for output of seqkit stat seqkit v0.2.9 fix minor bug of seqkit split and seqkit shuffle , header name error due to improper use of pointer add option -O (--out-dir) to seqkit split seqkit v0.2.8 improve speed of parsing sequence ID, not using regular expression for default --id-regexp improve speed of record outputing for small-size sequences fix minor bug: seqkit seq for blank record update benchmark result seqkit v0.2.7 reduce memory usage by optimize the outputing of sequences. detail: using BufferedByteSliceWrapper to resuse bytes.Buffer. reduce memory usage and improve speed by using custom buffered reading mechanism, instead of using standard library bufio , which is slow for large genome sequence. discard strategy of \"buffer\" and \"chunk\" of FASTA/Q records, just parse records one by one. delete global flags -c (--chunk-size) and -b (--buffer-size) . add function testing scripts seqkit v0.2.6 fix bug of seqkit subseq : Inplace subseq method leaded to wrong result seqkit v0.2.5.1 fix a bug of seqkit subseq : chromesome name was not be converting to lower case when using --gtf or --bed seqkit v0.2.5 fix a serious bug brought in v0.2.3 , using unsafe method to convert string to []byte add awk-like built-in variable of record number ( {NR} ) for seqkit replace seqkit v0.2.4.1 fix several bugs from library bio , affected situations: Locating patterns in sequences by pattern FASTA file: seqkit locate -f Reading FASTQ file with record of which the quality starts with + add command version seqkit v0.2.4 add subcommand head seqkit v0.2.3 reduce memory occupation by avoid copy data when convert string to []byte speedup reverse-complement by avoid repeatly calling functions seqkit v0.2.2 reduce memory occupation of subcommands that use FASTA index seqkit v0.2.1 improve performance of outputing. fix bug of seqkit seq -g for FASTA fromat some other minor fix of code and docs update benchmark results seqkit v0.2.0 reduce memory usage of writing output fix bug of subseq , shuffle , sort when reading from stdin reduce memory usage of faidx make validating sequences an optional option in seq command, it saves some time. seqkit v0.1.9 using custom FASTA index file extension: .seqkit.fai reducing memory usage of sample --number --two-pass change default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer seqkit v0.1.8 add subcommand rename to rename duplicated IDs add subcommand faidx to create FASTA index file utilize faidx to improve performance of subseq shuffle , sort and split support two-pass mode (by flag -2 ) with faidx to reduce memory usage. document update seqkit v0.1.7 add support for (multi-line) FASTQ format update document, add technical details rename subcommands fa2tab and tab2fa to fx2tab and tab2fx add subcommand fq2fa add column \"seq_format\" to stat add global flag -b ( --bufer-size ) little change of flag in subseq and some other commands seqkit v0.1.6 add subcommand replace seqkit v0.1.5.2 fix bug of grep , when not using flag -r , flag -i will not take effect. seqkit v0.1.5.1 fix result of seqkit sample -n fix benchmark script seqkit v0.1.5 add global flag --id-ncbi add flag -d ( --dup-seqs-file ) and -D ( --dup-num-file ) for subcommand rmdup make using MD5 as an optional flag -m ( --md5 ) in subcommand rmdup and common fix file name suffix of seqkit split result minor modification of sliding output seqkit v0.1.4.1 change alignment of stat output preciser CPUs number control seqkit v0.1.4 add subcommand sort improve subcommand subseq : supporting of getting subsequences by GTF and BED files change name format of sliding result prettier output of stat seqkit v0.1.3.1 Performance improvement by reducing time of cleaning spaces Document update seqkit v0.1.3 Further performance improvement Rename sub command extract to grep Change default value of flag --threads back CPU number of current device, change default value of flag --chunk-size back 10000 sequences. Update benchmark seqkit v0.1.2 Add flag --dna2rna and --rna2dna to subcommand seq . seqkit v0.1.1 5.5X speedup of FASTA file parsing by avoid using regular expression to remove spaces ( detail ) and using slice indexing instead of map to validate letters ( detail ) Change default value of global flag -- thread to 1. Since most of the subcommands are I/O intensive, For computation intensive jobs, like extract and locate, you may set a bigger value. Change default value of global flag --chunk-size to 100. Add subcommand stat Fix bug of failing to automatically detect alphabet when only one record in file. seqkit v0.1 first release of seqkit /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Download"},{"location":"download/#download","text":"SeqKit is implemented in Go programming language, executable binary files for most popular operating systems are freely available in release page.","title":"Download"},{"location":"download/#latest-version","text":"SeqKit v0.12.1 seqkit bam : add colorised and pretty printed output, by @bsipos . #110 seqkit locate/grep : fix bug of -m , when query contains letters not in subject sequences. #124 seqkit split2 : new flag -l/--by-length for splitting into chunks of N bases. seqkit fx2tab : new flag -I/--case-sensitive for calculating case sensitive base content. #108 add missing column name for averge quality for -H -q . #115 fix output of -n/--only-name , do not write empty columns of sequence and quality. #104 , #115 seqkit seq : new flag -k/--color : colorize sequences.","title":"Latest Version"},{"location":"download/#please-cite","text":"W Shen* , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE***. doi:10.1371/journal.pone.0163962 .","title":"Please cite"},{"location":"download/#links","text":"Tips run seqkit version to check update !!! run seqkit genautocomplete to update Bash completion !!! OS Arch File, \u4e2d\u56fd\u955c\u50cf Download Count Linux 32-bit seqkit_linux_386.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux 64-bit seqkit_linux_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf OS X 32-bit seqkit_darwin_386.tar.gz , \u4e2d\u56fd\u955c\u50cf OS X 64-bit seqkit_darwin_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 32-bit seqkit_windows_386.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 64-bit seqkit_windows_amd64.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf","title":"Links"},{"location":"download/#installation","text":"","title":"Installation"},{"location":"download/#method-1-download-binaries-latest-stabledev-version","text":"Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 .","title":"Method 1: Download binaries (latest stable/dev version)"},{"location":"download/#method-2-install-via-conda-latest-stable-version","text":"conda install -c bioconda seqkit","title":"Method 2: Install via conda (latest stable version)"},{"location":"download/#method-3-install-via-homebrew-latest-stable-version","text":"brew install brewsci/bio/seqkit","title":"Method 3: Install via homebrew (latest stable version)"},{"location":"download/#method-4-for-go-developer-latest-stabledev-version","text":"go get -u github.com/shenwei356/seqkit/seqkit","title":"Method 4: For Go developer (latest stable/dev version)"},{"location":"download/#method-5-docker-based-installation-latest-stabledev-version","text":"Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest","title":"Method 5: Docker based installation (latest stable/dev version)"},{"location":"download/#bash-completion","text":"Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: run: seqkit genautocomplete create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done","title":"Bash-completion"},{"location":"download/#release-history","text":"SeqKit v0.12.0 seqkit : fix checking input file existence. new global flag --infile-list for long list of input files, if given, they are appended to files from cli arguments. seqkit faidx : supporting \"truncated\" (no ending newline charactor) file. seqkit seq : do not force switching on -g when using -m/-M . show recommendation if flag -t/--seq-type is not DNA/RNA when computing complement sequence. #103 seqkit translate : supporting multiple frames. #96 seqkit grep/locate : add detection and warning for space existing in search pattern/sequence. speed improvement (2X) for -m/--max-mismatch . shenwei356/bwt/issues/3 seqkit locate : new flag -M/--hide-matched for hiding matched sequences. #98 new flag -r/--use-regexp for explicitly using regular expression, so improve speed of default index operation. And you have to switch this on if using regexp now . #101 new flag -F/--use-fmi for improving search speed for lots of sequence patterns . seqkit rename : making IDs unique across multiple files, and can write into multiple files. #100 seqkit sample : fix stdin checking for flag -2 . #102 . seqkit rename/split/split2 : fix detection of existed outdir. split split : fix bug of seqkit split -i -2 and parallizing it. seqkit version : checking update is optional ( -u ). SeqKit v0.11.0 seqkit : fix hanging when reading from truncated gzip file. new commands: seqkit amplicon : retrieve amplicon (or specific region around it) via primer(s). new commands by @bsipos : seqkit watch : monitoring and online histograms of sequence features. seqkit sana : sanitize broken single line fastq files. seqkit fish : look for short sequences in larger sequences using local alignment. seqkit bam : monitoring and online histograms of BAM record features. seqkit grep/locate : reduce memory occupation when using flag -m/--max-mismatch . seqkit seq : fix panic of computing complement sequence for long sequences containing illegal letters without flag -v on. #84 SeqKit v0.10.2 seqkit : fix bug of parsing sequence ID delimited by tab ( \\t ). #78 seqkit grep : better logic of --delete-matched . seqkit common/rmdup/split : use xxhash to replace MD5 when comparing with sequence, discard flag -m/--md5 . seqkit stats : new flag -b/--basename for outputting basename instead of full path. SeqKit v0.10.1 seqkit fx2tab : new option -q/--avg-qual for outputting average read quality. #60 seqkit grep/locate : fix support of X when using -d/--degenerate . #61 seqkit translate : new flag -M/--init-codon-as-M to translate initial codon at beginning to 'M'. #62 translates --- to - for aligned DNA/RNA, flag -X needed. #63 supports codons containing ambiguous bases, e.g., GGN->G , ATH->I . #64 new flag -l/--list-transl-table to show details of translate table N new flag -l/--list-transl-table-with-amb-codons to show details of translate table N (including ambigugous codons) seqkit split/split2 , fix bug of ignoring -O when reading from stdin. SeqKit v0.10.0 seqkit : report error when input is directory. new command seqkit mutate : edit sequence (point mutation, insertion, deletion). SeqKit v0.9.3 seqkit stats : fix panic for empty file. #57 seqkit translate : add flag -x/--allow-unknown-codon to translate unknown codon to X . #56 SeqKit v0.9.2 seqkit : stricter checking for value of global flag -t/--seq-type . seqkit sliding : fix bug for flag -g/--greedy . #54 seqkit translate : fix bug for frame < 0. #55 seqkit seq : add TAB to default blank characters (flag -G/--gap-letters ), and fix filter result when using flag -g/--remove-gaps along with -m/--min-len or -M/--max-len SeqKit v0.9.1 seqkit faidx : fix bug of retrieving subsequence with multiple regions on same sequence. #48 seqkit sort/shuffle/split : fix bug when using -2/--two-pass to process .gz files. #52 SeqKit v0.9.0 seqkit : better handle of empty file, no error message shown. #36 new subcommand seqkit split2 : split sequences into files by size/parts (FASTA, PE/SE FASTQ). #35 new subcommand seqkit translate : translate DNA/RNA to protein sequence. #28 seqkit sort : fix bug when using -2 -i , and add support for sorting in natural order. #39 seqkit grep and seqkit locate : add experimental support of mismatch when searching subsequences. #14 seqkit stats : add stats of Q20 and Q30 for FASTQ. #45 SeqKit v0.8.1 seqkit : do not call pigz or gzip for decompressing gzipped file any more. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . seqkit subseq : fix bug of missing quality when using --gtf or --bed seqkit stats : parallelize counting files, it's much faster for lots of small files, especially for files on SSD SeqKit v0.8.0 seqkit , stricter FASTA/Q format requirement , i.e., must starting with > or @ . seqkit , fix output format for FASTQ files containing zero-length records , yes this happens . seqkit , add amino acid code O (pyrrolysine) and U (selenocysteine). seqkit replace , add flag --nr-width to fill leading 0s for {nr} , useful for preparing sequence submission (\">strain_00001 XX\", \">strain_00002 XX\"). seqkit subseq , require BED file to be tab-delimited. SeqKit v0.7.2 seqkit tab2fx : fix a concurrency bug that occurs in low proprobability when only 1-column data provided. seqkit stats : add quartiles of sequence length seqkit faidx : add support for retrieving subsequence using seq ID and region, which is similar with \"samtools faidx\" but has some extra features SeqKit v0.7.1 seqkit convert : fix bug of read quality containing only 3 or less values. shenwei356/bio/issues/3 seqkit stats : add option -T/--tabular to output in machine-friendly tabular format. #23 seqkit common : increase speed and decrease memory occupation, and add some notes. fix some typos. #22 suggestion: please install pigz to gain better parsing performance for gzipped data . SeqKit v0.7.0 add new command convert for converting FASTQ quality encoding between Sanger, Solexa and Illumina. Thanks suggestion from @cviner ( #18 ). usage & example . add new command range for printing FASTA/Q records in a range (start:end). #19 . usage & example . add new command concate for concatenating sequences with same ID from multiple files. usage & example . SeqKit v0.6.0 add new command genautocomplete to generate shell autocompletion script! ( #17 ) add new command seqkit dup for duplicating sequences ( #16 ) seqkit stats -a does not show L50 which may brings confusion ( #15 ) seqkit subseq --bed : more robust for bad BED files SeqKit v0.5.5 Increasing speed of reading .gz file by utilizing gzip (1.3X), it would be much faster if you installed pigz (2X). Fixing colorful output in Windows seqkit locate : add flag --gtf and --bed to output GTF/BED6 format, so the result can be used in seqkit subseq . seqkit subseq : fix bug of --bed , add checking coordinate. SeqKit v0.5.4 seqkit subseq --gtf , add flag --gtf-tag to set tag that's outputted as sequence comment fix seqkit split and seqkit sample : forget not to wrap sequence and quality in output for FASTQ format compile with go1.8.1 SeqKit v0.5.3 seqkit grep : fix bug when using seqkit grep -r -f patternfile : all records will be retrived due to failing to discarding the blank pattern ( \"\" ). #11 SeqKit v0.5.2 seqkit stats -a and seqkit seq -g -G : change default gap letters from '- ' to '- .' seqkit subseq : fix bug of range overflow when using -d/--down-stream or -u/--up-stream for retieving subseq using BED ( --beb ) or GTF ( --gtf ) file. seqkit locate : add flag -G/--non-greedy , non-greedy mode, faster but may miss motifs overlaping with others. SeqKit v0.5.1 seqkit restart : fix bug of flag parsing SeqKit v0.5.0 new command seqkit restart , for resetting start position for circular genome . seqkit sliding : add flag -g/--greedy , exporting last subsequences even shorter than windows size. seqkit seq : add flag -m/--min-len and -M/--max-len to filter sequences by length . rename flag -G/--gap-letter to -G/--gap-letters . seqkit stat : renamed to seqkit stats , don't worry, old name is still available as an alias. add new flag -a/all , for all statistics, including sum_gap , N50 , and L50 . SeqKit v0.4.5 seqkit seq : fix bug of failing to reverse quality of FASTQ sequence SeqKit v0.4.4 seqkit locate : fix bug of missing regular-expression motifs containing non-DNA characters (e.g., ACT.{6,7}CGG ) from motif file ( -f ). compiled with go v1.8. SeqKit v0.4.3 fix bug of seqkit stat : min_len always be 0 in versions: v0.4.0, v0.4.1, v0.4.2 SeqKit v0.4.2 fix header information of seqkit subseq when restriving up- and down-steam sequences using GTF/BED file. SeqKit v0.4.1 enchancement: remove redudant regions for seqkit locate . SeqKit v0.4.0 fix bug of seqkit locate , e.g, only find two locations ( 1-4 , 7-10 , missing 4-7 ) of ACGA in ACGACGACGA . better output of seqkit stat for empty file. SeqKit v0.3.9 fix bug of region selection for blank sequences. affected commands include seqkit subseq --region , seqkit grep --region , seqkit split --by-region . compile with go1.8beta1. SeqKit v0.3.8.1 enhancement and bugfix of seqkit common : two or more same files allowed, fix log information of number of extracted sequences in the first file. SeqKit v0.3.8 enhancement of seqkit common : better handling of files containing replicated sequences SeqKit v0.3.7 fix bug in seqkit split --by-id when sequence ID contains invalid characters for system path. add more flags validation for seqkit replace . enhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added. changes: do not wrap sequence and quality in output for FASTQ format. SeqKit v0.3.6 add new feature for seqkit grep : new flag -R ( --region ) for specifying sequence region for searching. SeqKit v0.3.5 fig bug of seqkit grep : flag -i ( --ignore-case ) did not work when not using regular expression SeqKit v0.3.4.1 improve performance of reading (~10%) and writing (100%) gzip-compressed file by using github.com/klauspost/pgzip package add citation SeqKit v0.3.4 bugfix: seq wrongly handles only the first one sequence file when multiple files given new feature: fx2tab can output alphabet letters of a sequence by flag -a ( --alphabet ) new feature: new flag -K ( --keep-key ) for replace , when replacing with key-value file, one can choose keeping the key as value or not. SeqKit v0.3.3 fix bug of seqkit replace , wrongly starting from 2 when using {nr} in -r ( --replacement ) new feature: seqkit replace supports replacement symbols {nr} (record number) and {kv} (corresponding value of the key ($1) by key-value file) SeqKit v0.3.2 fix bug of seqkit split , error when target file is in a directory. improve performance of seqkit spliding for big sequences, and output last part even if it's shorter than window sze, output of FASTQ is also supported. SeqKit v0.3.1.1 compile with go1.7rc5, with higher performance and smaller size of binary file SeqKit v0.3.1 improve speed of seqkit locate SeqKit v0.3.0 use fork of github.com/brentp/xopen, using zcat for speedup of .gz file reading on *nix systems. improve speed of parsing sequence ID when creating FASTA index reduce memory usage of seqkit subseq --gtf fix bug of seqkit subseq when using flag --id-ncbi fix bug of seqkit split , outdir error fix bug of seqkit seq -p , last base is wrongly failed to convert when sequence length is odd. add \"sum_len\" result for output of seqkit stat seqkit v0.2.9 fix minor bug of seqkit split and seqkit shuffle , header name error due to improper use of pointer add option -O (--out-dir) to seqkit split seqkit v0.2.8 improve speed of parsing sequence ID, not using regular expression for default --id-regexp improve speed of record outputing for small-size sequences fix minor bug: seqkit seq for blank record update benchmark result seqkit v0.2.7 reduce memory usage by optimize the outputing of sequences. detail: using BufferedByteSliceWrapper to resuse bytes.Buffer. reduce memory usage and improve speed by using custom buffered reading mechanism, instead of using standard library bufio , which is slow for large genome sequence. discard strategy of \"buffer\" and \"chunk\" of FASTA/Q records, just parse records one by one. delete global flags -c (--chunk-size) and -b (--buffer-size) . add function testing scripts seqkit v0.2.6 fix bug of seqkit subseq : Inplace subseq method leaded to wrong result seqkit v0.2.5.1 fix a bug of seqkit subseq : chromesome name was not be converting to lower case when using --gtf or --bed seqkit v0.2.5 fix a serious bug brought in v0.2.3 , using unsafe method to convert string to []byte add awk-like built-in variable of record number ( {NR} ) for seqkit replace seqkit v0.2.4.1 fix several bugs from library bio , affected situations: Locating patterns in sequences by pattern FASTA file: seqkit locate -f Reading FASTQ file with record of which the quality starts with + add command version seqkit v0.2.4 add subcommand head seqkit v0.2.3 reduce memory occupation by avoid copy data when convert string to []byte speedup reverse-complement by avoid repeatly calling functions seqkit v0.2.2 reduce memory occupation of subcommands that use FASTA index seqkit v0.2.1 improve performance of outputing. fix bug of seqkit seq -g for FASTA fromat some other minor fix of code and docs update benchmark results seqkit v0.2.0 reduce memory usage of writing output fix bug of subseq , shuffle , sort when reading from stdin reduce memory usage of faidx make validating sequences an optional option in seq command, it saves some time. seqkit v0.1.9 using custom FASTA index file extension: .seqkit.fai reducing memory usage of sample --number --two-pass change default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer seqkit v0.1.8 add subcommand rename to rename duplicated IDs add subcommand faidx to create FASTA index file utilize faidx to improve performance of subseq shuffle , sort and split support two-pass mode (by flag -2 ) with faidx to reduce memory usage. document update seqkit v0.1.7 add support for (multi-line) FASTQ format update document, add technical details rename subcommands fa2tab and tab2fa to fx2tab and tab2fx add subcommand fq2fa add column \"seq_format\" to stat add global flag -b ( --bufer-size ) little change of flag in subseq and some other commands seqkit v0.1.6 add subcommand replace seqkit v0.1.5.2 fix bug of grep , when not using flag -r , flag -i will not take effect. seqkit v0.1.5.1 fix result of seqkit sample -n fix benchmark script seqkit v0.1.5 add global flag --id-ncbi add flag -d ( --dup-seqs-file ) and -D ( --dup-num-file ) for subcommand rmdup make using MD5 as an optional flag -m ( --md5 ) in subcommand rmdup and common fix file name suffix of seqkit split result minor modification of sliding output seqkit v0.1.4.1 change alignment of stat output preciser CPUs number control seqkit v0.1.4 add subcommand sort improve subcommand subseq : supporting of getting subsequences by GTF and BED files change name format of sliding result prettier output of stat seqkit v0.1.3.1 Performance improvement by reducing time of cleaning spaces Document update seqkit v0.1.3 Further performance improvement Rename sub command extract to grep Change default value of flag --threads back CPU number of current device, change default value of flag --chunk-size back 10000 sequences. Update benchmark seqkit v0.1.2 Add flag --dna2rna and --rna2dna to subcommand seq . seqkit v0.1.1 5.5X speedup of FASTA file parsing by avoid using regular expression to remove spaces ( detail ) and using slice indexing instead of map to validate letters ( detail ) Change default value of global flag -- thread to 1. Since most of the subcommands are I/O intensive, For computation intensive jobs, like extract and locate, you may set a bigger value. Change default value of global flag --chunk-size to 100. Add subcommand stat Fix bug of failing to automatically detect alphabet when only one record in file. seqkit v0.1 first release of seqkit /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Release History"},{"location":"faq/","text":"FAQ on FASTA/Q manipulations This page was originally written as the section FASTA/Q manipulations of The Biostar Handbook: A Beginner's Guide to Bioinformatics ( discussion on Biostars.org ) . This page illustrates common FASTA/Q manipulations using SeqKit . Some other utilities, including csvtk (CSV/TSV toolkit) and shell commands were also used. Note: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or in stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common usage but you can always use it on the other type as well. Example data How to produce an overview of FASTQ files? How to get GC content of every sequence in FASTA/Q file? How to extract sequences subset from FASTA/Q file with name/ID list file? How to find FASTA/Q sequences containing degenerate bases and locate them? How to remove duplicated FASTA/Q records with same sequences? How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? How to sort huge number of FASTA sequences by length? How to split FASTA sequences according to information in header? How to search and replace FASTA header with known character strings from a text file? How to extract paired reads from two paired-end reads file? How to concatenate two FASTA sequences in to one? Example data One FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein sequences from NCBI RefSeq database, 60+40M) are used. wget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz How to produce an overview of FASTQ files? Sequence format and type are automatically detected. $ seqkit stat *.gz file format type num_seqs sum_len min_len avg_len max_len duplicated-reads.fq.gz FASTQ DNA 15,000 1,515,000 101 101 101 viral.1.1.genomic.fna.gz FASTA DNA 7,048 203,325,120 200 28,848.6 2,473,870 viral.1.protein.faa.gz FASTA Protein 252,611 62,024,702 5 245.5 8,960 How to get GC content of every sequence in FASTA/Q file? seqkit fx2tab converts FASTA/Q to 3-column tabular format (1th: name/ID, 2nd: sequence, 3rd: quality), and can also provides various information in new columns, including sequence length, GC content/GC skew, alphabet. GC content: $ seqkit fx2tab --name --only-id --gc viral*.fna.gz gi|526245010|ref|NC_021865.1| 40.94 gi|460042095|ref|NC_020479.1| 41.82 gi|526244636|ref|NC_021857.1| 49.17 Custom bases (A, C and A+C): $ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz #name seq qual a c ac gi|526245010|ref|NC_021865.1| 33.20 18.24 51.44 gi|460042095|ref|NC_020479.1| 32.57 19.63 52.20 gi|526244636|ref|NC_021857.1| 25.52 23.06 48.59 How to extract sequences subset from FASTA/Q file with name/ID list file? This is a frequently used manipulation. Let's create a sample ID list file, which may also come from other way like mapping result. $ seqkit sample --proportion 0.001 duplicated-reads.fq.gz \\ | seqkit seq --name --only-id > id.txt ID list file: $ head id.txt SRR1972739.2996 SRR1972739.3044 SRR1972739.3562 Searching by ID list file: $ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz \\ > duplicated-reads.subset.fq.gz How to find FASTA/Q sequences containing degenerate bases and locate them? seqkit fx2tab converts FASTA/Q to tabular format and can output the sequence alphabet in a new column. And then text searching tools can be used to filter the table. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" gi|446730228|ref|NC_019782.1| ACGNT gi|557940284|ref|NC_022800.1| ACGKT gi|564292828|ref|NC_023009.1| ACGNT Long-option version of the command: $ seqkit fx2tab --name --only-id --alphabet viral.1.1.genomic.fna.gz \\ | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\" You can then exclude these sequences with seqkit grep : # save the sequenece IDs. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1 > id2.txt # search and exclude. $ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz > clean.fa Or locate the degenerate bases, e.g, N and K $ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz \\ | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+ seqID patternName pattern strand start end matched gi|564292828|ref|NC_023009.1| N+ N+ + 87972 87972 N gi|564292828|ref|NC_023009.1| N+ N+ + 100983 100983 N gi|557307918|ref|NC_022755.1| K+ K+ + 1788 1788 K gi|557307918|ref|NC_022755.1| K+ K+ + 4044 4044 K gi|589287065|ref|NC_023585.1| K+ K+ + 28296 28296 K gi|590911929|ref|NC_023639.1| N+ N+ + 741654 741753 NNNNNNNNNNNNNNNNNNNNNNNNNNN How to remove duplicated FASTA/Q records with same sequences? $ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz > duplicated-reads.uniq.fq.gz If the FASTA/Q file is very large, please switch on flag -m/--md5 , which use MD5 instead of original seqs to reduce memory usage when comparing by sequences. You can also deduplicate according to sequence ID (default) or full name ( --by-name ). How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? Related posts: Question: Count and location of strings in fastq file reads , Question: Finding TATAWAA in sequence . Assuming a list of motifs (enzyme digest sites) in FASTA format to be located: $ cat enzymes.fa >EcoRI GAATTC >MmeI TCCRAC >SacI GAGCTC >XcmI CCANNNNNNNNNTGG Flag --degenerate is on because patterns contain degenerate bases. Command: $ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz Sample output (simplified and reformated by csvtk -t uniq -f 3 | csvtk -t pretty ) seqID patternName pattern strand start end matched gi|526245010|ref|NC_021865.1| MmeI TCCRAC + 1816 1821 TCCGAC gi|526245010|ref|NC_021865.1| SacI GAGCTC + 19506 19511 GAGCTC gi|526245010|ref|NC_021865.1| XcmI CCANNNNNNNNNTGG + 2221 2235 CCATATTTAGTGTGG How to sort huge number of FASTA sequences by length? Sorting FASTA file in order of sequence size (small to large). $ seqkit sort --by-length viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa If the files are too big, use flag --two-pass which consumes lesser memory. $ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa You can also sort by sequence ID (default), full header ( --by-name ) or sequence content ( --by-seq ). How to split FASTA sequences according to information in header? Related posts: Question: extract same all similar sequences in FASTA based on the header . For example, FASTA header line of viral.1.protein.faa.gz contain species name in square brackets. Overview of FASTA Headers: $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name gi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23] gi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23] gi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23] seqkit split can split FASTA/Q files according to ID, number of parts, size of every parts, and sequence region. In this case, we'll split according to sequence ID (species names) which can be specified by flag --id-regexp . Default ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id gi|526245011|ref|YP_008320337.1| gi|526245012|ref|YP_008320338.1| gi|526245013|ref|YP_008320339.1| New ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\" Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Split: $ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz How to search and replace FASTA header with known character strings from a text file? Related posts: Question: Replace names in FASTA file with a known character string from a text file , Question: Fasta header, search and replace...? . seqKit replace can find substrings in FASTA/Q header with regular expression and replace them with strings or corresponding values of found substrings provided by the tab-delimited key-value file. For example, to unify names of protein with unknown functions, we want to rename \"hypothetical\" to \"putative\" in lower case. The replacing rules are listed below in tab-delimited file: $ cat changes.tsv Hypothetical putative hypothetical putative Putative putative Overview the FASTA headers containing \"hypothetical\": $ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz \\ | seqkit head -n 3 | seqkit seq --name gi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23] gi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23] gi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23] A regular expression, ^([^ ]+ )(\\w+) , was used to specify the key to be replaced, which is the first word after sequence ID in this case. Note that we also capture the ID ( ^([^ ]+ ) ) so we can restore it in \"replacement\" with capture variable ${1} (robuster than $1 ). And flag -I/--key-capt-idx (default: 1) is set to 2 because the key (\\w+) is the second captured match. Command: $ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" \\ --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz > renamed.fa How to extract paired reads from two paired-end reads file? Let's create two unbanlanced PE reads file: $ seqkit rmdup duplicated-reads.fq.gz \\ | seqkit replace --pattern \" .+\" --replacement \" 1\" \\ | seqkit sample --proportion 0.9 --rand-seed 1 --out-file read_1.fq.gz $ seqkit rmdup duplicated-reads.fq.gz \\ | seqkit replace --pattern \" .+\" --replacement \" 2\" \\ | seqkit sample --proportion 0.9 --rand-seed 2 --out-file read_2.fq.gz Overview: # number of records $ seqkit stat read_1.fq.gz read_2.fq.gz file format type num_seqs sum_len min_len avg_len max_len read_1.fq.gz FASTQ DNA 9,033 912,333 101 101 101 read_2.fq.gz FASTQ DNA 8,965 905,465 101 101 101 # sequence headers $ seqkit head -n 3 read_1.fq.gz | seqkit seq --name SRR1972739.1 1 SRR1972739.3 1 SRR1972739.4 1 $ seqkit head -n 3 read_2.fq.gz | seqkit seq --name SRR1972739.1 2 SRR1972739.2 2 SRR1972739.3 2 Firstly, extract sequence IDs of two file and compute the intersection: $ seqkit seq --name --only-id read_1.fq.gz read_2.fq.gz \\ | sort | uniq -d > id.txt $ # number of IDs wc -l id.txt 8090 id.txt Then extract reads using id.txt : $ seqkit grep --pattern-file id.txt read_1.fq.gz -o read_1.f.fq.gz $ seqkit grep --pattern-file id.txt read_2.fq.gz -o read_2.f.fq.gz Check if the IDs in two files are the same by md5sum : $ seqkit seq --name --only-id read_1.f.fq.gz > read_1.f.fq.gz.id.txt $ seqkit seq --name --only-id read_2.f.fq.gz > read_2.f.fq.gz.id.txt $ md5sum read_*.f.fq.gz.id.txt 537c57cfdc3923bb94a3dc31a0c3b02a read_1.f.fq.gz.id.txt 537c57cfdc3923bb94a3dc31a0c3b02a read_2.f.fq.gz.id.txt Note that this example assumes that the IDs in the two reads file have same order. If not you can sort them after previous steps. Shell sort can sort large file using disk, so temporary directory is set as current directory by option -T . . $ gzip -d -c read_1.f.fq.gz \\ | seqkit fx2tab \\ | sort -k1,1 -T . \\ | seqkit tab2fx \\ | gzip -c > read_1.f.sorted.fq.gz $ gzip -d -c read_2.f.fq.gz \\ | seqkit fx2tab \\ | sort -k1,1 -T . \\ | seqkit tab2fx \\ | gzip -c > read_2.f.sorted.fq.gz How to concatenate two FASTA sequences in to one? Related posts: Combining two fasta sequences into one Data (not in same order): $ cat 1.fa >seq1 aaaaa >seq2 ccccc >seq3 ggggg $ cat 2.fa >seq3 TTTTT >seq2 GGGGG >seq1 CCCCC Just one command: $ seqkit concat 1.fa 2.fa >seq1 aaaaaCCCCC >seq2 cccccGGGGG >seq3 gggggTTTTT","title":"FAQ"},{"location":"faq/#faq-on-fastaq-manipulations","text":"This page was originally written as the section FASTA/Q manipulations of The Biostar Handbook: A Beginner's Guide to Bioinformatics ( discussion on Biostars.org ) . This page illustrates common FASTA/Q manipulations using SeqKit . Some other utilities, including csvtk (CSV/TSV toolkit) and shell commands were also used. Note: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or in stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common usage but you can always use it on the other type as well. Example data How to produce an overview of FASTQ files? How to get GC content of every sequence in FASTA/Q file? How to extract sequences subset from FASTA/Q file with name/ID list file? How to find FASTA/Q sequences containing degenerate bases and locate them? How to remove duplicated FASTA/Q records with same sequences? How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? How to sort huge number of FASTA sequences by length? How to split FASTA sequences according to information in header? How to search and replace FASTA header with known character strings from a text file? How to extract paired reads from two paired-end reads file? How to concatenate two FASTA sequences in to one?","title":"FAQ on FASTA/Q manipulations"},{"location":"faq/#example-data","text":"One FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein sequences from NCBI RefSeq database, 60+40M) are used. wget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz","title":"Example data"},{"location":"faq/#how-to-produce-an-overview-of-fastq-files","text":"Sequence format and type are automatically detected. $ seqkit stat *.gz file format type num_seqs sum_len min_len avg_len max_len duplicated-reads.fq.gz FASTQ DNA 15,000 1,515,000 101 101 101 viral.1.1.genomic.fna.gz FASTA DNA 7,048 203,325,120 200 28,848.6 2,473,870 viral.1.protein.faa.gz FASTA Protein 252,611 62,024,702 5 245.5 8,960","title":"How to produce an overview of FASTQ files?"},{"location":"faq/#how-to-get-gc-content-of-every-sequence-in-fastaq-file","text":"seqkit fx2tab converts FASTA/Q to 3-column tabular format (1th: name/ID, 2nd: sequence, 3rd: quality), and can also provides various information in new columns, including sequence length, GC content/GC skew, alphabet. GC content: $ seqkit fx2tab --name --only-id --gc viral*.fna.gz gi|526245010|ref|NC_021865.1| 40.94 gi|460042095|ref|NC_020479.1| 41.82 gi|526244636|ref|NC_021857.1| 49.17 Custom bases (A, C and A+C): $ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz #name seq qual a c ac gi|526245010|ref|NC_021865.1| 33.20 18.24 51.44 gi|460042095|ref|NC_020479.1| 32.57 19.63 52.20 gi|526244636|ref|NC_021857.1| 25.52 23.06 48.59","title":"How to get GC content of every sequence in FASTA/Q file?"},{"location":"faq/#how-to-extract-sequences-subset-from-fastaq-file-with-nameid-list-file","text":"This is a frequently used manipulation. Let's create a sample ID list file, which may also come from other way like mapping result. $ seqkit sample --proportion 0.001 duplicated-reads.fq.gz \\ | seqkit seq --name --only-id > id.txt ID list file: $ head id.txt SRR1972739.2996 SRR1972739.3044 SRR1972739.3562 Searching by ID list file: $ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz \\ > duplicated-reads.subset.fq.gz","title":"How to extract sequences subset from FASTA/Q file with name/ID list file?"},{"location":"faq/#how-to-find-fastaq-sequences-containing-degenerate-bases-and-locate-them","text":"seqkit fx2tab converts FASTA/Q to tabular format and can output the sequence alphabet in a new column. And then text searching tools can be used to filter the table. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" gi|446730228|ref|NC_019782.1| ACGNT gi|557940284|ref|NC_022800.1| ACGKT gi|564292828|ref|NC_023009.1| ACGNT Long-option version of the command: $ seqkit fx2tab --name --only-id --alphabet viral.1.1.genomic.fna.gz \\ | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\" You can then exclude these sequences with seqkit grep : # save the sequenece IDs. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1 > id2.txt # search and exclude. $ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz > clean.fa Or locate the degenerate bases, e.g, N and K $ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz \\ | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+ seqID patternName pattern strand start end matched gi|564292828|ref|NC_023009.1| N+ N+ + 87972 87972 N gi|564292828|ref|NC_023009.1| N+ N+ + 100983 100983 N gi|557307918|ref|NC_022755.1| K+ K+ + 1788 1788 K gi|557307918|ref|NC_022755.1| K+ K+ + 4044 4044 K gi|589287065|ref|NC_023585.1| K+ K+ + 28296 28296 K gi|590911929|ref|NC_023639.1| N+ N+ + 741654 741753 NNNNNNNNNNNNNNNNNNNNNNNNNNN","title":"How to find FASTA/Q sequences containing degenerate bases and locate them?"},{"location":"faq/#how-to-remove-duplicated-fastaq-records-with-same-sequences","text":"$ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz > duplicated-reads.uniq.fq.gz If the FASTA/Q file is very large, please switch on flag -m/--md5 , which use MD5 instead of original seqs to reduce memory usage when comparing by sequences. You can also deduplicate according to sequence ID (default) or full name ( --by-name ).","title":"How to remove duplicated FASTA/Q records with same sequences?"},{"location":"faq/#how-to-locate-motifsubsequenceenzyme-digest-site-in-fastaq-sequence","text":"Related posts: Question: Count and location of strings in fastq file reads , Question: Finding TATAWAA in sequence . Assuming a list of motifs (enzyme digest sites) in FASTA format to be located: $ cat enzymes.fa >EcoRI GAATTC >MmeI TCCRAC >SacI GAGCTC >XcmI CCANNNNNNNNNTGG Flag --degenerate is on because patterns contain degenerate bases. Command: $ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz Sample output (simplified and reformated by csvtk -t uniq -f 3 | csvtk -t pretty ) seqID patternName pattern strand start end matched gi|526245010|ref|NC_021865.1| MmeI TCCRAC + 1816 1821 TCCGAC gi|526245010|ref|NC_021865.1| SacI GAGCTC + 19506 19511 GAGCTC gi|526245010|ref|NC_021865.1| XcmI CCANNNNNNNNNTGG + 2221 2235 CCATATTTAGTGTGG","title":"How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?"},{"location":"faq/#how-to-sort-huge-number-of-fasta-sequences-by-length","text":"Sorting FASTA file in order of sequence size (small to large). $ seqkit sort --by-length viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa If the files are too big, use flag --two-pass which consumes lesser memory. $ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa You can also sort by sequence ID (default), full header ( --by-name ) or sequence content ( --by-seq ).","title":"How to sort huge number of FASTA sequences by length?"},{"location":"faq/#how-to-split-fasta-sequences-according-to-information-in-header","text":"Related posts: Question: extract same all similar sequences in FASTA based on the header . For example, FASTA header line of viral.1.protein.faa.gz contain species name in square brackets. Overview of FASTA Headers: $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name gi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23] gi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23] gi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23] seqkit split can split FASTA/Q files according to ID, number of parts, size of every parts, and sequence region. In this case, we'll split according to sequence ID (species names) which can be specified by flag --id-regexp . Default ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id gi|526245011|ref|YP_008320337.1| gi|526245012|ref|YP_008320338.1| gi|526245013|ref|YP_008320339.1| New ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\" Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Split: $ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz","title":"How to split FASTA sequences according to information in header?"},{"location":"faq/#how-to-search-and-replace-fasta-header-with-known-character-strings-from-a-text-file","text":"Related posts: Question: Replace names in FASTA file with a known character string from a text file , Question: Fasta header, search and replace...? . seqKit replace can find substrings in FASTA/Q header with regular expression and replace them with strings or corresponding values of found substrings provided by the tab-delimited key-value file. For example, to unify names of protein with unknown functions, we want to rename \"hypothetical\" to \"putative\" in lower case. The replacing rules are listed below in tab-delimited file: $ cat changes.tsv Hypothetical putative hypothetical putative Putative putative Overview the FASTA headers containing \"hypothetical\": $ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz \\ | seqkit head -n 3 | seqkit seq --name gi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23] gi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23] gi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23] A regular expression, ^([^ ]+ )(\\w+) , was used to specify the key to be replaced, which is the first word after sequence ID in this case. Note that we also capture the ID ( ^([^ ]+ ) ) so we can restore it in \"replacement\" with capture variable ${1} (robuster than $1 ). And flag -I/--key-capt-idx (default: 1) is set to 2 because the key (\\w+) is the second captured match. Command: $ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" \\ --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz > renamed.fa","title":"How to search and replace FASTA header with known character strings from a text file?"},{"location":"faq/#how-to-extract-paired-reads-from-two-paired-end-reads-file","text":"Let's create two unbanlanced PE reads file: $ seqkit rmdup duplicated-reads.fq.gz \\ | seqkit replace --pattern \" .+\" --replacement \" 1\" \\ | seqkit sample --proportion 0.9 --rand-seed 1 --out-file read_1.fq.gz $ seqkit rmdup duplicated-reads.fq.gz \\ | seqkit replace --pattern \" .+\" --replacement \" 2\" \\ | seqkit sample --proportion 0.9 --rand-seed 2 --out-file read_2.fq.gz Overview: # number of records $ seqkit stat read_1.fq.gz read_2.fq.gz file format type num_seqs sum_len min_len avg_len max_len read_1.fq.gz FASTQ DNA 9,033 912,333 101 101 101 read_2.fq.gz FASTQ DNA 8,965 905,465 101 101 101 # sequence headers $ seqkit head -n 3 read_1.fq.gz | seqkit seq --name SRR1972739.1 1 SRR1972739.3 1 SRR1972739.4 1 $ seqkit head -n 3 read_2.fq.gz | seqkit seq --name SRR1972739.1 2 SRR1972739.2 2 SRR1972739.3 2 Firstly, extract sequence IDs of two file and compute the intersection: $ seqkit seq --name --only-id read_1.fq.gz read_2.fq.gz \\ | sort | uniq -d > id.txt $ # number of IDs wc -l id.txt 8090 id.txt Then extract reads using id.txt : $ seqkit grep --pattern-file id.txt read_1.fq.gz -o read_1.f.fq.gz $ seqkit grep --pattern-file id.txt read_2.fq.gz -o read_2.f.fq.gz Check if the IDs in two files are the same by md5sum : $ seqkit seq --name --only-id read_1.f.fq.gz > read_1.f.fq.gz.id.txt $ seqkit seq --name --only-id read_2.f.fq.gz > read_2.f.fq.gz.id.txt $ md5sum read_*.f.fq.gz.id.txt 537c57cfdc3923bb94a3dc31a0c3b02a read_1.f.fq.gz.id.txt 537c57cfdc3923bb94a3dc31a0c3b02a read_2.f.fq.gz.id.txt Note that this example assumes that the IDs in the two reads file have same order. If not you can sort them after previous steps. Shell sort can sort large file using disk, so temporary directory is set as current directory by option -T . . $ gzip -d -c read_1.f.fq.gz \\ | seqkit fx2tab \\ | sort -k1,1 -T . \\ | seqkit tab2fx \\ | gzip -c > read_1.f.sorted.fq.gz $ gzip -d -c read_2.f.fq.gz \\ | seqkit fx2tab \\ | sort -k1,1 -T . \\ | seqkit tab2fx \\ | gzip -c > read_2.f.sorted.fq.gz","title":"How to extract paired reads from two paired-end reads file?"},{"location":"faq/#how-to-concatenate-two-fasta-sequences-in-to-one","text":"Related posts: Combining two fasta sequences into one Data (not in same order): $ cat 1.fa >seq1 aaaaa >seq2 ccccc >seq3 ggggg $ cat 2.fa >seq3 TTTTT >seq2 GGGGG >seq1 CCCCC Just one command: $ seqkit concat 1.fa 2.fa >seq1 aaaaaCCCCC >seq2 cccccGGGGG >seq3 gggggTTTTT","title":"How to concatenate two FASTA sequences in to one?"},{"location":"note/","text":"Notes Sequence Parsing Strategies In general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences. During the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made ( Seqkit v0.2.7 ). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter. Figure 1 Illustration of FASTA/Q file parsing strategies . (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences. Effect of random seed on results of seqkit sample seqkit sample supports FASTA/Q sampling by proportion or amount. For sampling by proportion ( P ), SeqKit returns a record if a random number ( [0, 1 ]) is less than P . For sampling by amount ( N ), Seqkit firstly gets the total amount of records, and compute the proportion ( P ), and sampling by proportion ( P ). Cause the generated random number is pseudorandom and affected by the random seed ( -s/--rand-seed ), the number of sampled records may not be equal to N . Here we evaluate the effect of random seed on seqkit sample results. Used softwares csvtk: https://github.com/shenwei356/csvtk rush: https://github.com/shenwei356/rush Amount distribution of sampled records 1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 1000 , and the distribution of number of sampled records was plotted in boxplot. seq 1000 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | wc -l' \\ > ns.txt cat ns.txt | csvtk -H -t plot box -f 1 --horiz --height 2 \\ --xlab \"# of sampled records\" \\ > ns.png Location distribution of sampled records 1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 10 . The record IDs ( x axis ) was used to plot a scatter plot, which show the location distribution of sampled records. The ideal distribution would produces a straight line in the plot. seq 10 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | csvtk -H -t mutate \\ | csvtk -H -t replace -f 2 -p '.+' -r '{nr}' \\ | csvtk -H -t replace -f 4 -p '.+' -r {}' \\ | csvtk -H -t plot line -x 1 -y 2 -g 4 \\ --xlab \"sampled locations\" --ylab \"new ID of sampled records\" \\ --title \"location distribution of sampled records\" \\ --width 8 --height 6 --point-size 2 \\ > pos.png /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Notes"},{"location":"note/#notes","text":"","title":"Notes"},{"location":"note/#sequence-parsing-strategies","text":"In general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences. During the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made ( Seqkit v0.2.7 ). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter. Figure 1 Illustration of FASTA/Q file parsing strategies . (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences.","title":"Sequence Parsing Strategies"},{"location":"note/#effect-of-random-seed-on-results-of-seqkit-sample","text":"seqkit sample supports FASTA/Q sampling by proportion or amount. For sampling by proportion ( P ), SeqKit returns a record if a random number ( [0, 1 ]) is less than P . For sampling by amount ( N ), Seqkit firstly gets the total amount of records, and compute the proportion ( P ), and sampling by proportion ( P ). Cause the generated random number is pseudorandom and affected by the random seed ( -s/--rand-seed ), the number of sampled records may not be equal to N . Here we evaluate the effect of random seed on seqkit sample results. Used softwares csvtk: https://github.com/shenwei356/csvtk rush: https://github.com/shenwei356/rush","title":"Effect of random seed on results of seqkit sample"},{"location":"note/#amount-distribution-of-sampled-records","text":"1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 1000 , and the distribution of number of sampled records was plotted in boxplot. seq 1000 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | wc -l' \\ > ns.txt cat ns.txt | csvtk -H -t plot box -f 1 --horiz --height 2 \\ --xlab \"# of sampled records\" \\ > ns.png","title":"Amount distribution of sampled records"},{"location":"note/#location-distribution-of-sampled-records","text":"1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 10 . The record IDs ( x axis ) was used to plot a scatter plot, which show the location distribution of sampled records. The ideal distribution would produces a straight line in the plot. seq 10 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | csvtk -H -t mutate \\ | csvtk -H -t replace -f 2 -p '.+' -r '{nr}' \\ | csvtk -H -t replace -f 4 -p '.+' -r {}' \\ | csvtk -H -t plot line -x 1 -y 2 -g 4 \\ --xlab \"sampled locations\" --ylab \"new ID of sampled records\" \\ --title \"location distribution of sampled records\" \\ --width 8 --height 6 --point-size 2 \\ > pos.png /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Location distribution of sampled records"},{"location":"tutorial/","text":"Tutorial Some manipulations on big genomes A script memusg is used to check the peek memory usage of seqkit. Usage: memusg [-t] command . Human genome $ seqkit stat hsa.fa file format type num_seqs sum_len min_len avg_len max_len hsa.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 Build FASTA index ( optional , when using flag -2 ( --two-pass ), some commands will automaticlly build it). For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files or stdin, FASTA index would be optional used for rapid acccess of sequences and reducing memory occupation. ATTENTION : the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools. SeqKit uses full sequence head instead of just ID as key. $ memusg -t seqkit faidx --id-regexp \"^(.+)$\" hsa.fa -o hsa.fa.seqkit.fai elapsed time: 10.011s peak rss: 177.21 MB Create common .fai file: $ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2 elapsed time: 10.454s peak rss: 172.82 MB Performance of samtools: $ memusg -t samtools faidx hsa.fa elapsed time: 9.574s peak rss: 1.45 MB Exactly same content: $ md5sum hsa.fa.fai* 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai2 Sorting by sequence length $ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa > hsa.sorted.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs and lengths from FASTA index ... [INFO] 194 sequences loaded [INFO] sorting ... [INFO] output ... elapsed time: 4.892s peak rss: 500.15 MB Detail: $ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more 1 248956422 2 242193529 3 198295559 4 190214555 5 181538259 6 170805979 7 159345973 X 156040895 8 145138636 9 138394717 11 135086622 10 133797422 12 133275309 13 114364328 14 107043718 15 101991189 16 90338345 17 83257441 18 80373285 20 64444167 19 58617616 Y 57227415 22 50818468 21 46709983 KI270728.1 1872759 KI270727.1 448248 ... real 0m10.697s user 0m11.153s sys 0m0.917s Shuffling sequences $ memusg -t seqkit shuffle hsa.fa --two-pass > hsa.shuffled.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... elapsed time: 6.632s peak rss: 528.3 MB Spliting into files with single sequence $ memusg -t seqkit split --by-id hsa.fa --two-pass [INFO] split by ID. idRegexp: ^([^\\s]+)\\s? [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] write 1 sequences to file: hsa.id_KI270743.1.fa [INFO] write 1 sequences to file: hsa.id_KI270706.1.fa [INFO] write 1 sequences to file: hsa.id_KI270717.1.fa [INFO] write 1 sequences to file: hsa.id_KI270718.1.fa [INFO] write 1 sequences to file: hsa.id_KI270468.1.fa ... elapsed time: 18.807s peak rss: 1.36 GB Geting subsequence of some chromesomes $ memusg -t seqkit subseq -r 1:10 --chr X --chr Y hsa.fa >X_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF nnnnnnnnnn >Y_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF NNNNNNNNNN elapsed time: 1.276s peak rss: 640.92 MB Geting CDS sequence of chr 1 by GTF files $ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds hsa.fa > chrX.gtf.cds.fa [INFO] read GTF file ... [INFO] 22420 GTF features loaded elapsed time: 8.643s peak rss: 846.14 MB Remove contaminated reads Mapping with reads on some potential contaminate genomes, and get the reads IDs list. $ wc -l contaminate.list 244 contaminate.list $ head -n 2 contaminate.list HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 HWI-D00523:240:HF3WGBCXX:1:1101:12616:2205 Remove contaminated reads $ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz $ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz $ seqkit stat *.fq.gz file seq_format seq_type num_seqs min_len avg_len max_len reads_1.clean.fq.gz FASTQ DNA 2,256 226 227 229 reads_1.fq.gz FASTQ DNA 2,500 226 227 229 reads_2.clean.fq.gz FASTQ DNA 2,256 223 224 225 reads_2.fq.gz FASTQ DNA 2,500 223 224 225 Handling of aligned sequences Some mock sequences (usually they will be much longer) $ cat seqs.fa >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Run multiple sequence alignment (clustalo) clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4 Convert FASTA format to tabular format. $ seqkit fx2tab seqs.msa.fa seq1 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG seq2 ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG or $ seqkit fx2tab seqs.msa.fa | cut -f 2 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG For me, it's useful when 1) manually assembling Sanger sequencing result, 2) designing site specific PCR primers. Remove gaps $ seqkit seq seqs.msa.fa -g >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Play with miRNA hairpins Dataset hairpin.fa.gz from The miRBase Sequence Database -- Release 21 Quick glance Sequence number $ seqkit stat hairpin.fa.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 First 10 bases $ zcat hairpin.fa.gz \\ | seqkit subseq -r 1:10 \\ | seqkit sort -s | seqkit seq -s \\ | head -n 10 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAG AAAAAAAAAG AAAAAAAAAG AAAAAAAAAU AAAAAAAAGG AAAAAAACAU AAAAAAACGA AAAAAAAUUA hmm, nothing special, non-coding RNA~ Repeated hairpin sequences We may want to check how may identical hairpins among different species there are. seqkit rmdup could remove duplicated sequences by sequence content, and save the replicates to another file (here is duplicated.fa.gz ), as well as replicating details ( duplicated.detail.txt , 1th column is the repeated number, 2nd column contains sequence IDs seperated by comma). $ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ head -n 5 duplicated.detail.txt 18 dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18 16 hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3 15 dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125 13 hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b 13 hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a The result shows the most conserved miRNAs among different species, mir-29b , mir-125 , mir-19b-1 and mir-20a . And the dre-miR-430c has the most multicopies in Danio rerio . Hairpins in different species Before spliting by species, let's take a look at the sequence names. $ seqkit seq hairpin.fa.gz -n | head -n 3 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop The first three letters (e.g. cel ) are the abbreviation of species names. So we could split hairpins by the first letters by defining custom sequence ID parsing regular expression ^([\\w]+)\\- . By default, seqkit takes the first non-space letters as sequence ID. For example, FASTA head ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . Split sequences by species. A custom ID parsing regular expression is used, ^([\\w]+)\\- . $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass To reduce memory usage when splitting big file, we should always use flag --two-pass Species with most miRNA hairpins. Third column is the sequences number. $ cd hairpin.fa.gz.split/; $ seqkit stat hairpin.id_* \\ | csvtk space2tab \\ | csvtk -t sort -k num_seqs:nr \\ | csvtk -t pretty \\ | more file format type num_seqs sum_len min_len avg_len max_len hairpin.id_hsa.fasta FASTA RNA 1,881 154,242 82 82 82 hairpin.id_mmu.fasta FASTA RNA 1,193 107,370 90 90 90 hairpin.id_bta.fasta FASTA RNA 808 61,408 76 76 76 hairpin.id_gga.fasta FASTA RNA 740 42,180 57 57 57 hairpin.id_eca.fasta FASTA RNA 715 89,375 125 125 125 hairpin.id_mtr.fasta FASTA RNA 672 231,840 345 345 345 Here, a CSV/TSV tool csvtk is used to sort and view the result. For human miRNA hairpins Length distribution. seqkit fx2tab could show extra information like sequence length, GC content. csvtk is used to plot. $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\" $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot box --xlab Length --horiz --height 1.5 Bacteria genome Dataset Pseudomonas aeruginosa PAO1 , files: Genbank file PAO1.gb Genome FASTA file PAO1.fasta GTF file PAO1.gtf was created with extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py PAO1.gb -t . -f gtf > PAO1.gtf Motif distribution Motifs $ cat motifs.fa >GTAGCGS GTAGCGS >GGWGKTCG GGWGKTCG Sliding. Remember flag --id-ncbi , do you? By the way, do not be scared by the long flag --circle-genome , --step and so on. They have short ones, -c , -s $ seqkit sliding --id-ncbi --circular-genome \\ --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa $ seqkit stat PAO1.fasta.sliding.fa file format type num_seqs sum_len min_len avg_len max_len PAO1.fasta.sliding.fa FASTA DNA 314 62,800,000 200,000 200,000 200,000 Locating motifs $ seqkit locate --id-ncbi --ignore-case --degenerate \\ --pattern-file motifs.fa PAO1.fasta.sliding.fa -o PAO1.fasta.sliding.fa.motifs.tsv Ploting distribution ( plot_motif_distribution.R ) # preproccess $ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv > PAO1.fasta.sliding.fa.motifs.tsv2 # plot $ ./plot_motif_distribution.R Result Find multicopy genes Get all CDS sequences $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta $ seqkit stat *.fasta file format type num_seqs sum_len min_len avg_len max_len PAO1.cds.fasta FASTA DNA 5,572 5,593,306 72 1,003.8 16,884 PAO1.fasta FASTA DNA 1 6,264,404 6,264,404 6,264,404 6,264,404 Get duplicated sequences $ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta \\ --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text $ cat PAO1.cds.dup.text 6 NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:- 2 NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+ 2 NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+ 2 NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+ Flanking sequences Get CDS and 1000 bp upstream sequence $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 Get 1000 bp upstream sequence of CDS, NOT including CDS. $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 --only-flank /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#some-manipulations-on-big-genomes","text":"A script memusg is used to check the peek memory usage of seqkit. Usage: memusg [-t] command . Human genome $ seqkit stat hsa.fa file format type num_seqs sum_len min_len avg_len max_len hsa.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 Build FASTA index ( optional , when using flag -2 ( --two-pass ), some commands will automaticlly build it). For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files or stdin, FASTA index would be optional used for rapid acccess of sequences and reducing memory occupation. ATTENTION : the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools. SeqKit uses full sequence head instead of just ID as key. $ memusg -t seqkit faidx --id-regexp \"^(.+)$\" hsa.fa -o hsa.fa.seqkit.fai elapsed time: 10.011s peak rss: 177.21 MB Create common .fai file: $ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2 elapsed time: 10.454s peak rss: 172.82 MB Performance of samtools: $ memusg -t samtools faidx hsa.fa elapsed time: 9.574s peak rss: 1.45 MB Exactly same content: $ md5sum hsa.fa.fai* 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai2 Sorting by sequence length $ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa > hsa.sorted.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs and lengths from FASTA index ... [INFO] 194 sequences loaded [INFO] sorting ... [INFO] output ... elapsed time: 4.892s peak rss: 500.15 MB Detail: $ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more 1 248956422 2 242193529 3 198295559 4 190214555 5 181538259 6 170805979 7 159345973 X 156040895 8 145138636 9 138394717 11 135086622 10 133797422 12 133275309 13 114364328 14 107043718 15 101991189 16 90338345 17 83257441 18 80373285 20 64444167 19 58617616 Y 57227415 22 50818468 21 46709983 KI270728.1 1872759 KI270727.1 448248 ... real 0m10.697s user 0m11.153s sys 0m0.917s Shuffling sequences $ memusg -t seqkit shuffle hsa.fa --two-pass > hsa.shuffled.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... elapsed time: 6.632s peak rss: 528.3 MB Spliting into files with single sequence $ memusg -t seqkit split --by-id hsa.fa --two-pass [INFO] split by ID. idRegexp: ^([^\\s]+)\\s? [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] write 1 sequences to file: hsa.id_KI270743.1.fa [INFO] write 1 sequences to file: hsa.id_KI270706.1.fa [INFO] write 1 sequences to file: hsa.id_KI270717.1.fa [INFO] write 1 sequences to file: hsa.id_KI270718.1.fa [INFO] write 1 sequences to file: hsa.id_KI270468.1.fa ... elapsed time: 18.807s peak rss: 1.36 GB Geting subsequence of some chromesomes $ memusg -t seqkit subseq -r 1:10 --chr X --chr Y hsa.fa >X_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF nnnnnnnnnn >Y_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF NNNNNNNNNN elapsed time: 1.276s peak rss: 640.92 MB Geting CDS sequence of chr 1 by GTF files $ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds hsa.fa > chrX.gtf.cds.fa [INFO] read GTF file ... [INFO] 22420 GTF features loaded elapsed time: 8.643s peak rss: 846.14 MB","title":"Some manipulations on big genomes"},{"location":"tutorial/#remove-contaminated-reads","text":"Mapping with reads on some potential contaminate genomes, and get the reads IDs list. $ wc -l contaminate.list 244 contaminate.list $ head -n 2 contaminate.list HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 HWI-D00523:240:HF3WGBCXX:1:1101:12616:2205 Remove contaminated reads $ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz $ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz $ seqkit stat *.fq.gz file seq_format seq_type num_seqs min_len avg_len max_len reads_1.clean.fq.gz FASTQ DNA 2,256 226 227 229 reads_1.fq.gz FASTQ DNA 2,500 226 227 229 reads_2.clean.fq.gz FASTQ DNA 2,256 223 224 225 reads_2.fq.gz FASTQ DNA 2,500 223 224 225","title":"Remove contaminated reads"},{"location":"tutorial/#handling-of-aligned-sequences","text":"Some mock sequences (usually they will be much longer) $ cat seqs.fa >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Run multiple sequence alignment (clustalo) clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4 Convert FASTA format to tabular format. $ seqkit fx2tab seqs.msa.fa seq1 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG seq2 ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG or $ seqkit fx2tab seqs.msa.fa | cut -f 2 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG For me, it's useful when 1) manually assembling Sanger sequencing result, 2) designing site specific PCR primers. Remove gaps $ seqkit seq seqs.msa.fa -g >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG","title":"Handling of aligned sequences"},{"location":"tutorial/#play-with-mirna-hairpins","text":"","title":"Play with miRNA hairpins"},{"location":"tutorial/#dataset","text":"hairpin.fa.gz from The miRBase Sequence Database -- Release 21","title":"Dataset"},{"location":"tutorial/#quick-glance","text":"Sequence number $ seqkit stat hairpin.fa.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 First 10 bases $ zcat hairpin.fa.gz \\ | seqkit subseq -r 1:10 \\ | seqkit sort -s | seqkit seq -s \\ | head -n 10 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAG AAAAAAAAAG AAAAAAAAAG AAAAAAAAAU AAAAAAAAGG AAAAAAACAU AAAAAAACGA AAAAAAAUUA hmm, nothing special, non-coding RNA~","title":"Quick glance"},{"location":"tutorial/#repeated-hairpin-sequences","text":"We may want to check how may identical hairpins among different species there are. seqkit rmdup could remove duplicated sequences by sequence content, and save the replicates to another file (here is duplicated.fa.gz ), as well as replicating details ( duplicated.detail.txt , 1th column is the repeated number, 2nd column contains sequence IDs seperated by comma). $ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ head -n 5 duplicated.detail.txt 18 dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18 16 hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3 15 dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125 13 hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b 13 hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a The result shows the most conserved miRNAs among different species, mir-29b , mir-125 , mir-19b-1 and mir-20a . And the dre-miR-430c has the most multicopies in Danio rerio .","title":"Repeated hairpin sequences"},{"location":"tutorial/#hairpins-in-different-species","text":"Before spliting by species, let's take a look at the sequence names. $ seqkit seq hairpin.fa.gz -n | head -n 3 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop The first three letters (e.g. cel ) are the abbreviation of species names. So we could split hairpins by the first letters by defining custom sequence ID parsing regular expression ^([\\w]+)\\- . By default, seqkit takes the first non-space letters as sequence ID. For example, FASTA head ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . Split sequences by species. A custom ID parsing regular expression is used, ^([\\w]+)\\- . $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass To reduce memory usage when splitting big file, we should always use flag --two-pass Species with most miRNA hairpins. Third column is the sequences number. $ cd hairpin.fa.gz.split/; $ seqkit stat hairpin.id_* \\ | csvtk space2tab \\ | csvtk -t sort -k num_seqs:nr \\ | csvtk -t pretty \\ | more file format type num_seqs sum_len min_len avg_len max_len hairpin.id_hsa.fasta FASTA RNA 1,881 154,242 82 82 82 hairpin.id_mmu.fasta FASTA RNA 1,193 107,370 90 90 90 hairpin.id_bta.fasta FASTA RNA 808 61,408 76 76 76 hairpin.id_gga.fasta FASTA RNA 740 42,180 57 57 57 hairpin.id_eca.fasta FASTA RNA 715 89,375 125 125 125 hairpin.id_mtr.fasta FASTA RNA 672 231,840 345 345 345 Here, a CSV/TSV tool csvtk is used to sort and view the result. For human miRNA hairpins Length distribution. seqkit fx2tab could show extra information like sequence length, GC content. csvtk is used to plot. $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\" $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot box --xlab Length --horiz --height 1.5","title":"Hairpins in different species"},{"location":"tutorial/#bacteria-genome","text":"","title":"Bacteria genome"},{"location":"tutorial/#dataset_1","text":"Pseudomonas aeruginosa PAO1 , files: Genbank file PAO1.gb Genome FASTA file PAO1.fasta GTF file PAO1.gtf was created with extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py PAO1.gb -t . -f gtf > PAO1.gtf","title":"Dataset"},{"location":"tutorial/#motif-distribution","text":"Motifs $ cat motifs.fa >GTAGCGS GTAGCGS >GGWGKTCG GGWGKTCG Sliding. Remember flag --id-ncbi , do you? By the way, do not be scared by the long flag --circle-genome , --step and so on. They have short ones, -c , -s $ seqkit sliding --id-ncbi --circular-genome \\ --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa $ seqkit stat PAO1.fasta.sliding.fa file format type num_seqs sum_len min_len avg_len max_len PAO1.fasta.sliding.fa FASTA DNA 314 62,800,000 200,000 200,000 200,000 Locating motifs $ seqkit locate --id-ncbi --ignore-case --degenerate \\ --pattern-file motifs.fa PAO1.fasta.sliding.fa -o PAO1.fasta.sliding.fa.motifs.tsv Ploting distribution ( plot_motif_distribution.R ) # preproccess $ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv > PAO1.fasta.sliding.fa.motifs.tsv2 # plot $ ./plot_motif_distribution.R Result","title":"Motif distribution"},{"location":"tutorial/#find-multicopy-genes","text":"Get all CDS sequences $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta $ seqkit stat *.fasta file format type num_seqs sum_len min_len avg_len max_len PAO1.cds.fasta FASTA DNA 5,572 5,593,306 72 1,003.8 16,884 PAO1.fasta FASTA DNA 1 6,264,404 6,264,404 6,264,404 6,264,404 Get duplicated sequences $ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta \\ --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text $ cat PAO1.cds.dup.text 6 NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:- 2 NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+ 2 NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+ 2 NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+","title":"Find multicopy genes"},{"location":"tutorial/#flanking-sequences","text":"Get CDS and 1000 bp upstream sequence $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 Get 1000 bp upstream sequence of CDS, NOT including CDS. $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 --only-flank /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Flanking sequences"},{"location":"usage/","text":"Usage and Examples Table of Contents Technical details and guides for use seqkit Sequence and subsequence seq subseq sliding stats faidx watch sana Format conversion fq2fa fx2tab & tab2fx convert translate Searching grep locate fish amplicon BAM processing and monitoring bam Set operations head range sample rmdup duplicate common split split2 Edit replace rename restart concat mutate Ordering shuffle sort Misc genautocomplete Technical details and guides for use FASTA/Q format parsing SeqKit uses author's lightweight and high-performance bioinformatics packages bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Seqkit calls pigz (much faster than gzip ) or gzip to decompress .gz file if they are available. So please install pigz to gain better parsing performance for gzipped data . Seqkit does not call pigz or gzip any more since v0.8.1, Because it does not always increase the speed. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . Seqkit uses package pgzip to write gzip file, which is very fast ( 10X of gzip , 4X of pigz ) and the gzip file would be slighty larger. Sequence formats and types SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked. Sequence ID By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . FASTA index For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key. Parallelization of CPU intensive jobs The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 1 for single-CPU PC, 2 for others). Memory occupation Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands need to store sequences or heads in memory, but there are strategy to reduce memory occupation, including rmdup and common . When comparing with sequences, MD5 digest could be used to replace sequence by flag -m ( --md5 ). Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation. Reproducibility Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed. seqkit SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Version: 0.12.1 Author: Wei Shen <shenwei356@gmail.com> Documents : http://bioinf.shenwei.me/seqkit Source code: https://github.com/shenwei356/seqkit Please cite: https://doi.org/10.1371/journal.pone.0163962 Usage: seqkit [command] Available Commands: amplicon retrieve amplicon (or specific region around it) via primer(s) bam monitoring and online histograms of BAM record features common find common sequences of multiple files by id/name/sequence concat concatenate sequences with same ID from multiple files convert convert FASTQ quality encoding between Sanger, Solexa and Illumina duplicate duplicate sequences N times faidx create FASTA index file and extract subsequence fish look for short sequences in larger sequences using local alignment fq2fa convert FASTQ to FASTA fx2tab convert FASTA/Q to tabular format (with length/GC content/GC skew) genautocomplete generate shell autocompletion script grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed head print first N FASTA/Q records help Help about any command locate locate subsequences/motifs, mismatch allowed mutate edit sequence (point mutation, insertion, deletion) range print FASTA/Q records in a range (start:end) rename rename duplicated IDs replace replace name/sequence by regular expression restart reset start position for circular genome rmdup remove duplicated sequences by id/name/sequence sample sample sequences by number or proportion sana sanitize broken single line fastq files seq transform sequences (revserse, complement, extract ID...) shuffle shuffle sequences sliding sliding sequences, circular genome supported sort sort sequences by id/name/sequence/length split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) stats simple statistics of FASTA/Q files subseq get subsequences by region/gtf/bed, including flanking sequences tab2fx convert tabular format to FASTA/Q format translate translate DNA/RNA to protein sequence (supporting ambiguous bases) version print version information and check for update watch monitoring and online histograms of sequence features Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) -h, --help help for seqkit --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") --infile-list string file of input files list (one file per line), if given, they are appended to files from cli arguments -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Datasets Datasets from The miRBase Sequence Database -- Release 21 hairpin.fa.gz mature.fa.gz miRNA.diff.gz Human genome from ensembl (For seqkit subseq ) Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz Homo_sapiens.GRCh38.84.gtf.gz Homo_sapiens.GRCh38.84.bed.gz is converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command zcat Homo_sapiens.GRCh38.84.gtf.gz \\ | gtf2bed --do-not-sort \\ | gzip -c > Homo_sapiens.GRCh38.84.bed.gz Only DNA and gtf/bed data of Chr1 were used: chr1.fa.gz seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz chr1.gtf.gz zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c > chr1.gtf.gz chr1.bed.gz zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c > chr1.bed.gz seq Usage transform sequences (revserse, complement, extract ID...) Usage: seqkit seq [flags] Flags: -p, --complement complement sequence, flag '-v' is recommended to switch on --dna2rna DNA to RNA -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for seq -l, --lower-case print sequences in lower case -M, --max-len int only print sequences shorter than the maximum length (-1 for no limit) (default -1) -R, --max-qual float only print sequences with average quality less than this limit (-1 for no limit) (default -1) -m, --min-len int only print sequences longer than the minimum length (-1 for no limit) (default -1) -Q, --min-qual float only print sequences with average quality qreater or equal than this limit (-1 for no limit) (default -1) -n, --name only print names -i, --only-id print ID instead of full head -q, --qual only print qualities -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -g, --remove-gaps remove gaps -r, --reverse reverse sequence --rna2dna RNA to DNA -s, --seq only print sequences -u, --upper-case print sequences in upper case -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Read and print From file: $ seqkit seq hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA $ seqkit seq read_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII From stdin: zcat hairpin.fa.gz | seqkit seq Sequence types By default, seqkit seq automatically detect the sequence type $ echo -e \">seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA DNA 1 28 28 28 28 $ echo -e \">seq\\nACGUN ACGUN\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1 11 11 11 11 $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA Protein 1 23 23 23 23 $ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTQ DNA 1 6 6 6 6 You can also set sequence type by flag -t ( --seq-type ). But this only take effect on subcommands seq and locate . $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna [INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on [ERRO] error when parsing seq: seq (invalid DNAredundant letter: e) Only print names Full name: $ seqkit seq hairpin.fa.gz -n cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop Only ID: $ seqkit seq hairpin.fa.gz -n -i cel-let-7 cel-lin-4 cel-mir-1 Custom ID region by regular expression (this could be applied to all subcommands): $ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\" MI0000001 MI0000002 MI0000003 Only print seq (global flag -w defines the output line width, 0 for no wrap) $ seqkit seq hairpin.fa.gz -s -w 0 UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU Convert multi-line FASTQ to 4-line FASTQ $ seqkit seq reads_1.fq.gz -w 0 Reverse comlement sequence $ seqkit seq hairpin.fa.gz -r -p >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA Remove gaps and to lower/upper case $ echo -e \">seq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u >seq ACGTACTGCACC RNA to DNA $ echo -e \">seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna >seq TCATATGCTTGTCTCAAAGATTA Filter by sequence length $ cat hairpin.fa | seqkit seq | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 28,645 2,949,871 39 103 2,354 $ cat hairpin.fa | seqkit seq -m 100 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,975 1,565,486 100 142.6 2,354 $ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,972 1,560,270 100 142.2 938 subseq Usage get subsequences by region/gtf/bed, including flanking sequences. Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit subseq [flags] Flags: --bed string by BED file --chr value select limited sequence with sequence IDs when using flag --gtf or --bed (multiple value supported, case ignored) (default []) -d, --down-stream int down stream length --feature value select limited feature types (multiple value supported, case ignored, only works with GTF) (default []) --gtf string by GTF (version 2.2) file --gtf-tag string output this tag as sequence comment (default \"gene_id\") -f, --only-flank only return up/down stream sequence -r, --region string by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \"seqkit subseq -h\" for more examples -u, --up-stream int up stream length Examples Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. First 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 1:12 Last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r -12:-1 Subsequences without first and last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 13:-13 Get subsequence by GTF file $ cat t.fa >seq actgACTGactgn $ cat t.gtf seq test CDS 5 8 . . . gene_id \"A\"; transcript_id \"\"; seq test CDS 5 8 . - . gene_id \"B\"; transcript_id \"\"; $ seqkit subseq --gtf t.gtf t.fa >seq_5:8:. A ACTG >seq_5:8:- B CAGT Human genome example: AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. We could specify chromesomes and features. $ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa > chr1.gtf.cds.fa $ seqkit stats chr1.gtf.cds.fa file format type num_seqs sum_len min_len avg_len max_len chr1.gtf.cds.fa FASTA DNA 65,012 9,842,274 1 151.4 12,045 Get CDS and 3bp up-stream sequences $ seqkit subseq --gtf t.gtf t.fa -u 3 >seq_5:8:._us:3 A ctgACTG >seq_5:8:-_us:3 B agtCAGT Get 3bp up-stream sequences of CDS, not including CDS $ seqkit subseq --gtf t.gtf t.fa -u 3 -f >seq_5:8:._usf:3 A ctg >seq_5:8:-_usf:3 B agt Get subsequences by BED file. AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ > chr1.bed.gz.fa We may need to remove duplicated sequences $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ | seqkit rmdup > chr1.bed.rmdup.fa [INFO] 141060 duplicated records removed Summary: $ seqkit stats chr1.gz.*.gz file seq_format seq_type num_seqs min_len avg_len max_len chr1.gz.fa FASTA DNA 231,974 1 3,089.5 1,551,957 chr1.gz.rmdup.fa FASTA DNA 90,914 1 6,455.8 1,551,957 sliding Usage sliding sequences, circular genome supported Usage: seqkit sliding [flags] Flags: -C, --circular-genome circular genome. -g, --greedy greedy mode, i.e., exporting last subsequences even shorter than windows size -s, --step int step size -W, --window int window size Examples General use $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN Greedy mode $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-12 gtNN >seq_sliding:10-15 N Circular genome $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-2 gtNNAC >seq_sliding:10-5 NACGTa Generate GC content for ploting $ zcat hairpin.fa.gz \\ | seqkit sliding -s 5 -W 30 \\ | seqkit fx2tab -n -g cel-let-7_sliding:1-30 50.00 cel-let-7_sliding:6-35 46.67 cel-let-7_sliding:11-40 43.33 cel-let-7_sliding:16-45 36.67 cel-let-7_sliding:21-50 33.33 cel-let-7_sliding:26-55 40.00 ... stats Usage simple statistics of FASTA/Q files Tips: 1. For lots of small files (especially on SDD), use big value of '-j' to parallelize counting. Usage: seqkit stats [flags] Aliases: stats, stat Flags: -a, --all all statistics, including quartiles of seq length, sum_gap, N50 -b, --basename only output basename of files -E, --fq-encoding string fastq quality encoding. available values: 'sanger', 'solexa', 'illumina-1.3+', 'illumina-1.5+', 'illumina-1.8+'. (default \"sanger\") -G, --gap-letters string gap letters (default \"- .\") -h, --help help for stats -e, --skip-err skip error, only show warning message -T, --tabular output in machine-friendly tabular format Eexamples General use $ seqkit stats *.f{a,q}.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Machine-friendly tabular format $ seqkit stats *.f{a,q}.gz -T file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # So you can process the result with tools like csvtk: http://bioinf.shenwei.me/csvtk $ seqkit stats *.f{a,q}.gz -T | csvtk pretty -t file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # To markdown $ seqkit stats *.f{a,q}.gz -T | csvtk csv2md -t file |format|type|num_seqs|sum_len|min_len|avg_len|max_len :----------------|:-----|:---|:-------|:------|:------|:------|:------ hairpin.fa.gz |FASTA |RNA |28645 |2949871|39 |103.0 |2354 mature.fa.gz |FASTA |RNA |35828 |781222 |15 |21.8 |34 Illimina1.8.fq.gz|FASTQ |DNA |10000 |1500000|150 |150.0 |150 reads_1.fq.gz |FASTQ |DNA |2500 |567516 |226 |227.0 |229 reads_2.fq.gz |FASTQ |DNA |2500 |560002 |223 |224.0 |225 file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 Extra information $ seqkit stats *.f{a,q}.gz -a file format type num_seqs sum_len min_len avg_len max_len Q1 Q2 Q3 sum_gap N50 Q20(%) Q30(%) hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 76 91 111 0 101 0 0 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 21 22 22 0 22 0 0 Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 150 150 150 0 150 96.16 89.71 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 227 227 227 0 227 91.24 86.62 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 224 224 224 0 224 91.06 87.66 Parallelize counting files, it's much faster for lots of small files, especially for files on SSD seqkit stats -j 10 refseq/virual/*.fna.gz Skip error $ seqkit stats tests/* [ERRO] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format $ seqkit stats tests/* -e [WARN] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format [WARN] tests/hairpin.fa.seqkit.fai: fastx: invalid FASTA/Q format [WARN] tests/miRNA.diff.gz: fastx: invalid FASTA/Q format [WARN] tests/test.sh: fastx: invalid FASTA/Q format file format type num_seqs sum_len min_len avg_len max_len tests/contigs.fa FASTA DNA 9 54 2 6 10 tests/hairpin.fa FASTA RNA 28,645 2,949,871 39 103 2,354 tests/Illimina1.5.fq FASTQ DNA 1 100 100 100 100 tests/Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 tests/hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 tests/reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 tests/mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 tests/reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Output basename instead of full path ( -b/--basename ) faidx Usage create FASTA index file and extract subsequence This command is similar with \"samtools faidx\" but has some extra features: 1. output full header line with flag -f 2. support regular expression as sequence ID with flag -r 3. if you have large number of IDs, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt Usage: seqkit faidx [flags] <fasta-file> [regions...] Flags: -f, --full-head print full header line instead of just ID. New fasta index file ending with .seqkit.fai will be created -h, --help help for faidx -i, --ignore-case ignore case -r, --use-regexp IDs are regular expression. But subseq region is not suppored here. Example common usage like samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 >hsa-let-7a-1 UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU output full header, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 -f >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU extract subsequence of specific region $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1-10 >hsa-let-7a-1:1-10 UGGGAUGAGG $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:-10--1 >hsa-let-7a-1:-10--1 GUCUUUCCUA $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1 >hsa-let-7a-1:1-1 U use regular expression $ seqkit faidx tests/hairpin.fa hsa -r | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,881 154,002 41 81.9 180 watch Usage monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Histogram of log sequence length seqkit watch -L -f ReadLen hairpin.fa Histogram of mean base qualities every 500 record, also saved as PDF seqkit watch -p 500 -O qhist.pdf -f MeanQual reads_1.fq.gz sana Usage sanitize broken single line fastq files Usage: seqkit sana [flags] Flags: -h, --help help for sana -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq.gz -o rescued.fq.gz fq2fa Usage convert FASTQ to FASTA Usage: seqkit fq2fa [flags] Examples seqkit fq2fa reads_1.fq.gz -o reads_1.fa.gz fx2tab & tab2fx Usage (fx2tab) convert FASTA/Q to tabular format, and provide various information, like sequence length, GC content/GC skew. Usage: seqkit fx2tab [flags] Flags: -a, --alphabet print alphabet letters -q, --avg-qual print average quality of a read -B, --base-content strings print base content. (case ignored, multiple values supported) e.g. -B AT -B N -I, --case-sensitive calculate case sensitive base content -g, --gc print GC content -G, --gc-skew print GC-Skew -H, --header-line print header line -h, --help help for fx2tab -l, --length print sequence length -n, --name only print names (no sequences and qualities) -i, --only-id print ID instead of full head -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Usage (tab2fx) convert tabular format (first two/three columns) to FASTA/Q format Usage: seqkit tab2fx [flags] Flags: -p, --comment-line-prefix value comment line prefix (default [#,//]) Examples Default output $ seqkit fx2tab hairpin.fa.gz | head -n 2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU Print sequence length, GC content, and only print names (no sequences), we could also print title line by flag -H . $ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '&' pretty #name seq qual length GC cel-let-7 99 43.43 cel-lin-4 94 54.26 cel-mir-1 96 40.62 Use fx2tab and tab2fx in pipe $ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx $ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx Sort sequences by length (use seqkit sort -l ) $ zcat hairpin.fa.gz \\ | seqkit fx2tab -l \\ | sort -t\"`echo -e '\\t'`\" -n -k4,4 \\ | seqkit tab2fx >cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop UUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC >mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop UGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU >cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop ACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU $ seqkit sort -l hairpin.fa.gz Sorting or filtering by GC (or other base by -flag -B ) content could also achieved in similar way. Get first 1000 sequences (use seqkit head -n 1000 ) $ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx $ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx Extension After converting FASTA to tabular format with seqkit fx2tab , it could be handled with CSV/TSV tools, e.g. csvtk , a cross-platform, efficient and practical CSV/TSV toolkit csvtk grep could be used to filter sequences (similar with seqkit grep ) csvtk inter computates intersection of multiple files. It could achieve similar function as seqkit common -n along with shell. csvtk join joins multiple CSV/TSV files by multiple IDs. csv_melt provides melt function, could be used in preparation of data for ploting. convert Usage convert FASTQ quality encoding between Sanger, Solexa and Illumina Usage: seqkit convert [flags] Flags: -d, --dry-run dry run -f, --force for Illumina-1.8+ -> Sanger, truncate scores > 40 to 40 --from string source quality encoding. if not given, we'll guess it -h, --help help for convert -n, --nrecords int number of records for guessing quality encoding (default 1000) -N, --thresh-B-in-n-most-common int threshold of 'B' in top N most common quality for guessing Illumina 1.5. (default 4) -F, --thresh-illumina1.5-frac float threshold of faction of Illumina 1.5 in the leading N records (default 0.1) --to string target quality encoding (default \"Sanger\") Examples: Note that seqkit convert always output sequences. The test dataset contains score 41 ( J ): $ seqkit head -n 1 tests/Illimina1.8.fq.gz @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< By default, nothing changes when converting Illumina 1.8 to Sanger. A warning message show that source and target quality encoding match. $ seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger [WARN] source and target quality encoding match. @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< When switching flag --force on, J (41) was converted to I (40). $ seqkit convert tests/Illimina1.8.fq.gz -f | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAIFFFIII<IIIIIFFFIFIIIIIFIIAIIIFIIFIFIIIIFAFI<IA<FFI7FIIFIIAAIIII<IIIIIIIFIIIAIIIIIFII77<IIII-F7A-FIFFIIIIII<FFI-<7FIIIFII)A7)7AA<7--)<-7F-A7FA< Other cases: To Illumina-1.5. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iiiiieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[ To Illumina-1.5 and back to Sanger. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit convert | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + !AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< Checking encoding $ seqkit convert tests/Illimina1.8.fq.gz --from Solexa [INFO] converting Solexa -> Sanger [ERRO] seq: invalid Solexa quality Real Illumina 1.5+ data $ seqkit seq tests/Illimina1.5.fq @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + efcfffffcfeefffcffffffddf`feed]`]_Ba_^__[YBBBBBBBBBBRTT\\]][]dddd`ddd^dddadd^BBBBBBBBBBBBBBBBBBBBBBBB $ seqkit convert tests/Illimina1.5.fq | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + FGDGGGGGDGFFGGGDGGGGGGEEGAGFFE>A>@!B@?@@<:!!!!!!!!!!355=>><>EEEEAEEE?EEEBEE?!!!!!!!!!!!!!!!!!!!!!!!! translate Usage translate DNA/RNA to protein sequence (supporting ambiguous bases) Note: 1. this command supports codons containing any ambiguous base. Plese switch on flag -L for details. e.g., for standard table: ACN -> T CCN -> P CGN -> R CTN -> L GCN -> A GGN -> G GTN -> V TCN -> S MGR -> R YTR -> L Translate Tables/Genetic Codes: # https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes 1: The Standard Code 2: The Vertebrate Mitochondrial Code 3: The Yeast Mitochondrial Code 4: The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code 5: The Invertebrate Mitochondrial Code 6: The Ciliate, Dasycladacean and Hexamita Nuclear Code 9: The Echinoderm and Flatworm Mitochondrial Code 10: The Euplotid Nuclear Code 11: The Bacterial, Archaeal and Plant Plastid Code 12: The Alternative Yeast Nuclear Code 13: The Ascidian Mitochondrial Code 14: The Alternative Flatworm Mitochondrial Code 16: Chlorophycean Mitochondrial Code 21: Trematode Mitochondrial Code 22: Scenedesmus obliquus Mitochondrial Code 23: Thraustochytrium Mitochondrial Code 24: Pterobranchia Mitochondrial Code 25: Candidate Division SR1 and Gracilibacteria Code 26: Pachysolen tannophilus Nuclear Code 27: Karyorelict Nuclear 28: Condylostoma Nuclear 29: Mesodinium Nuclear 30: Peritrich Nuclear 31: Blastocrithidia Nuclear Usage: seqkit translate [flags] Flags: -x, --allow-unknown-codon translate unknown code to 'X'. And you may not use flag --trim which removes 'X' --clean change all STOP codon positions from the '*' character to 'X' (an unknown residue) -f, --frame strings frame(s) to translate, available value: 1, 2, 3, -1, -2, -3, and 6 for all six frames (default [1]) -h, --help help for translate -M, --init-codon-as-M translate initial codon at beginning to 'M' -l, --list-transl-table int show details of translate table N, 0 for all (default -1) -L, --list-transl-table-with-amb-codons int show details of translate table N (including ambigugous codons), 0 for all. (default -1) -T, --transl-table int translate table/genetic code, type 'seqkit translate --help' for more details (default 1) --trim remove all 'X' and '*' characters from the right end of the translation Examples common usage $ seqkit translate tests/mouse-p53-cds.fna >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD* trim the * $ seqkit translate tests/mouse-p53-cds.fna --trim >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD different translate table $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --trim >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF different frame $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] SESNFSE*ITNNSYGKSKHKAPSPLIISFHFFYKFRI*LSY*ERSFCFISNCFIVI*LCF NSS*TFEDFSPCLFLH $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit seq -r -p \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF* show details of translate table 1 $ seqkit translate -l 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAT: N ACA: T, ACC: T, ACG: T, ACT: T AGA: R, AGC: S, AGG: R, AGT: S ATA: I, ATC: I, ATG: M, ATT: I CAA: Q, CAC: H, CAG: Q, CAT: H CCA: P, CCC: P, CCG: P, CCT: P CGA: R, CGC: R, CGG: R, CGT: R CTA: L, CTC: L, CTG: L, CTT: L GAA: E, GAC: D, GAG: E, GAT: D GCA: A, GCC: A, GCG: A, GCT: A GGA: G, GGC: G, GGG: G, GGT: G GTA: V, GTC: V, GTG: V, GTT: V TAA: *, TAC: Y, TAG: *, TAT: Y TCA: S, TCC: S, TCG: S, TCT: S TGA: *, TGC: C, TGG: W, TGT: C TTA: L, TTC: F, TTG: L, TTT: F show details of translate table 1, including ambigugous codons $ seqkit translate -L 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAR: K, AAT: N, AAY: N ACA: T, ACC: T, ACM: T, ACG: T, ACR: T, ACS: T, ACV: T, ACT: T, ACW: T, ACY: T, ACH: T, ACK: T, ACD: T, ACB: T, ACN: T AGA: R, AGC: S, AGG: R, AGR: R, AGT: S, AGY: S ATA: I, ATC: I, ATM: I, ATG: M, ATT: I, ATW: I, ATY: I, ATH: I CAA: Q, CAC: H, CAG: Q, CAR: Q, CAT: H, CAY: H CCA: P, CCC: P, CCM: P, CCG: P, CCR: P, CCS: P, CCV: P, CCT: P, CCW: P, CCY: P, CCH: P, CCK: P, CCD: P, CCB: P, CCN: P CGA: R, CGC: R, CGM: R, CGG: R, CGR: R, CGS: R, CGV: R, CGT: R, CGW: R, CGY: R, CGH: R, CGK: R, CGD: R, CGB: R, CGN: R CTA: L, CTC: L, CTM: L, CTG: L, CTR: L, CTS: L, CTV: L, CTT: L, CTW: L, CTY: L, CTH: L, CTK: L, CTD: L, CTB: L, CTN: L MGA: R, MGG: R, MGR: R GAA: E, GAC: D, GAG: E, GAR: E, GAT: D, GAY: D GCA: A, GCC: A, GCM: A, GCG: A, GCR: A, GCS: A, GCV: A, GCT: A, GCW: A, GCY: A, GCH: A, GCK: A, GCD: A, GCB: A, GCN: A GGA: G, GGC: G, GGM: G, GGG: G, GGR: G, GGS: G, GGV: G, GGT: G, GGW: G, GGY: G, GGH: G, GGK: G, GGD: G, GGB: G, GGN: G GTA: V, GTC: V, GTM: V, GTG: V, GTR: V, GTS: V, GTV: V, GTT: V, GTW: V, GTY: V, GTH: V, GTK: V, GTD: V, GTB: V, GTN: V TAA: *, TAC: Y, TAG: *, TAR: *, TAT: Y, TAY: Y TCA: S, TCC: S, TCM: S, TCG: S, TCR: S, TCS: S, TCV: S, TCT: S, TCW: S, TCY: S, TCH: S, TCK: S, TCD: S, TCB: S, TCN: S TGA: *, TGC: C, TGG: W, TGT: C, TGY: C TRA: * TTA: L, TTC: F, TTG: L, TTR: L, TTT: F, TTY: F YTA: L, YTG: L, YTR: L grep Usage search sequences by ID/name/sequence/sequence motifs, mismatch allowed Attentions: 1. Unlike POSIX/GNU grep, we compare the pattern to the whole target (ID/full header) by default. Please switch \"-r/--use-regexp\" on for partly matching. 2. While when searching by sequences, only positive strand is searched, and it's partly matching. Mismatch is allowed using flag \"-m/--max-mismatch\", but it's not fast enough for large genome like human genome. Though, it's fast enough for microbial genomes. 3. The order of sequences in result is consistent with that in original file, not the order of the query patterns. But for FASTA file, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt You can specify the sequence region for searching with flag -R (--region). The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit grep [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq search subseq on seq, only positive strand is searched, and mismatch allowed using flag -m/--max-mismatch -d, --degenerate pattern/motif contains degenerate base --delete-matched delete a pattern right after being matched, this keeps the firstly matched data and speedups when using regular expressions -h, --help help for grep -i, --ignore-case ignore case -v, --invert-match invert the sense of matching, to select non-matching records -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -p, --pattern strings search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string pattern file (one record per line) -R, --region string specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases -r, --use-regexp patterns are regular expression Examples Extract human hairpins (i.e. sequences with name starting with hsa ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU Remove human and mice hairpins. $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v Extract new entries by information from miRNA.diff.gz Get IDs of new entries. $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 > list $ more list cfa-mir-486 cfa-mir-339-1 pmi-let-7 Extract by ID list file $ zcat hairpin.fa.gz | seqkit grep -f list > new.fa Extract sequences containing AGGCG $ cat hairpin.fa.gz | seqkit grep -s -i -p aggcg Extract sequences containing AGGCG (allow mismatch) $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,181 145,789 49 123.4 2,354 real 0m0.058s user 0m0.100s sys 0m0.017s $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg -m 1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 17,168 1,881,005 39 109.6 2,354 real 0m0.864s user 0m0.941s sys 0m0.014s Extract sequences starting with AGGCG $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G. $ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA It's equal to but simpler than: $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA Specify sequence regions for searching. e.g., leading 30 bases. $ seqkit grep -s -R 1:30 -i -r -p GCTGG locate Usage locate subsequences/motifs, mismatch allowed Motifs could be EITHER plain sequence containing \"ACTGN\" OR regular expression like \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" for ORFs. Degenerate bases like \"RYMM..\" are also supported by flag -d. By default, motifs are treated as regular expression. When flag -d given, regular expression may be wrong. For example: \"\\w\" will be wrongly converted to \"\\[AT]\". Mismatch is allowed using flag \"-m/--max-mismatch\", but it's not fast enough for large genome like human genome. Though, it's fast enough for microbial genomes. Usage: seqkit locate [flags] Flags: --bed output in BED6 format -d, --degenerate pattern/motif contains degenerate base --gtf output in GTF format -h, --help help for locate -M, --hide-matched do not show matched sequences -i, --ignore-case ignore case -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -G, --non-greedy non-greedy mode, faster but may miss motifs overlapping with others -P, --only-positive-strand only search on positive strand -p, --pattern strings pattern/motif (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern/motif file (FASTA format) -F, --use-fmi use FM-index for much faster search of lots of sequence patterns -r, --use-regexp patterns/motifs are regular expression -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Locating subsequences (mismatch allowed) $ cat t.fa >seq agctggagctacc $ cat t.fa \\ | seqkit locate -p agc \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # do not show matched sequences $ cat t.fa \\ | seqkit locate -p agc -M \\ | csvtk pretty -t seqID patternName pattern strand start end seq agc agc + 1 3 seq agc agc + 7 9 seq agc agc - 8 10 seq agc agc - 2 4 # max mismatch: 1 $ cat t.fa \\ | seqkit locate -p agc -m 1 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc + 11 13 acc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # max mismatch: 2 $ cat t.fa \\ | seqkit locate -p agc -m 2 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 4 6 tgg seq agc agc + 5 7 gga seq agc agc + 7 9 agc seq agc agc + 10 12 tac seq agc agc + 11 13 acc seq agc agc - 11 13 ggt seq agc agc - 8 10 agc seq agc agc - 6 8 ctc seq agc agc - 5 7 tcc seq agc agc - 2 4 agc Locate ORFs. $ zcat hairpin.fa.gz \\ | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" -r \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-lin-4 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 1 36 AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 54 95 AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 43 51 AUGAUAUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 30 41 AUGGGCAUGUAA Locate Motif. $ zcat hairpin.fa.gz \\ | seqkit locate -i -d -p AUGGACUN \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-mir-58a AUGGACUN AUGGACUN + 81 88 AUGGACUG ath-MIR163 AUGGACUN AUGGACUN - 122 129 AUGGACUC cel-mir-270 AUGGACUN AUGGACUN + 84 91 AUGGACUG Notice that seqkit grep only searches in positive strand, but seqkit loate could recognize both strand. Output in GTF or BED6 format, which you can use in seqkit subseq $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --bed cel-mir-58a 80 88 AUGGACUN 0 + ath-MIR163 121 129 AUGGACUN 0 - $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --gtf cel-mir-58a SeqKit location 81 88 0 + . gene_id \"AUGGACUN\"; ath-MIR163 SeqKit location 122 129 0 - . gene_id \"AUGGACUN\"; greedy mode (default) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 4 7 ACGA seq ACGA ACGA + 7 10 ACGA non-greedy mode ( -G ) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA fish Usage look for short sequences in larger sequences using local alignment Attention: 1. output coordinates are BED-like 0-based, left-close and right-open. 2. alignment information are printed to STDERR. Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular $ seqkit fish -q 4.7 -F GGCGGCTGTGACC -g mouse-p53-cds.fna Compare to seqkit locate : $ echo -e '>seq\\nACGACGACGA' \\ | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA $ echo -e '>seq\\nACGACGACGA' \\ | seqkit fish -F ACGA -a 2>&1 | csvtk -t pretty Ref RefStart RefEnd Query QueryStart QueryEnd Strand MapQual RawScore Acc ClipAcc QueryCov seq 6 10 q0 0 4 + 60.00 16 100.00 100.00 100.00 seq 0 4 q0 0 4 + 60.00 16 100.00 100.00 100.00 Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna amplicon Usage retrieve amplicon (or specific region around it) via primer(s). Examples: 0. no region given. F -----===============----- F R -----=====-----=====----- =============== amplicon 1. inner region (-r x:y). F -----===============----- 1 3 5 x/y -5-3-1 x/y F R -----=====-----=====----- x:y =============== 1:-1 ======= 1:7 ===== 3:7 ===== 6:10 ===== -10:-6 ===== -7:-3 -x:y (invalid) 2. flanking region (-r x:y -f) F -----===============----- -3-1 x/y 1 3 5 x/y F R -----=====-----=====----- ===== -5:-1 === -5:-3 ===== 1:5 === 3:5 ================= -1:1 ========================= -5:5 x:-y (invalid) Usage: seqkit amplicon [flags] Flags: -f, --flanking-region region is flanking region -F, --forward string forward primer -h, --help help for amplicon -m, --max-mismatch int max mismatch when matching primers -r, --region string specify region to return. type \"seqkit amplicon -h\" for detail -R, --reverse string reverse primer -s, --strict strict mode, i.e., discarding seqs not fully matching (shorter) given region range Examples No region given. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" >seq acgcccactgaaatga $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt >seq cccactgaaa Inner region # region right behind forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 >seq actg # more common case is triming primers $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:-4 >seq actg flanking region # in one of my sequencing data, I only care about # region downstream of forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 >seq tgaa # if given region if out scope of sequence. e.g, # 2-5bp downstream of aaa, we can get part of region (2-4) by default $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 >seq ga # you can also use strict mode to discard those cases $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 -s duplicate Usage duplicate sequences N times You may need \"seqkit rename\" to make the the sequence IDs unique. Usage: seqkit duplicate [flags] Aliases: duplicate, dup Flags: -h, --help help for duplicate -n, --times int duplication number (default 1) Examples Data $ cat tests/hairpin.fa | seqkit head -n 1 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA Duplicate 2 times $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA use seqkit rename to make the the sequence IDs unique. $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 | seqkit rename >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7_2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA rmdup Usage remove duplicated sequences by id/name/sequence Usage: seqkit rmdup [flags] Flags: -n, --by-name by full name instead of just id -s, --by-seq by seq -D, --dup-num-file string file to save number and list of duplicated seqs -d, --dup-seqs-file string file to save duplicated seqs -h, --help help for rmdup -i, --ignore-case ignore case Examples Similar to common . General use $ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 2226 duplicated records removed $ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 1086 duplicated records removed Save duplicated sequences to file $ zcat hairpin.fa.gz \\ | seqkit rmdup -s -i -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ cat duplicated.detail.txt # here is not the entire list 3 hsa-mir-424, mml-mir-424, ppy-mir-424 3 hsa-mir-342, mml-mir-342, ppy-mir-342 2 ngi-mir-932, nlo-mir-932 2 ssc-mir-9784-1, ssc-mir-9784-2 common Usage find common sequences of multiple files by id/name/sequence Note: 1. 'seqkit common' is designed to support 2 and MORE files. 2. For 2 files, 'seqkit grep' is much faster and consumes lesser memory: seqkit grep -f <(seqkit seq -n -i small.fq.gz) big.fq.gz # by seq ID seqkit grep -s -f <(seqkit seq -s small.fq.gz) big.fq.gz # by seq 3. Some records in one file may have same sequences/IDs. They will ALL be retrieved if the sequence/ID was shared in multiple files. So the records number may be larger than that of the smallest file. Usage: seqkit common [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq match by sequence -h, --help help for common -i, --ignore-case ignore case Examples By ID (default) seqkit common file*.fa -o common.fasta By full name seqkit common file*.fa -n -o common.fasta By sequence seqkit common file*.fa -s -i -o common.fasta split Usage split sequences into files by name ID, subsequence of given region, part size or number of parts. Please use \"seqkit split2\" for paired- and single-end FASTQ. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit split [flags] Flags: -i, --by-id split squences according to sequence ID -p, --by-part int split sequences into N parts -r, --by-region string split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \"seqkit split -h\" for more examples -s, --by-size int split sequences into multi parts with N sequences -d, --dry-run dry run, just print message and no files will be created. -f, --force overwrite output directory -h, --help help for split -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -O, --out-dir string output directory (default value is $infile.split) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples Split sequences into parts with at most 10000 sequences $ seqkit split hairpin.fa.gz -s 10000 [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.part_001.gz [INFO] write 7162 sequences to file: hairpin.fa.part_002.gz [INFO] write 7162 sequences to file: hairpin.fa.part_003.gz [INFO] write 7159 sequences to file: hairpin.fa.part_004.gz To reduce memory usage when spliting big file, we should alwasy use flag --two-pass $ seqkit split hairpin.fa.gz -p 4 -2 [INFO] split into 4 parts [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 28645 sequences loaded [INFO] write 7162 sequences to file: hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.part_004.fa.gz Split sequences by species. i.e. by custom IDs (first three letters) $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2 [INFO] split by ID. idRegexp: ^([\\w]+)\\- [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] create and read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fa [INFO] read sequence IDs from FASTA index ... [INFO] 28645 sequences loaded [INFO] write 48 sequences to file: hairpin.id_cca.fa.gz [INFO] write 3 sequences to file: hairpin.id_hci.fa.gz [INFO] write 106 sequences to file: hairpin.id_str.fa.gz [INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz ... Split sequences by sequence region (for example, sequence barcode) $ seqkit split hairpin.fa.gz -r 1:3 -2 [INFO] split by region: 1:3 [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] read sequence IDs and sequence region from FASTA file ... [INFO] create and read FASTA index ... [INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz [INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz [INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz Sequence suffix could be defined as -r -12:-1 split2 Usage split sequences into files by part size or number of parts This command supports FASTA and paired- or single-end FASTQ with low memory occupation and fast speed. The file extensions of output are automatically detected and created according to the input files. Usage: seqkit split2 [flags] Flags: -l, --by-length string split sequences into chunks of N bases, supports K/M/G suffix -p, --by-part int split sequences into N parts -s, --by-size int split sequences into multi parts with N sequences -f, --force overwrite output directory -h, --help help for split2 -O, --out-dir string output directory (default value is $infile.split) -1, --read1 string read1 file -2, --read2 string read2 file Examples Split sequences into parts with at most 10000 sequences $ seqkit split2 hairpin.fa.gz -s 10000 -f [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 -f [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.fa.gz.split/hairpin.part_004.fa.gz For FASTQ files (paired-end) $ seqkit split2 -1 reads_1.fq.gz -2 reads_2.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz and reads_2.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_2.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_2.part_002.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz For FASTA files (single-end) $ seqkit split2 -1 reads_1.fq.gz reads_2.fq.gz -p 2 -O out -f [INFO] flag -1/--read1 given, ignore: reads_2.fq.gz [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz $ seqkit split2 reads_1.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz sample Usage sample sequences by number or proportion. Usage: seqkit sample [flags] Flags: -n, --number int sample by number (result may not exactly match) -p, --proportion float sample by proportion -s, --rand-seed int rand seed (default 11) -2, --two-pass 2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin Examples Sample by proportion $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz [INFO] sample by proportion [INFO] 2814 sequences outputed Sample by number $ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz [INFO] sample by number [INFO] 949 sequences outputed 949 != 1000 ??? see Effect of random seed on results of seqkit sample To reduce memory usage when spliting big file, we could use flag --two-pass We can also use seqkit sample -p followed with seqkit head -n : $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit head -n 1000 -o sample.fa.gz Set rand seed to reproduce the result $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 -s 11 Most of the time, we could shuffle after sampling $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit shuffle -o sample.fa.gz Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) head Usage print first N FASTA/Q records Usage: seqkit head [flags] Flags: -n, --number int print first N FASTA/Q records (default 10) Examples FASTA $ seqkit head -n 1 hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA FASTQ $ seqkit head -n 1 reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII range Usage print FASTA/Q records in a range (start:end) Usage: seqkit range [flags] Flags: -h, --help help for range -r, --range string range. e.g., 1:12 for first 12 records (head -n 12), -12:-1 for last 12 records (tail -n 12) Examples leading N records (head) $ cat tests/hairpin.fa | seqkit head -n 100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - $ cat tests/hairpin.fa | seqkit range -r 1:100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - last N records (tail) $ cat tests/hairpin.fa | seqkit range -r -100:-1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 100 8,656 58 86.6 172 Other ranges $ cat tests/hairpin.fa | seqkit range -r 101:150 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 50 3,777 63 75.5 96 $ cat tests/hairpin.fa | seqkit range -r -100:-2 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 99 8,484 58 85.7 146 replace Usage replace name/sequence by regular expression. Note that the replacement supports capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: use SINGLE quote NOT double quotes in *nix OS. Examples: Adding space to all bases. seqkit replace -p \"(.)\" -r '$1 ' -s Or use the \\ escape character. seqkit replace -p \"(.)\" -r \"\\$1 \" -s more on: http://bioinf.shenwei.me/seqkit/usage/#replace Special replacement symbols (only for replacing name not sequence): {nr} Record number, starting from 1 {kv} Corresponding value of the key (captured variable $n) by key-value file, n can be specified by flag -I (--key-capt-idx) (default: 1) Usage: seqkit replace [flags] Flags: -s, --by-seq replace seq -h, --help help for replace -i, --ignore-case ignore case -K, --keep-key keep the key as value when no value found for the key (only for sequence name) -I, --key-capt-idx int capture variable index of key (1-based) (default 1) -m, --key-miss-repl string replacement for key with no corresponding value -k, --kv-file string tab-delimited key-value file for replacing key with value when using \"{kv}\" in -r (--replacement) (only for sequence name) --nr-width int minimum width for {nr} in flag -r/--replacement. e.g., formating \"1\" to \"001\" by --nr-width 3 (default 1) -p, --pattern string search regular expression -r, --replacement string replacement. supporting capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by \"{nr}\".use ${1} instead of $1 when {kv} given! Examples Remove descriptions $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\s.+\" >seq1 ACGT-ACGT Replace \"-\" with \"=\" $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\-\" -r '=' >seq1 abc=123 ACGT-ACGT Remove gaps in sequences. $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \" |-\" -s >seq1 abc-123 ACGTACGT Add space to every base. ATTENTION: use SINGLE quote NOT double quotes in *nix OS $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r '$1 ' -s >seq1 abc-123 A C G T - A C G T Transpose sequence with csvtk $ echo -e \">seq1\\nACTGACGT\\n>seq2\\nactgccgt\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s \\ | seqkit seq -s -u \\ | csvtk space2tab \\ | csvtk -t transpose A A C C T T G G A C C C G G T T Rename with number of record $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" >seq_1 ACTG >seq_2 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" --nr-width 5 >seq_00001 ACTG >seq_00002 ATTT Replace key with value by key-value file $ more test.fa >seq1 name1 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 name3 CCCCAAAACCCCATGTTGCTACTAG $ more alias.txt name0 ABC name1 123 name3 Hello name4 World $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG convert fasta to genbank style $ cat seq.fa >seq1 TTTAAAGAGACCGGCGATTCTAGTGAAATCGAACGGGCAGGTCAATTTCCAACCAGCGAT GACGTAATAGATAGATACAAGGAAGTCATTTTTCTTTTAAAGGATAGAAACGGTTAATGC TCTTGGGACGGCGCTTTTCTGTGCATAACT >seq2 AAGGATAGAAACGGTTAATGCTCTTGGGACGGCGCTTTTCTGTGCATAACTCGATGAAGC CCAGCAATTGCGTGTTTCTCCGGCAGGCAAAAGGTTGTCGAGAACCGGTGTCGAGGCTGT TTCCTTCCTGAGCGAAGCCTGGGGATGAACG $ cat seq.fa \\ | seqkit replace -s -p '(\\w{10})' -r '$1 ' -w 66 \\ | perl -ne 'if (/^>/) {print; $n=1} \\ else {s/ \\r?\\n$/\\n/; printf \"%9d %s\", $n, $_; $n+=60;}' >seq1 1 TTTAAAGAGA CCGGCGATTC TAGTGAAATC GAACGGGCAG GTCAATTTCC AACCAGCGAT 61 GACGTAATAG ATAGATACAA GGAAGTCATT TTTCTTTTAA AGGATAGAAA CGGTTAATGC 121 TCTTGGGACG GCGCTTTTCT GTGCATAACT >seq2 1 AAGGATAGAA ACGGTTAATG CTCTTGGGAC GGCGCTTTTC TGTGCATAAC TCGATGAAGC 61 CCAGCAATTG CGTGTTTCTC CGGCAGGCAA AAGGTTGTCG AGAACCGGTG TCGAGGCTGT 121 TTCCTTCCTG AGCGAAGCCT GGGGATGAAC G rename Usage rename duplicated IDs Usage: seqkit rename [flags] Flags: -n, --by-name check duplication by full name instead of just id -f, --force overwrite output directory -h, --help help for rename -m, --multiple-outfiles write results into separated files for multiple input files -O, --out-dir string output directory (default \"renamed\") Examples $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" >a comment acgt >b comment of b ACTG >a comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename >a comment acgt >b comment of b ACTG >a_2 a comment aaaa restart Usage reset start position for circular genome Examples $ echo -e \">seq\\nacgtnACGTN\" >seq acgtnACGTN $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i 2 >seq cgtnACGTNa $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i -2 >seq TNacgtnACG Usage: seqkit restart [flags] Flags: -i, --new-start int new start position (1-base, supporting negative value counting from the end) (default 1) concat Usage concatenate sequences with same ID from multiple files Example: concatenating leading 2 bases and last 2 bases $ cat t.fa >test ACCTGATGT >test2 TGATAGCTACTAGGGTGTCTATCG $ seqkit concat <(seqkit subseq -r 1:2 t.fa) <(seqkit subseq -r -2:-1 t.fa) >test ACGT >test2 TGCG Usage: seqkit concat [flags] Flags: -h, --help help for concat mutate Usage edit sequence (point mutation, insertion, deletion) Attentions: 1. Mutiple point mutations (-p/--point) are allowed, but only single insertion (-i/--insertion) OR single deletion (-d/--deletion) is allowed. 2. Point mutation takes place before insertion/deletion. Notes: 1. You can choose certain sequences to edit using similar flags in 'seqkit grep'. The definition of position is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit mutate [flags] Flags: -n, --by-name [match seqs to mutate] match by full name instead of just id -d, --deletion string deletion mutation: deleting subsequence in a range. e.g., -d 1:2 for deleting leading two bases, -d -3:-1 for removing last 3 bases -h, --help help for mutate -I, --ignore-case [match seqs to mutate] ignore case of search pattern -i, --insertion string insertion mutation: inserting bases behind of given position, e.g., -i 0:ACGT for inserting ACGT at the beginning, -1:* for add * to the end -v, --invert-match [match seqs to mutate] invert the sense of matching, to select non-matching records --pattern strings [match seqs to mutate] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string [match seqs to mutate] pattern file (one record per line) -p, --point strings point mutation: changing base at given postion. e.g., -p 2:C for setting 2nd base as C, -p -1:A for change last base as A -r, --use-regexp [match seqs to mutate] search patterns are regular expression Examples: Point mutation: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" >1 ACTGNactgn >2 actgnACTGN # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x [INFO] edit seq: 1 [INFO] edit seq: 2 >1 xCTGNactgn >2 xctgnACTGN # 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 5:x --quiet >1 ACTGxactgn >2 actgxACTGN # last base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p -1:x --quiet >1 ACTGNactgx >2 actgnACTGx # mutiple locations: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x -p -1:x --quiet >1 xCTGNactgx >2 xctgnACTGx Deletion # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d 1:1 --quiet >1 CTGNactgn >2 ctgnACTGN # last 3 bases $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d -3:-1 --quiet >1 ACTGNac >2 actgnAC Insertion: inserting bases behind of given position # at the beginning $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 0:xx --quiet >1 xxACTGNactgn >2 xxactgnACTGN # at the end $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i -1:xx --quiet >1 ACTGNactgnxx >2 actgnACTGNxx # behind of 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 5:x --quiet >1 ACTGNxactgn >2 actgnxACTGN Choosing which sequences to edit , using similar flags in seqkit grep . $ cat tests/hsa.fa >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # only edit chr1 and chr2 # or cat tests/hsa.fa | seqkit mutate -p -1:X -s chr1 -s chr2 $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1,chr2 [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # using regular expression to match. # e,g., editing all chrosomes: $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -r -s chr [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq [INFO] edit seq: chr11 11th seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgn # excluding seqs $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1 -s chr2 -v [INFO] edit seq: chr11 11th seq [INFO] edit seq: MT mitochondrial seq >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgX shuffle Usage shuffle sequences. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence IDs. If the file is not plain FASTA file, seqkit will write the sequences to tempory files, and create FASTA index. Secondly, seqkit shuffles sequence IDs and extract sequences by FASTA index. Usage: seqkit shuffle [flags] Flags: -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -s, --rand-seed int rand seed for shuffle (default 23) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples General use. $ seqkit shuffle hairpin.fa.gz > shuffled.fa [INFO] read sequences ... [INFO] 28645 sequences loaded [INFO] shuffle ... [INFO] output ... For big genome, you'd better use two-pass mode so seqkit could use FASTA index to reduce memory usage $ time seqkit shuffle -2 hsa.fa > shuffle.fa [INFO] create and read FASTA index ... [INFO] create FASTA index for hsa.fa [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... real 0m35.080s user 0m45.521s sys 0m3.411s Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) for read 1 and 2 files. sort Usage sort sequences by id/name/sequence/length. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence head and length information. If the file is not plain FASTA file, seqkit will write the sequences to tempory files, and create FASTA index. Secondly, seqkit sorts sequence by head and length information and extracts sequences by FASTA index. Usage: seqkit sort [flags] Flags: -l, --by-length by sequence length -n, --by-name by full name instead of just id -s, --by-seq by sequence -i, --ignore-case ignore case -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -N, --natural-order sort in natural order, when sorting by IDs/full name -r, --reverse reverse the result -L, --seq-prefix-length int length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples For FASTA format, use flag -2 (--two-pass) to reduce memory usage sort by ID $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by ID and in natural order $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit seq -n -i 3 1 Y x Mt 11 2 $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit sort -N -i -2 \\ | seqkit seq -n -i 1 2 3 11 Mt x Y sort by ID, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -i >seq1 ACGTNcccc >SEQ2 acgtnAAAA sort by seq, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -s -i >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by sequence length $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAAnnn\\n>seq3\\nacgt\" \\ | seqkit sort --quiet -l >seq3 acgt >seq1 ACGTNcccc >SEQ2 acgtnAAAAnnn bam monitoring and online histograms of BAM record features Usage: seqkit bam [flags] Flags: -B, --bins int number of histogram bins (default -1) -c, --count string count reads per reference and save to this file -W, --delay int sleep this many seconds after plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -e, --exec-after string execute command after reporting -E, --exec-before string execute command before reporting -f, --field string target fields -h, --help help for bam -C, --idx-count fast read per reference counting based on the BAM index -i, --idx-stat fast statistics based on the BAM index -O, --img string save histogram to this PDF/image file -H, --list-fields list all available BAM record features -L, --log log10(x+1) transform numeric values -q, --map-qual int minimum mapping quality -x, --pass passthrough mode (forward filtered BAM to output) -F, --prim-only filter out non-primary alignment records -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -Q, --quiet-mode supress all plotting to stderr -M, --range-max float discard record with field (-f) value greater than this flag (default NaN) -m, --range-min float discard record with field (-f) value less than this flag (default NaN) -R, --reset reset histogram after every report -s, --stat print BAM satistics of the input files -@, --top-bam string save the top -? records to this bam file -?, --top-size int size of the top-mode buffer (default 100) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Get detailed statistics from multiple BAM files. seqkit bam -s *.bam Get rough statistics from multiple indexed BAM files. seqkit bam -i *.bam Count reads mapped to references from a BAM stream. cat sample.bam | seqkit bam -c counts.tsv - Count reads mapped to references using the BAM index. seqkit bam -C sorted_indexed.bam Monitor alignment accuracy from a bam stream and report after every 1000 records, use 20 bins. cat sample.bam | seqkit bam -B -f Acc -p 1000 - Dump selected fields to TSV. seqkit bam -f Ref,Acc,RefCov,Strand sample.bam Save the best 100 records in terms of alignment accuracy to a BAM file. seqkit bam -f Acc -@ top_acc_100.bam -? 100 -Q sample.bam fish look for short sequences in larger sequences using local alignment Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular seqkit fish -q 4.7 -F \"GGCGGCTGTGACC\" -g mouse-p53-cds.fna Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna sana sanitize broken single line fastq files Usage: seqkit sana [flags] Flags: -h, --help help for sana -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq > rescued.fq watch monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Histogram of log sequence length seqkit watch -L -f ReadLen hairpin.fa Histogram of mean base qualities every 500 record, also saved as PDF seqkit watch -p 500 -O qhist.pdf -f MeanQual reads_1.fq.gz genautocomplete Usage generate shell autocompletion script Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: 1. run: seqkit genautocomplete 2. create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done Usage: seqkit genautocomplete [flags] Flags: --file string autocompletion file (default \"/home/shenwei/.bash_completion.d/seqkit.sh\") -h, --help help for genautocomplete --type string autocompletion type (currently only bash supported) (default \"bash\") /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Usage"},{"location":"usage/#usage-and-examples","text":"","title":"Usage and Examples"},{"location":"usage/#table-of-contents","text":"Technical details and guides for use seqkit Sequence and subsequence seq subseq sliding stats faidx watch sana Format conversion fq2fa fx2tab & tab2fx convert translate Searching grep locate fish amplicon BAM processing and monitoring bam Set operations head range sample rmdup duplicate common split split2 Edit replace rename restart concat mutate Ordering shuffle sort Misc genautocomplete","title":"Table of Contents"},{"location":"usage/#technical-details-and-guides-for-use","text":"","title":"Technical details and guides for use"},{"location":"usage/#fastaq-format-parsing","text":"SeqKit uses author's lightweight and high-performance bioinformatics packages bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Seqkit calls pigz (much faster than gzip ) or gzip to decompress .gz file if they are available. So please install pigz to gain better parsing performance for gzipped data . Seqkit does not call pigz or gzip any more since v0.8.1, Because it does not always increase the speed. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . Seqkit uses package pgzip to write gzip file, which is very fast ( 10X of gzip , 4X of pigz ) and the gzip file would be slighty larger.","title":"FASTA/Q format parsing"},{"location":"usage/#sequence-formats-and-types","text":"SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked.","title":"Sequence formats and types"},{"location":"usage/#sequence-id","text":"By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" .","title":"Sequence ID"},{"location":"usage/#fasta-index","text":"For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key.","title":"FASTA index"},{"location":"usage/#parallelization-of-cpu-intensive-jobs","text":"The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 1 for single-CPU PC, 2 for others).","title":"Parallelization of CPU intensive jobs"},{"location":"usage/#memory-occupation","text":"Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands need to store sequences or heads in memory, but there are strategy to reduce memory occupation, including rmdup and common . When comparing with sequences, MD5 digest could be used to replace sequence by flag -m ( --md5 ). Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation.","title":"Memory occupation"},{"location":"usage/#reproducibility","text":"Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed.","title":"Reproducibility"},{"location":"usage/#seqkit","text":"SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Version: 0.12.1 Author: Wei Shen <shenwei356@gmail.com> Documents : http://bioinf.shenwei.me/seqkit Source code: https://github.com/shenwei356/seqkit Please cite: https://doi.org/10.1371/journal.pone.0163962 Usage: seqkit [command] Available Commands: amplicon retrieve amplicon (or specific region around it) via primer(s) bam monitoring and online histograms of BAM record features common find common sequences of multiple files by id/name/sequence concat concatenate sequences with same ID from multiple files convert convert FASTQ quality encoding between Sanger, Solexa and Illumina duplicate duplicate sequences N times faidx create FASTA index file and extract subsequence fish look for short sequences in larger sequences using local alignment fq2fa convert FASTQ to FASTA fx2tab convert FASTA/Q to tabular format (with length/GC content/GC skew) genautocomplete generate shell autocompletion script grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed head print first N FASTA/Q records help Help about any command locate locate subsequences/motifs, mismatch allowed mutate edit sequence (point mutation, insertion, deletion) range print FASTA/Q records in a range (start:end) rename rename duplicated IDs replace replace name/sequence by regular expression restart reset start position for circular genome rmdup remove duplicated sequences by id/name/sequence sample sample sequences by number or proportion sana sanitize broken single line fastq files seq transform sequences (revserse, complement, extract ID...) shuffle shuffle sequences sliding sliding sequences, circular genome supported sort sort sequences by id/name/sequence/length split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) stats simple statistics of FASTA/Q files subseq get subsequences by region/gtf/bed, including flanking sequences tab2fx convert tabular format to FASTA/Q format translate translate DNA/RNA to protein sequence (supporting ambiguous bases) version print version information and check for update watch monitoring and online histograms of sequence features Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) -h, --help help for seqkit --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") --infile-list string file of input files list (one file per line), if given, they are appended to files from cli arguments -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)","title":"seqkit"},{"location":"usage/#datasets","text":"Datasets from The miRBase Sequence Database -- Release 21 hairpin.fa.gz mature.fa.gz miRNA.diff.gz Human genome from ensembl (For seqkit subseq ) Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz Homo_sapiens.GRCh38.84.gtf.gz Homo_sapiens.GRCh38.84.bed.gz is converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command zcat Homo_sapiens.GRCh38.84.gtf.gz \\ | gtf2bed --do-not-sort \\ | gzip -c > Homo_sapiens.GRCh38.84.bed.gz Only DNA and gtf/bed data of Chr1 were used: chr1.fa.gz seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz chr1.gtf.gz zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c > chr1.gtf.gz chr1.bed.gz zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c > chr1.bed.gz","title":"Datasets"},{"location":"usage/#seq","text":"Usage transform sequences (revserse, complement, extract ID...) Usage: seqkit seq [flags] Flags: -p, --complement complement sequence, flag '-v' is recommended to switch on --dna2rna DNA to RNA -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for seq -l, --lower-case print sequences in lower case -M, --max-len int only print sequences shorter than the maximum length (-1 for no limit) (default -1) -R, --max-qual float only print sequences with average quality less than this limit (-1 for no limit) (default -1) -m, --min-len int only print sequences longer than the minimum length (-1 for no limit) (default -1) -Q, --min-qual float only print sequences with average quality qreater or equal than this limit (-1 for no limit) (default -1) -n, --name only print names -i, --only-id print ID instead of full head -q, --qual only print qualities -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -g, --remove-gaps remove gaps -r, --reverse reverse sequence --rna2dna RNA to DNA -s, --seq only print sequences -u, --upper-case print sequences in upper case -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Read and print From file: $ seqkit seq hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA $ seqkit seq read_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII From stdin: zcat hairpin.fa.gz | seqkit seq Sequence types By default, seqkit seq automatically detect the sequence type $ echo -e \">seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA DNA 1 28 28 28 28 $ echo -e \">seq\\nACGUN ACGUN\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1 11 11 11 11 $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA Protein 1 23 23 23 23 $ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTQ DNA 1 6 6 6 6 You can also set sequence type by flag -t ( --seq-type ). But this only take effect on subcommands seq and locate . $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna [INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on [ERRO] error when parsing seq: seq (invalid DNAredundant letter: e) Only print names Full name: $ seqkit seq hairpin.fa.gz -n cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop Only ID: $ seqkit seq hairpin.fa.gz -n -i cel-let-7 cel-lin-4 cel-mir-1 Custom ID region by regular expression (this could be applied to all subcommands): $ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\" MI0000001 MI0000002 MI0000003 Only print seq (global flag -w defines the output line width, 0 for no wrap) $ seqkit seq hairpin.fa.gz -s -w 0 UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU Convert multi-line FASTQ to 4-line FASTQ $ seqkit seq reads_1.fq.gz -w 0 Reverse comlement sequence $ seqkit seq hairpin.fa.gz -r -p >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA Remove gaps and to lower/upper case $ echo -e \">seq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u >seq ACGTACTGCACC RNA to DNA $ echo -e \">seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna >seq TCATATGCTTGTCTCAAAGATTA Filter by sequence length $ cat hairpin.fa | seqkit seq | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 28,645 2,949,871 39 103 2,354 $ cat hairpin.fa | seqkit seq -m 100 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,975 1,565,486 100 142.6 2,354 $ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,972 1,560,270 100 142.2 938","title":"seq"},{"location":"usage/#subseq","text":"Usage get subsequences by region/gtf/bed, including flanking sequences. Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit subseq [flags] Flags: --bed string by BED file --chr value select limited sequence with sequence IDs when using flag --gtf or --bed (multiple value supported, case ignored) (default []) -d, --down-stream int down stream length --feature value select limited feature types (multiple value supported, case ignored, only works with GTF) (default []) --gtf string by GTF (version 2.2) file --gtf-tag string output this tag as sequence comment (default \"gene_id\") -f, --only-flank only return up/down stream sequence -r, --region string by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \"seqkit subseq -h\" for more examples -u, --up-stream int up stream length Examples Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. First 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 1:12 Last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r -12:-1 Subsequences without first and last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 13:-13 Get subsequence by GTF file $ cat t.fa >seq actgACTGactgn $ cat t.gtf seq test CDS 5 8 . . . gene_id \"A\"; transcript_id \"\"; seq test CDS 5 8 . - . gene_id \"B\"; transcript_id \"\"; $ seqkit subseq --gtf t.gtf t.fa >seq_5:8:. A ACTG >seq_5:8:- B CAGT Human genome example: AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. We could specify chromesomes and features. $ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa > chr1.gtf.cds.fa $ seqkit stats chr1.gtf.cds.fa file format type num_seqs sum_len min_len avg_len max_len chr1.gtf.cds.fa FASTA DNA 65,012 9,842,274 1 151.4 12,045 Get CDS and 3bp up-stream sequences $ seqkit subseq --gtf t.gtf t.fa -u 3 >seq_5:8:._us:3 A ctgACTG >seq_5:8:-_us:3 B agtCAGT Get 3bp up-stream sequences of CDS, not including CDS $ seqkit subseq --gtf t.gtf t.fa -u 3 -f >seq_5:8:._usf:3 A ctg >seq_5:8:-_usf:3 B agt Get subsequences by BED file. AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ > chr1.bed.gz.fa We may need to remove duplicated sequences $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ | seqkit rmdup > chr1.bed.rmdup.fa [INFO] 141060 duplicated records removed Summary: $ seqkit stats chr1.gz.*.gz file seq_format seq_type num_seqs min_len avg_len max_len chr1.gz.fa FASTA DNA 231,974 1 3,089.5 1,551,957 chr1.gz.rmdup.fa FASTA DNA 90,914 1 6,455.8 1,551,957","title":"subseq"},{"location":"usage/#sliding","text":"Usage sliding sequences, circular genome supported Usage: seqkit sliding [flags] Flags: -C, --circular-genome circular genome. -g, --greedy greedy mode, i.e., exporting last subsequences even shorter than windows size -s, --step int step size -W, --window int window size Examples General use $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN Greedy mode $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-12 gtNN >seq_sliding:10-15 N Circular genome $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-2 gtNNAC >seq_sliding:10-5 NACGTa Generate GC content for ploting $ zcat hairpin.fa.gz \\ | seqkit sliding -s 5 -W 30 \\ | seqkit fx2tab -n -g cel-let-7_sliding:1-30 50.00 cel-let-7_sliding:6-35 46.67 cel-let-7_sliding:11-40 43.33 cel-let-7_sliding:16-45 36.67 cel-let-7_sliding:21-50 33.33 cel-let-7_sliding:26-55 40.00 ...","title":"sliding"},{"location":"usage/#stats","text":"Usage simple statistics of FASTA/Q files Tips: 1. For lots of small files (especially on SDD), use big value of '-j' to parallelize counting. Usage: seqkit stats [flags] Aliases: stats, stat Flags: -a, --all all statistics, including quartiles of seq length, sum_gap, N50 -b, --basename only output basename of files -E, --fq-encoding string fastq quality encoding. available values: 'sanger', 'solexa', 'illumina-1.3+', 'illumina-1.5+', 'illumina-1.8+'. (default \"sanger\") -G, --gap-letters string gap letters (default \"- .\") -h, --help help for stats -e, --skip-err skip error, only show warning message -T, --tabular output in machine-friendly tabular format Eexamples General use $ seqkit stats *.f{a,q}.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Machine-friendly tabular format $ seqkit stats *.f{a,q}.gz -T file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # So you can process the result with tools like csvtk: http://bioinf.shenwei.me/csvtk $ seqkit stats *.f{a,q}.gz -T | csvtk pretty -t file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # To markdown $ seqkit stats *.f{a,q}.gz -T | csvtk csv2md -t file |format|type|num_seqs|sum_len|min_len|avg_len|max_len :----------------|:-----|:---|:-------|:------|:------|:------|:------ hairpin.fa.gz |FASTA |RNA |28645 |2949871|39 |103.0 |2354 mature.fa.gz |FASTA |RNA |35828 |781222 |15 |21.8 |34 Illimina1.8.fq.gz|FASTQ |DNA |10000 |1500000|150 |150.0 |150 reads_1.fq.gz |FASTQ |DNA |2500 |567516 |226 |227.0 |229 reads_2.fq.gz |FASTQ |DNA |2500 |560002 |223 |224.0 |225 file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 Extra information $ seqkit stats *.f{a,q}.gz -a file format type num_seqs sum_len min_len avg_len max_len Q1 Q2 Q3 sum_gap N50 Q20(%) Q30(%) hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 76 91 111 0 101 0 0 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 21 22 22 0 22 0 0 Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 150 150 150 0 150 96.16 89.71 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 227 227 227 0 227 91.24 86.62 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 224 224 224 0 224 91.06 87.66 Parallelize counting files, it's much faster for lots of small files, especially for files on SSD seqkit stats -j 10 refseq/virual/*.fna.gz Skip error $ seqkit stats tests/* [ERRO] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format $ seqkit stats tests/* -e [WARN] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format [WARN] tests/hairpin.fa.seqkit.fai: fastx: invalid FASTA/Q format [WARN] tests/miRNA.diff.gz: fastx: invalid FASTA/Q format [WARN] tests/test.sh: fastx: invalid FASTA/Q format file format type num_seqs sum_len min_len avg_len max_len tests/contigs.fa FASTA DNA 9 54 2 6 10 tests/hairpin.fa FASTA RNA 28,645 2,949,871 39 103 2,354 tests/Illimina1.5.fq FASTQ DNA 1 100 100 100 100 tests/Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 tests/hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 tests/reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 tests/mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 tests/reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Output basename instead of full path ( -b/--basename )","title":"stats"},{"location":"usage/#faidx","text":"Usage create FASTA index file and extract subsequence This command is similar with \"samtools faidx\" but has some extra features: 1. output full header line with flag -f 2. support regular expression as sequence ID with flag -r 3. if you have large number of IDs, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt Usage: seqkit faidx [flags] <fasta-file> [regions...] Flags: -f, --full-head print full header line instead of just ID. New fasta index file ending with .seqkit.fai will be created -h, --help help for faidx -i, --ignore-case ignore case -r, --use-regexp IDs are regular expression. But subseq region is not suppored here. Example common usage like samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 >hsa-let-7a-1 UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU output full header, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 -f >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU extract subsequence of specific region $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1-10 >hsa-let-7a-1:1-10 UGGGAUGAGG $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:-10--1 >hsa-let-7a-1:-10--1 GUCUUUCCUA $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1 >hsa-let-7a-1:1-1 U use regular expression $ seqkit faidx tests/hairpin.fa hsa -r | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,881 154,002 41 81.9 180","title":"faidx"},{"location":"usage/#watch","text":"Usage monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Histogram of log sequence length seqkit watch -L -f ReadLen hairpin.fa Histogram of mean base qualities every 500 record, also saved as PDF seqkit watch -p 500 -O qhist.pdf -f MeanQual reads_1.fq.gz","title":"watch"},{"location":"usage/#sana","text":"Usage sanitize broken single line fastq files Usage: seqkit sana [flags] Flags: -h, --help help for sana -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq.gz -o rescued.fq.gz","title":"sana"},{"location":"usage/#fq2fa","text":"Usage convert FASTQ to FASTA Usage: seqkit fq2fa [flags] Examples seqkit fq2fa reads_1.fq.gz -o reads_1.fa.gz","title":"fq2fa"},{"location":"usage/#fx2tab-tab2fx","text":"Usage (fx2tab) convert FASTA/Q to tabular format, and provide various information, like sequence length, GC content/GC skew. Usage: seqkit fx2tab [flags] Flags: -a, --alphabet print alphabet letters -q, --avg-qual print average quality of a read -B, --base-content strings print base content. (case ignored, multiple values supported) e.g. -B AT -B N -I, --case-sensitive calculate case sensitive base content -g, --gc print GC content -G, --gc-skew print GC-Skew -H, --header-line print header line -h, --help help for fx2tab -l, --length print sequence length -n, --name only print names (no sequences and qualities) -i, --only-id print ID instead of full head -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Usage (tab2fx) convert tabular format (first two/three columns) to FASTA/Q format Usage: seqkit tab2fx [flags] Flags: -p, --comment-line-prefix value comment line prefix (default [#,//]) Examples Default output $ seqkit fx2tab hairpin.fa.gz | head -n 2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU Print sequence length, GC content, and only print names (no sequences), we could also print title line by flag -H . $ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '&' pretty #name seq qual length GC cel-let-7 99 43.43 cel-lin-4 94 54.26 cel-mir-1 96 40.62 Use fx2tab and tab2fx in pipe $ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx $ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx Sort sequences by length (use seqkit sort -l ) $ zcat hairpin.fa.gz \\ | seqkit fx2tab -l \\ | sort -t\"`echo -e '\\t'`\" -n -k4,4 \\ | seqkit tab2fx >cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop UUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC >mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop UGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU >cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop ACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU $ seqkit sort -l hairpin.fa.gz Sorting or filtering by GC (or other base by -flag -B ) content could also achieved in similar way. Get first 1000 sequences (use seqkit head -n 1000 ) $ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx $ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx Extension After converting FASTA to tabular format with seqkit fx2tab , it could be handled with CSV/TSV tools, e.g. csvtk , a cross-platform, efficient and practical CSV/TSV toolkit csvtk grep could be used to filter sequences (similar with seqkit grep ) csvtk inter computates intersection of multiple files. It could achieve similar function as seqkit common -n along with shell. csvtk join joins multiple CSV/TSV files by multiple IDs. csv_melt provides melt function, could be used in preparation of data for ploting.","title":"fx2tab &amp; tab2fx"},{"location":"usage/#convert","text":"Usage convert FASTQ quality encoding between Sanger, Solexa and Illumina Usage: seqkit convert [flags] Flags: -d, --dry-run dry run -f, --force for Illumina-1.8+ -> Sanger, truncate scores > 40 to 40 --from string source quality encoding. if not given, we'll guess it -h, --help help for convert -n, --nrecords int number of records for guessing quality encoding (default 1000) -N, --thresh-B-in-n-most-common int threshold of 'B' in top N most common quality for guessing Illumina 1.5. (default 4) -F, --thresh-illumina1.5-frac float threshold of faction of Illumina 1.5 in the leading N records (default 0.1) --to string target quality encoding (default \"Sanger\") Examples: Note that seqkit convert always output sequences. The test dataset contains score 41 ( J ): $ seqkit head -n 1 tests/Illimina1.8.fq.gz @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< By default, nothing changes when converting Illumina 1.8 to Sanger. A warning message show that source and target quality encoding match. $ seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger [WARN] source and target quality encoding match. @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< When switching flag --force on, J (41) was converted to I (40). $ seqkit convert tests/Illimina1.8.fq.gz -f | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAIFFFIII<IIIIIFFFIFIIIIIFIIAIIIFIIFIFIIIIFAFI<IA<FFI7FIIFIIAAIIII<IIIIIIIFIIIAIIIIIFII77<IIII-F7A-FIFFIIIIII<FFI-<7FIIIFII)A7)7AA<7--)<-7F-A7FA< Other cases: To Illumina-1.5. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iiiiieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[ To Illumina-1.5 and back to Sanger. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit convert | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + !AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< Checking encoding $ seqkit convert tests/Illimina1.8.fq.gz --from Solexa [INFO] converting Solexa -> Sanger [ERRO] seq: invalid Solexa quality Real Illumina 1.5+ data $ seqkit seq tests/Illimina1.5.fq @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + efcfffffcfeefffcffffffddf`feed]`]_Ba_^__[YBBBBBBBBBBRTT\\]][]dddd`ddd^dddadd^BBBBBBBBBBBBBBBBBBBBBBBB $ seqkit convert tests/Illimina1.5.fq | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + FGDGGGGGDGFFGGGDGGGGGGEEGAGFFE>A>@!B@?@@<:!!!!!!!!!!355=>><>EEEEAEEE?EEEBEE?!!!!!!!!!!!!!!!!!!!!!!!!","title":"convert"},{"location":"usage/#translate","text":"Usage translate DNA/RNA to protein sequence (supporting ambiguous bases) Note: 1. this command supports codons containing any ambiguous base. Plese switch on flag -L for details. e.g., for standard table: ACN -> T CCN -> P CGN -> R CTN -> L GCN -> A GGN -> G GTN -> V TCN -> S MGR -> R YTR -> L Translate Tables/Genetic Codes: # https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes 1: The Standard Code 2: The Vertebrate Mitochondrial Code 3: The Yeast Mitochondrial Code 4: The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code 5: The Invertebrate Mitochondrial Code 6: The Ciliate, Dasycladacean and Hexamita Nuclear Code 9: The Echinoderm and Flatworm Mitochondrial Code 10: The Euplotid Nuclear Code 11: The Bacterial, Archaeal and Plant Plastid Code 12: The Alternative Yeast Nuclear Code 13: The Ascidian Mitochondrial Code 14: The Alternative Flatworm Mitochondrial Code 16: Chlorophycean Mitochondrial Code 21: Trematode Mitochondrial Code 22: Scenedesmus obliquus Mitochondrial Code 23: Thraustochytrium Mitochondrial Code 24: Pterobranchia Mitochondrial Code 25: Candidate Division SR1 and Gracilibacteria Code 26: Pachysolen tannophilus Nuclear Code 27: Karyorelict Nuclear 28: Condylostoma Nuclear 29: Mesodinium Nuclear 30: Peritrich Nuclear 31: Blastocrithidia Nuclear Usage: seqkit translate [flags] Flags: -x, --allow-unknown-codon translate unknown code to 'X'. And you may not use flag --trim which removes 'X' --clean change all STOP codon positions from the '*' character to 'X' (an unknown residue) -f, --frame strings frame(s) to translate, available value: 1, 2, 3, -1, -2, -3, and 6 for all six frames (default [1]) -h, --help help for translate -M, --init-codon-as-M translate initial codon at beginning to 'M' -l, --list-transl-table int show details of translate table N, 0 for all (default -1) -L, --list-transl-table-with-amb-codons int show details of translate table N (including ambigugous codons), 0 for all. (default -1) -T, --transl-table int translate table/genetic code, type 'seqkit translate --help' for more details (default 1) --trim remove all 'X' and '*' characters from the right end of the translation Examples common usage $ seqkit translate tests/mouse-p53-cds.fna >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD* trim the * $ seqkit translate tests/mouse-p53-cds.fna --trim >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD different translate table $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --trim >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF different frame $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] SESNFSE*ITNNSYGKSKHKAPSPLIISFHFFYKFRI*LSY*ERSFCFISNCFIVI*LCF NSS*TFEDFSPCLFLH $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit seq -r -p \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF* show details of translate table 1 $ seqkit translate -l 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAT: N ACA: T, ACC: T, ACG: T, ACT: T AGA: R, AGC: S, AGG: R, AGT: S ATA: I, ATC: I, ATG: M, ATT: I CAA: Q, CAC: H, CAG: Q, CAT: H CCA: P, CCC: P, CCG: P, CCT: P CGA: R, CGC: R, CGG: R, CGT: R CTA: L, CTC: L, CTG: L, CTT: L GAA: E, GAC: D, GAG: E, GAT: D GCA: A, GCC: A, GCG: A, GCT: A GGA: G, GGC: G, GGG: G, GGT: G GTA: V, GTC: V, GTG: V, GTT: V TAA: *, TAC: Y, TAG: *, TAT: Y TCA: S, TCC: S, TCG: S, TCT: S TGA: *, TGC: C, TGG: W, TGT: C TTA: L, TTC: F, TTG: L, TTT: F show details of translate table 1, including ambigugous codons $ seqkit translate -L 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAR: K, AAT: N, AAY: N ACA: T, ACC: T, ACM: T, ACG: T, ACR: T, ACS: T, ACV: T, ACT: T, ACW: T, ACY: T, ACH: T, ACK: T, ACD: T, ACB: T, ACN: T AGA: R, AGC: S, AGG: R, AGR: R, AGT: S, AGY: S ATA: I, ATC: I, ATM: I, ATG: M, ATT: I, ATW: I, ATY: I, ATH: I CAA: Q, CAC: H, CAG: Q, CAR: Q, CAT: H, CAY: H CCA: P, CCC: P, CCM: P, CCG: P, CCR: P, CCS: P, CCV: P, CCT: P, CCW: P, CCY: P, CCH: P, CCK: P, CCD: P, CCB: P, CCN: P CGA: R, CGC: R, CGM: R, CGG: R, CGR: R, CGS: R, CGV: R, CGT: R, CGW: R, CGY: R, CGH: R, CGK: R, CGD: R, CGB: R, CGN: R CTA: L, CTC: L, CTM: L, CTG: L, CTR: L, CTS: L, CTV: L, CTT: L, CTW: L, CTY: L, CTH: L, CTK: L, CTD: L, CTB: L, CTN: L MGA: R, MGG: R, MGR: R GAA: E, GAC: D, GAG: E, GAR: E, GAT: D, GAY: D GCA: A, GCC: A, GCM: A, GCG: A, GCR: A, GCS: A, GCV: A, GCT: A, GCW: A, GCY: A, GCH: A, GCK: A, GCD: A, GCB: A, GCN: A GGA: G, GGC: G, GGM: G, GGG: G, GGR: G, GGS: G, GGV: G, GGT: G, GGW: G, GGY: G, GGH: G, GGK: G, GGD: G, GGB: G, GGN: G GTA: V, GTC: V, GTM: V, GTG: V, GTR: V, GTS: V, GTV: V, GTT: V, GTW: V, GTY: V, GTH: V, GTK: V, GTD: V, GTB: V, GTN: V TAA: *, TAC: Y, TAG: *, TAR: *, TAT: Y, TAY: Y TCA: S, TCC: S, TCM: S, TCG: S, TCR: S, TCS: S, TCV: S, TCT: S, TCW: S, TCY: S, TCH: S, TCK: S, TCD: S, TCB: S, TCN: S TGA: *, TGC: C, TGG: W, TGT: C, TGY: C TRA: * TTA: L, TTC: F, TTG: L, TTR: L, TTT: F, TTY: F YTA: L, YTG: L, YTR: L","title":"translate"},{"location":"usage/#grep","text":"Usage search sequences by ID/name/sequence/sequence motifs, mismatch allowed Attentions: 1. Unlike POSIX/GNU grep, we compare the pattern to the whole target (ID/full header) by default. Please switch \"-r/--use-regexp\" on for partly matching. 2. While when searching by sequences, only positive strand is searched, and it's partly matching. Mismatch is allowed using flag \"-m/--max-mismatch\", but it's not fast enough for large genome like human genome. Though, it's fast enough for microbial genomes. 3. The order of sequences in result is consistent with that in original file, not the order of the query patterns. But for FASTA file, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt You can specify the sequence region for searching with flag -R (--region). The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit grep [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq search subseq on seq, only positive strand is searched, and mismatch allowed using flag -m/--max-mismatch -d, --degenerate pattern/motif contains degenerate base --delete-matched delete a pattern right after being matched, this keeps the firstly matched data and speedups when using regular expressions -h, --help help for grep -i, --ignore-case ignore case -v, --invert-match invert the sense of matching, to select non-matching records -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -p, --pattern strings search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string pattern file (one record per line) -R, --region string specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases -r, --use-regexp patterns are regular expression Examples Extract human hairpins (i.e. sequences with name starting with hsa ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU Remove human and mice hairpins. $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v Extract new entries by information from miRNA.diff.gz Get IDs of new entries. $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 > list $ more list cfa-mir-486 cfa-mir-339-1 pmi-let-7 Extract by ID list file $ zcat hairpin.fa.gz | seqkit grep -f list > new.fa Extract sequences containing AGGCG $ cat hairpin.fa.gz | seqkit grep -s -i -p aggcg Extract sequences containing AGGCG (allow mismatch) $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,181 145,789 49 123.4 2,354 real 0m0.058s user 0m0.100s sys 0m0.017s $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg -m 1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 17,168 1,881,005 39 109.6 2,354 real 0m0.864s user 0m0.941s sys 0m0.014s Extract sequences starting with AGGCG $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G. $ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA It's equal to but simpler than: $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA Specify sequence regions for searching. e.g., leading 30 bases. $ seqkit grep -s -R 1:30 -i -r -p GCTGG","title":"grep"},{"location":"usage/#locate","text":"Usage locate subsequences/motifs, mismatch allowed Motifs could be EITHER plain sequence containing \"ACTGN\" OR regular expression like \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" for ORFs. Degenerate bases like \"RYMM..\" are also supported by flag -d. By default, motifs are treated as regular expression. When flag -d given, regular expression may be wrong. For example: \"\\w\" will be wrongly converted to \"\\[AT]\". Mismatch is allowed using flag \"-m/--max-mismatch\", but it's not fast enough for large genome like human genome. Though, it's fast enough for microbial genomes. Usage: seqkit locate [flags] Flags: --bed output in BED6 format -d, --degenerate pattern/motif contains degenerate base --gtf output in GTF format -h, --help help for locate -M, --hide-matched do not show matched sequences -i, --ignore-case ignore case -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -G, --non-greedy non-greedy mode, faster but may miss motifs overlapping with others -P, --only-positive-strand only search on positive strand -p, --pattern strings pattern/motif (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern/motif file (FASTA format) -F, --use-fmi use FM-index for much faster search of lots of sequence patterns -r, --use-regexp patterns/motifs are regular expression -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Locating subsequences (mismatch allowed) $ cat t.fa >seq agctggagctacc $ cat t.fa \\ | seqkit locate -p agc \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # do not show matched sequences $ cat t.fa \\ | seqkit locate -p agc -M \\ | csvtk pretty -t seqID patternName pattern strand start end seq agc agc + 1 3 seq agc agc + 7 9 seq agc agc - 8 10 seq agc agc - 2 4 # max mismatch: 1 $ cat t.fa \\ | seqkit locate -p agc -m 1 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc + 11 13 acc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # max mismatch: 2 $ cat t.fa \\ | seqkit locate -p agc -m 2 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 4 6 tgg seq agc agc + 5 7 gga seq agc agc + 7 9 agc seq agc agc + 10 12 tac seq agc agc + 11 13 acc seq agc agc - 11 13 ggt seq agc agc - 8 10 agc seq agc agc - 6 8 ctc seq agc agc - 5 7 tcc seq agc agc - 2 4 agc Locate ORFs. $ zcat hairpin.fa.gz \\ | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" -r \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-lin-4 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 1 36 AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 54 95 AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 43 51 AUGAUAUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 30 41 AUGGGCAUGUAA Locate Motif. $ zcat hairpin.fa.gz \\ | seqkit locate -i -d -p AUGGACUN \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-mir-58a AUGGACUN AUGGACUN + 81 88 AUGGACUG ath-MIR163 AUGGACUN AUGGACUN - 122 129 AUGGACUC cel-mir-270 AUGGACUN AUGGACUN + 84 91 AUGGACUG Notice that seqkit grep only searches in positive strand, but seqkit loate could recognize both strand. Output in GTF or BED6 format, which you can use in seqkit subseq $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --bed cel-mir-58a 80 88 AUGGACUN 0 + ath-MIR163 121 129 AUGGACUN 0 - $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --gtf cel-mir-58a SeqKit location 81 88 0 + . gene_id \"AUGGACUN\"; ath-MIR163 SeqKit location 122 129 0 - . gene_id \"AUGGACUN\"; greedy mode (default) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 4 7 ACGA seq ACGA ACGA + 7 10 ACGA non-greedy mode ( -G ) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA","title":"locate"},{"location":"usage/#fish","text":"Usage look for short sequences in larger sequences using local alignment Attention: 1. output coordinates are BED-like 0-based, left-close and right-open. 2. alignment information are printed to STDERR. Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular $ seqkit fish -q 4.7 -F GGCGGCTGTGACC -g mouse-p53-cds.fna Compare to seqkit locate : $ echo -e '>seq\\nACGACGACGA' \\ | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA $ echo -e '>seq\\nACGACGACGA' \\ | seqkit fish -F ACGA -a 2>&1 | csvtk -t pretty Ref RefStart RefEnd Query QueryStart QueryEnd Strand MapQual RawScore Acc ClipAcc QueryCov seq 6 10 q0 0 4 + 60.00 16 100.00 100.00 100.00 seq 0 4 q0 0 4 + 60.00 16 100.00 100.00 100.00 Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna","title":"fish"},{"location":"usage/#amplicon","text":"Usage retrieve amplicon (or specific region around it) via primer(s). Examples: 0. no region given. F -----===============----- F R -----=====-----=====----- =============== amplicon 1. inner region (-r x:y). F -----===============----- 1 3 5 x/y -5-3-1 x/y F R -----=====-----=====----- x:y =============== 1:-1 ======= 1:7 ===== 3:7 ===== 6:10 ===== -10:-6 ===== -7:-3 -x:y (invalid) 2. flanking region (-r x:y -f) F -----===============----- -3-1 x/y 1 3 5 x/y F R -----=====-----=====----- ===== -5:-1 === -5:-3 ===== 1:5 === 3:5 ================= -1:1 ========================= -5:5 x:-y (invalid) Usage: seqkit amplicon [flags] Flags: -f, --flanking-region region is flanking region -F, --forward string forward primer -h, --help help for amplicon -m, --max-mismatch int max mismatch when matching primers -r, --region string specify region to return. type \"seqkit amplicon -h\" for detail -R, --reverse string reverse primer -s, --strict strict mode, i.e., discarding seqs not fully matching (shorter) given region range Examples No region given. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" >seq acgcccactgaaatga $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt >seq cccactgaaa Inner region # region right behind forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 >seq actg # more common case is triming primers $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:-4 >seq actg flanking region # in one of my sequencing data, I only care about # region downstream of forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 >seq tgaa # if given region if out scope of sequence. e.g, # 2-5bp downstream of aaa, we can get part of region (2-4) by default $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 >seq ga # you can also use strict mode to discard those cases $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 -s","title":"amplicon"},{"location":"usage/#duplicate","text":"Usage duplicate sequences N times You may need \"seqkit rename\" to make the the sequence IDs unique. Usage: seqkit duplicate [flags] Aliases: duplicate, dup Flags: -h, --help help for duplicate -n, --times int duplication number (default 1) Examples Data $ cat tests/hairpin.fa | seqkit head -n 1 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA Duplicate 2 times $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA use seqkit rename to make the the sequence IDs unique. $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 | seqkit rename >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7_2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA","title":"duplicate"},{"location":"usage/#rmdup","text":"Usage remove duplicated sequences by id/name/sequence Usage: seqkit rmdup [flags] Flags: -n, --by-name by full name instead of just id -s, --by-seq by seq -D, --dup-num-file string file to save number and list of duplicated seqs -d, --dup-seqs-file string file to save duplicated seqs -h, --help help for rmdup -i, --ignore-case ignore case Examples Similar to common . General use $ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 2226 duplicated records removed $ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 1086 duplicated records removed Save duplicated sequences to file $ zcat hairpin.fa.gz \\ | seqkit rmdup -s -i -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ cat duplicated.detail.txt # here is not the entire list 3 hsa-mir-424, mml-mir-424, ppy-mir-424 3 hsa-mir-342, mml-mir-342, ppy-mir-342 2 ngi-mir-932, nlo-mir-932 2 ssc-mir-9784-1, ssc-mir-9784-2","title":"rmdup"},{"location":"usage/#common","text":"Usage find common sequences of multiple files by id/name/sequence Note: 1. 'seqkit common' is designed to support 2 and MORE files. 2. For 2 files, 'seqkit grep' is much faster and consumes lesser memory: seqkit grep -f <(seqkit seq -n -i small.fq.gz) big.fq.gz # by seq ID seqkit grep -s -f <(seqkit seq -s small.fq.gz) big.fq.gz # by seq 3. Some records in one file may have same sequences/IDs. They will ALL be retrieved if the sequence/ID was shared in multiple files. So the records number may be larger than that of the smallest file. Usage: seqkit common [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq match by sequence -h, --help help for common -i, --ignore-case ignore case Examples By ID (default) seqkit common file*.fa -o common.fasta By full name seqkit common file*.fa -n -o common.fasta By sequence seqkit common file*.fa -s -i -o common.fasta","title":"common"},{"location":"usage/#split","text":"Usage split sequences into files by name ID, subsequence of given region, part size or number of parts. Please use \"seqkit split2\" for paired- and single-end FASTQ. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit split [flags] Flags: -i, --by-id split squences according to sequence ID -p, --by-part int split sequences into N parts -r, --by-region string split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \"seqkit split -h\" for more examples -s, --by-size int split sequences into multi parts with N sequences -d, --dry-run dry run, just print message and no files will be created. -f, --force overwrite output directory -h, --help help for split -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -O, --out-dir string output directory (default value is $infile.split) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples Split sequences into parts with at most 10000 sequences $ seqkit split hairpin.fa.gz -s 10000 [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.part_001.gz [INFO] write 7162 sequences to file: hairpin.fa.part_002.gz [INFO] write 7162 sequences to file: hairpin.fa.part_003.gz [INFO] write 7159 sequences to file: hairpin.fa.part_004.gz To reduce memory usage when spliting big file, we should alwasy use flag --two-pass $ seqkit split hairpin.fa.gz -p 4 -2 [INFO] split into 4 parts [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 28645 sequences loaded [INFO] write 7162 sequences to file: hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.part_004.fa.gz Split sequences by species. i.e. by custom IDs (first three letters) $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2 [INFO] split by ID. idRegexp: ^([\\w]+)\\- [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] create and read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fa [INFO] read sequence IDs from FASTA index ... [INFO] 28645 sequences loaded [INFO] write 48 sequences to file: hairpin.id_cca.fa.gz [INFO] write 3 sequences to file: hairpin.id_hci.fa.gz [INFO] write 106 sequences to file: hairpin.id_str.fa.gz [INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz ... Split sequences by sequence region (for example, sequence barcode) $ seqkit split hairpin.fa.gz -r 1:3 -2 [INFO] split by region: 1:3 [INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ... [INFO] read sequence IDs and sequence region from FASTA file ... [INFO] create and read FASTA index ... [INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz [INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz [INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz Sequence suffix could be defined as -r -12:-1","title":"split"},{"location":"usage/#split2","text":"Usage split sequences into files by part size or number of parts This command supports FASTA and paired- or single-end FASTQ with low memory occupation and fast speed. The file extensions of output are automatically detected and created according to the input files. Usage: seqkit split2 [flags] Flags: -l, --by-length string split sequences into chunks of N bases, supports K/M/G suffix -p, --by-part int split sequences into N parts -s, --by-size int split sequences into multi parts with N sequences -f, --force overwrite output directory -h, --help help for split2 -O, --out-dir string output directory (default value is $infile.split) -1, --read1 string read1 file -2, --read2 string read2 file Examples Split sequences into parts with at most 10000 sequences $ seqkit split2 hairpin.fa.gz -s 10000 -f [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 -f [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.fa.gz.split/hairpin.part_004.fa.gz For FASTQ files (paired-end) $ seqkit split2 -1 reads_1.fq.gz -2 reads_2.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz and reads_2.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_2.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_2.part_002.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz For FASTA files (single-end) $ seqkit split2 -1 reads_1.fq.gz reads_2.fq.gz -p 2 -O out -f [INFO] flag -1/--read1 given, ignore: reads_2.fq.gz [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz $ seqkit split2 reads_1.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz","title":"split2"},{"location":"usage/#sample","text":"Usage sample sequences by number or proportion. Usage: seqkit sample [flags] Flags: -n, --number int sample by number (result may not exactly match) -p, --proportion float sample by proportion -s, --rand-seed int rand seed (default 11) -2, --two-pass 2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin Examples Sample by proportion $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz [INFO] sample by proportion [INFO] 2814 sequences outputed Sample by number $ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz [INFO] sample by number [INFO] 949 sequences outputed 949 != 1000 ??? see Effect of random seed on results of seqkit sample To reduce memory usage when spliting big file, we could use flag --two-pass We can also use seqkit sample -p followed with seqkit head -n : $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit head -n 1000 -o sample.fa.gz Set rand seed to reproduce the result $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 -s 11 Most of the time, we could shuffle after sampling $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit shuffle -o sample.fa.gz Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed )","title":"sample"},{"location":"usage/#head","text":"Usage print first N FASTA/Q records Usage: seqkit head [flags] Flags: -n, --number int print first N FASTA/Q records (default 10) Examples FASTA $ seqkit head -n 1 hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA FASTQ $ seqkit head -n 1 reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII","title":"head"},{"location":"usage/#range","text":"Usage print FASTA/Q records in a range (start:end) Usage: seqkit range [flags] Flags: -h, --help help for range -r, --range string range. e.g., 1:12 for first 12 records (head -n 12), -12:-1 for last 12 records (tail -n 12) Examples leading N records (head) $ cat tests/hairpin.fa | seqkit head -n 100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - $ cat tests/hairpin.fa | seqkit range -r 1:100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - last N records (tail) $ cat tests/hairpin.fa | seqkit range -r -100:-1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 100 8,656 58 86.6 172 Other ranges $ cat tests/hairpin.fa | seqkit range -r 101:150 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 50 3,777 63 75.5 96 $ cat tests/hairpin.fa | seqkit range -r -100:-2 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 99 8,484 58 85.7 146","title":"range"},{"location":"usage/#replace","text":"Usage replace name/sequence by regular expression. Note that the replacement supports capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: use SINGLE quote NOT double quotes in *nix OS. Examples: Adding space to all bases. seqkit replace -p \"(.)\" -r '$1 ' -s Or use the \\ escape character. seqkit replace -p \"(.)\" -r \"\\$1 \" -s more on: http://bioinf.shenwei.me/seqkit/usage/#replace Special replacement symbols (only for replacing name not sequence): {nr} Record number, starting from 1 {kv} Corresponding value of the key (captured variable $n) by key-value file, n can be specified by flag -I (--key-capt-idx) (default: 1) Usage: seqkit replace [flags] Flags: -s, --by-seq replace seq -h, --help help for replace -i, --ignore-case ignore case -K, --keep-key keep the key as value when no value found for the key (only for sequence name) -I, --key-capt-idx int capture variable index of key (1-based) (default 1) -m, --key-miss-repl string replacement for key with no corresponding value -k, --kv-file string tab-delimited key-value file for replacing key with value when using \"{kv}\" in -r (--replacement) (only for sequence name) --nr-width int minimum width for {nr} in flag -r/--replacement. e.g., formating \"1\" to \"001\" by --nr-width 3 (default 1) -p, --pattern string search regular expression -r, --replacement string replacement. supporting capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by \"{nr}\".use ${1} instead of $1 when {kv} given! Examples Remove descriptions $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\s.+\" >seq1 ACGT-ACGT Replace \"-\" with \"=\" $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\-\" -r '=' >seq1 abc=123 ACGT-ACGT Remove gaps in sequences. $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \" |-\" -s >seq1 abc-123 ACGTACGT Add space to every base. ATTENTION: use SINGLE quote NOT double quotes in *nix OS $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r '$1 ' -s >seq1 abc-123 A C G T - A C G T Transpose sequence with csvtk $ echo -e \">seq1\\nACTGACGT\\n>seq2\\nactgccgt\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s \\ | seqkit seq -s -u \\ | csvtk space2tab \\ | csvtk -t transpose A A C C T T G G A C C C G G T T Rename with number of record $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" >seq_1 ACTG >seq_2 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" --nr-width 5 >seq_00001 ACTG >seq_00002 ATTT Replace key with value by key-value file $ more test.fa >seq1 name1 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 name3 CCCCAAAACCCCATGTTGCTACTAG $ more alias.txt name0 ABC name1 123 name3 Hello name4 World $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG convert fasta to genbank style $ cat seq.fa >seq1 TTTAAAGAGACCGGCGATTCTAGTGAAATCGAACGGGCAGGTCAATTTCCAACCAGCGAT GACGTAATAGATAGATACAAGGAAGTCATTTTTCTTTTAAAGGATAGAAACGGTTAATGC TCTTGGGACGGCGCTTTTCTGTGCATAACT >seq2 AAGGATAGAAACGGTTAATGCTCTTGGGACGGCGCTTTTCTGTGCATAACTCGATGAAGC CCAGCAATTGCGTGTTTCTCCGGCAGGCAAAAGGTTGTCGAGAACCGGTGTCGAGGCTGT TTCCTTCCTGAGCGAAGCCTGGGGATGAACG $ cat seq.fa \\ | seqkit replace -s -p '(\\w{10})' -r '$1 ' -w 66 \\ | perl -ne 'if (/^>/) {print; $n=1} \\ else {s/ \\r?\\n$/\\n/; printf \"%9d %s\", $n, $_; $n+=60;}' >seq1 1 TTTAAAGAGA CCGGCGATTC TAGTGAAATC GAACGGGCAG GTCAATTTCC AACCAGCGAT 61 GACGTAATAG ATAGATACAA GGAAGTCATT TTTCTTTTAA AGGATAGAAA CGGTTAATGC 121 TCTTGGGACG GCGCTTTTCT GTGCATAACT >seq2 1 AAGGATAGAA ACGGTTAATG CTCTTGGGAC GGCGCTTTTC TGTGCATAAC TCGATGAAGC 61 CCAGCAATTG CGTGTTTCTC CGGCAGGCAA AAGGTTGTCG AGAACCGGTG TCGAGGCTGT 121 TTCCTTCCTG AGCGAAGCCT GGGGATGAAC G","title":"replace"},{"location":"usage/#rename","text":"Usage rename duplicated IDs Usage: seqkit rename [flags] Flags: -n, --by-name check duplication by full name instead of just id -f, --force overwrite output directory -h, --help help for rename -m, --multiple-outfiles write results into separated files for multiple input files -O, --out-dir string output directory (default \"renamed\") Examples $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" >a comment acgt >b comment of b ACTG >a comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename >a comment acgt >b comment of b ACTG >a_2 a comment aaaa","title":"rename"},{"location":"usage/#restart","text":"Usage reset start position for circular genome Examples $ echo -e \">seq\\nacgtnACGTN\" >seq acgtnACGTN $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i 2 >seq cgtnACGTNa $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i -2 >seq TNacgtnACG Usage: seqkit restart [flags] Flags: -i, --new-start int new start position (1-base, supporting negative value counting from the end) (default 1)","title":"restart"},{"location":"usage/#concat","text":"Usage concatenate sequences with same ID from multiple files Example: concatenating leading 2 bases and last 2 bases $ cat t.fa >test ACCTGATGT >test2 TGATAGCTACTAGGGTGTCTATCG $ seqkit concat <(seqkit subseq -r 1:2 t.fa) <(seqkit subseq -r -2:-1 t.fa) >test ACGT >test2 TGCG Usage: seqkit concat [flags] Flags: -h, --help help for concat","title":"concat"},{"location":"usage/#mutate","text":"Usage edit sequence (point mutation, insertion, deletion) Attentions: 1. Mutiple point mutations (-p/--point) are allowed, but only single insertion (-i/--insertion) OR single deletion (-d/--deletion) is allowed. 2. Point mutation takes place before insertion/deletion. Notes: 1. You can choose certain sequences to edit using similar flags in 'seqkit grep'. The definition of position is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit mutate [flags] Flags: -n, --by-name [match seqs to mutate] match by full name instead of just id -d, --deletion string deletion mutation: deleting subsequence in a range. e.g., -d 1:2 for deleting leading two bases, -d -3:-1 for removing last 3 bases -h, --help help for mutate -I, --ignore-case [match seqs to mutate] ignore case of search pattern -i, --insertion string insertion mutation: inserting bases behind of given position, e.g., -i 0:ACGT for inserting ACGT at the beginning, -1:* for add * to the end -v, --invert-match [match seqs to mutate] invert the sense of matching, to select non-matching records --pattern strings [match seqs to mutate] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string [match seqs to mutate] pattern file (one record per line) -p, --point strings point mutation: changing base at given postion. e.g., -p 2:C for setting 2nd base as C, -p -1:A for change last base as A -r, --use-regexp [match seqs to mutate] search patterns are regular expression Examples: Point mutation: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" >1 ACTGNactgn >2 actgnACTGN # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x [INFO] edit seq: 1 [INFO] edit seq: 2 >1 xCTGNactgn >2 xctgnACTGN # 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 5:x --quiet >1 ACTGxactgn >2 actgxACTGN # last base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p -1:x --quiet >1 ACTGNactgx >2 actgnACTGx # mutiple locations: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x -p -1:x --quiet >1 xCTGNactgx >2 xctgnACTGx Deletion # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d 1:1 --quiet >1 CTGNactgn >2 ctgnACTGN # last 3 bases $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d -3:-1 --quiet >1 ACTGNac >2 actgnAC Insertion: inserting bases behind of given position # at the beginning $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 0:xx --quiet >1 xxACTGNactgn >2 xxactgnACTGN # at the end $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i -1:xx --quiet >1 ACTGNactgnxx >2 actgnACTGNxx # behind of 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 5:x --quiet >1 ACTGNxactgn >2 actgnxACTGN Choosing which sequences to edit , using similar flags in seqkit grep . $ cat tests/hsa.fa >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # only edit chr1 and chr2 # or cat tests/hsa.fa | seqkit mutate -p -1:X -s chr1 -s chr2 $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1,chr2 [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # using regular expression to match. # e,g., editing all chrosomes: $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -r -s chr [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq [INFO] edit seq: chr11 11th seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgn # excluding seqs $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1 -s chr2 -v [INFO] edit seq: chr11 11th seq [INFO] edit seq: MT mitochondrial seq >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgX","title":"mutate"},{"location":"usage/#shuffle","text":"Usage shuffle sequences. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence IDs. If the file is not plain FASTA file, seqkit will write the sequences to tempory files, and create FASTA index. Secondly, seqkit shuffles sequence IDs and extract sequences by FASTA index. Usage: seqkit shuffle [flags] Flags: -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -s, --rand-seed int rand seed for shuffle (default 23) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples General use. $ seqkit shuffle hairpin.fa.gz > shuffled.fa [INFO] read sequences ... [INFO] 28645 sequences loaded [INFO] shuffle ... [INFO] output ... For big genome, you'd better use two-pass mode so seqkit could use FASTA index to reduce memory usage $ time seqkit shuffle -2 hsa.fa > shuffle.fa [INFO] create and read FASTA index ... [INFO] create FASTA index for hsa.fa [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... real 0m35.080s user 0m45.521s sys 0m3.411s Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) for read 1 and 2 files.","title":"shuffle"},{"location":"usage/#sort","text":"Usage sort sequences by id/name/sequence/length. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence head and length information. If the file is not plain FASTA file, seqkit will write the sequences to tempory files, and create FASTA index. Secondly, seqkit sorts sequence by head and length information and extracts sequences by FASTA index. Usage: seqkit sort [flags] Flags: -l, --by-length by sequence length -n, --by-name by full name instead of just id -s, --by-seq by sequence -i, --ignore-case ignore case -k, --keep-temp keep tempory FASTA and .fai file when using 2-pass mode -N, --natural-order sort in natural order, when sorting by IDs/full name -r, --reverse reverse the result -L, --seq-prefix-length int length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) Examples For FASTA format, use flag -2 (--two-pass) to reduce memory usage sort by ID $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by ID and in natural order $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit seq -n -i 3 1 Y x Mt 11 2 $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit sort -N -i -2 \\ | seqkit seq -n -i 1 2 3 11 Mt x Y sort by ID, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -i >seq1 ACGTNcccc >SEQ2 acgtnAAAA sort by seq, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -s -i >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by sequence length $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAAnnn\\n>seq3\\nacgt\" \\ | seqkit sort --quiet -l >seq3 acgt >seq1 ACGTNcccc >SEQ2 acgtnAAAAnnn","title":"sort"},{"location":"usage/#bam","text":"monitoring and online histograms of BAM record features Usage: seqkit bam [flags] Flags: -B, --bins int number of histogram bins (default -1) -c, --count string count reads per reference and save to this file -W, --delay int sleep this many seconds after plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -e, --exec-after string execute command after reporting -E, --exec-before string execute command before reporting -f, --field string target fields -h, --help help for bam -C, --idx-count fast read per reference counting based on the BAM index -i, --idx-stat fast statistics based on the BAM index -O, --img string save histogram to this PDF/image file -H, --list-fields list all available BAM record features -L, --log log10(x+1) transform numeric values -q, --map-qual int minimum mapping quality -x, --pass passthrough mode (forward filtered BAM to output) -F, --prim-only filter out non-primary alignment records -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -Q, --quiet-mode supress all plotting to stderr -M, --range-max float discard record with field (-f) value greater than this flag (default NaN) -m, --range-min float discard record with field (-f) value less than this flag (default NaN) -R, --reset reset histogram after every report -s, --stat print BAM satistics of the input files -@, --top-bam string save the top -? records to this bam file -?, --top-size int size of the top-mode buffer (default 100) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Get detailed statistics from multiple BAM files. seqkit bam -s *.bam Get rough statistics from multiple indexed BAM files. seqkit bam -i *.bam Count reads mapped to references from a BAM stream. cat sample.bam | seqkit bam -c counts.tsv - Count reads mapped to references using the BAM index. seqkit bam -C sorted_indexed.bam Monitor alignment accuracy from a bam stream and report after every 1000 records, use 20 bins. cat sample.bam | seqkit bam -B -f Acc -p 1000 - Dump selected fields to TSV. seqkit bam -f Ref,Acc,RefCov,Strand sample.bam Save the best 100 records in terms of alignment accuracy to a BAM file. seqkit bam -f Acc -@ top_acc_100.bam -? 100 -Q sample.bam","title":"bam"},{"location":"usage/#fish_1","text":"look for short sequences in larger sequences using local alignment Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular seqkit fish -q 4.7 -F \"GGCGGCTGTGACC\" -g mouse-p53-cds.fna Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna","title":"fish"},{"location":"usage/#sana_1","text":"sanitize broken single line fastq files Usage: seqkit sana [flags] Flags: -h, --help help for sana -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq > rescued.fq","title":"sana"},{"location":"usage/#watch_1","text":"monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Global Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") -w, --line-width int line width when outputing FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2) Examples Histogram of log sequence length seqkit watch -L -f ReadLen hairpin.fa Histogram of mean base qualities every 500 record, also saved as PDF seqkit watch -p 500 -O qhist.pdf -f MeanQual reads_1.fq.gz","title":"watch"},{"location":"usage/#genautocomplete","text":"Usage generate shell autocompletion script Note: The current version supports Bash only. This should work for *nix systems with Bash installed. Howto: 1. run: seqkit genautocomplete 2. create and edit ~/.bash_completion file if you don't have it. nano ~/.bash_completion add the following: for bcfile in ~/.bash_completion.d/* ; do . $bcfile done Usage: seqkit genautocomplete [flags] Flags: --file string autocompletion file (default \"/home/shenwei/.bash_completion.d/seqkit.sh\") -h, --help help for genautocomplete --type string autocompletion type (currently only bash supported) (default \"bash\") /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"genautocomplete"},{"location":"yanlilab/","text":"","title":"Yanlilab"}]}