
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation">
      
      
        <meta name="author" content="Wei Shen">
      
      
      
        <link rel="prev" href="../download/">
      
      
        <link rel="next" href="../faq/">
      
      
      <link rel="icon" href="../files/favicon.ico">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.8">
    
    
      
        <title>Usage - SeqKit - Ultrafast FASTA/Q kit</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.4b4a2bd9.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="blue-grey">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#usage-and-examples" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="SeqKit - Ultrafast FASTA/Q kit" class="md-header__button md-logo" aria-label="SeqKit - Ultrafast FASTA/Q kit" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3 1 9l11 6 9-4.91V17h2V9M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            SeqKit - Ultrafast FASTA/Q kit
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Usage
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/shenwei356/seqkit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="SeqKit - Ultrafast FASTA/Q kit" class="md-nav__button md-logo" aria-label="SeqKit - Ultrafast FASTA/Q kit" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3 1 9l11 6 9-4.91V17h2V9M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82Z"/></svg>

    </a>
    SeqKit - Ultrafast FASTA/Q kit
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/shenwei356/seqkit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../download/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Download
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Usage
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Usage
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quick-guide" class="md-nav__link">
    Quick Guide
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#technical-details-and-guides-for-use" class="md-nav__link">
    Technical details and guides for use
  </a>
  
    <nav class="md-nav" aria-label="Technical details and guides for use">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fastaq-format-parsing-and-writing" class="md-nav__link">
    FASTA/Q format parsing and writing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#input-and-output-files" class="md-nav__link">
    Input and output files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-formats-and-types" class="md-nav__link">
    Sequence formats and types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-id" class="md-nav__link">
    Sequence ID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fasta-index" class="md-nav__link">
    FASTA index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parallelization-of-cpu-intensive-jobs" class="md-nav__link">
    Parallelization of CPU intensive jobs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memory-occupation" class="md-nav__link">
    Memory occupation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reproducibility" class="md-nav__link">
    Reproducibility
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seqkit" class="md-nav__link">
    seqkit
  </a>
  
    <nav class="md-nav" aria-label="seqkit">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#datasets" class="md-nav__link">
    Datasets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seq" class="md-nav__link">
    seq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#subseq" class="md-nav__link">
    subseq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sliding" class="md-nav__link">
    sliding
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stats" class="md-nav__link">
    stats
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sum" class="md-nav__link">
    sum
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#faidx" class="md-nav__link">
    faidx
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#watch" class="md-nav__link">
    watch
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sana" class="md-nav__link">
    sana
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scat" class="md-nav__link">
    scat
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fq2fa" class="md-nav__link">
    fq2fa
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fa2fq" class="md-nav__link">
    fa2fq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fx2tab-tab2fx" class="md-nav__link">
    fx2tab &amp; tab2fx
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convert" class="md-nav__link">
    convert
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#translate" class="md-nav__link">
    translate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grep" class="md-nav__link">
    grep
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#locate" class="md-nav__link">
    locate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fish" class="md-nav__link">
    fish
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#amplicon" class="md-nav__link">
    amplicon
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#duplicate" class="md-nav__link">
    duplicate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rmdup" class="md-nav__link">
    rmdup
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#common" class="md-nav__link">
    common
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split" class="md-nav__link">
    split
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split2" class="md-nav__link">
    split2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sample" class="md-nav__link">
    sample
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#head" class="md-nav__link">
    head
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#head-genome" class="md-nav__link">
    head-genome
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#range" class="md-nav__link">
    range
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#replace" class="md-nav__link">
    replace
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rename" class="md-nav__link">
    rename
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#restart" class="md-nav__link">
    restart
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#concat" class="md-nav__link">
    concat
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mutate" class="md-nav__link">
    mutate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shuffle" class="md-nav__link">
    shuffle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    sort
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bam" class="md-nav__link">
    bam
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-slides" class="md-nav__link">
    merge-slides
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#genautocomplete" class="md-nav__link">
    genautocomplete
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tutorial
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../benchmark/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Benchmark
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../note/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Notes
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/shenwei356" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    More tools
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quick-guide" class="md-nav__link">
    Quick Guide
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#technical-details-and-guides-for-use" class="md-nav__link">
    Technical details and guides for use
  </a>
  
    <nav class="md-nav" aria-label="Technical details and guides for use">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fastaq-format-parsing-and-writing" class="md-nav__link">
    FASTA/Q format parsing and writing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#input-and-output-files" class="md-nav__link">
    Input and output files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-formats-and-types" class="md-nav__link">
    Sequence formats and types
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequence-id" class="md-nav__link">
    Sequence ID
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fasta-index" class="md-nav__link">
    FASTA index
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parallelization-of-cpu-intensive-jobs" class="md-nav__link">
    Parallelization of CPU intensive jobs
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#memory-occupation" class="md-nav__link">
    Memory occupation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reproducibility" class="md-nav__link">
    Reproducibility
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seqkit" class="md-nav__link">
    seqkit
  </a>
  
    <nav class="md-nav" aria-label="seqkit">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#datasets" class="md-nav__link">
    Datasets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#seq" class="md-nav__link">
    seq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#subseq" class="md-nav__link">
    subseq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sliding" class="md-nav__link">
    sliding
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stats" class="md-nav__link">
    stats
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sum" class="md-nav__link">
    sum
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#faidx" class="md-nav__link">
    faidx
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#watch" class="md-nav__link">
    watch
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sana" class="md-nav__link">
    sana
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#scat" class="md-nav__link">
    scat
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fq2fa" class="md-nav__link">
    fq2fa
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fa2fq" class="md-nav__link">
    fa2fq
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fx2tab-tab2fx" class="md-nav__link">
    fx2tab &amp; tab2fx
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convert" class="md-nav__link">
    convert
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#translate" class="md-nav__link">
    translate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grep" class="md-nav__link">
    grep
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#locate" class="md-nav__link">
    locate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fish" class="md-nav__link">
    fish
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#amplicon" class="md-nav__link">
    amplicon
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#duplicate" class="md-nav__link">
    duplicate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rmdup" class="md-nav__link">
    rmdup
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#common" class="md-nav__link">
    common
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split" class="md-nav__link">
    split
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split2" class="md-nav__link">
    split2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pair" class="md-nav__link">
    pair
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sample" class="md-nav__link">
    sample
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#head" class="md-nav__link">
    head
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#head-genome" class="md-nav__link">
    head-genome
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#range" class="md-nav__link">
    range
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#replace" class="md-nav__link">
    replace
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rename" class="md-nav__link">
    rename
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#restart" class="md-nav__link">
    restart
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#concat" class="md-nav__link">
    concat
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mutate" class="md-nav__link">
    mutate
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shuffle" class="md-nav__link">
    shuffle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    sort
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bam" class="md-nav__link">
    bam
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-slides" class="md-nav__link">
    merge-slides
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#genautocomplete" class="md-nav__link">
    genautocomplete
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="usage-and-examples">Usage and Examples</h1>
<h2 id="quick-guide">Quick Guide</h2>
<ul>
<li>Basic: <a href="#seq">seq</a>, <a href="#stats">stats</a>, <a href="#subseq">subseq</a>, <a href="#sliding">sliding</a>,
  <a href="#faidx">faidx</a>, <a href="#translate">translate</a>, <a href="#watch">watch</a>, <a href="#sana">sana</a>, <a href="#scat">scat</a></li>
<li>Format conversion: <a href="#fq2fa">fq2fa</a>, <a href="#fa2fq">fa2fq</a>, <a href="#fx2tab-tab2fx">fx2tab</a>, <a href="#fx2tab-tab2fx">tab2fx</a>,
  <a href="#convert">convert</a></li>
<li>Searching: <a href="#grep">grep</a>, <a href="#locate">locate</a>, <a href="#amplicon">amplicon</a>, <a href="#fish">fish</a></li>
<li>Set operation: <a href="#sample">sample</a>, <a href="#rmdup">rmdup</a>, <a href="#common">common</a>,
  <a href="#duplicate">duplicate</a>, <a href="#split">split</a>, <a href="#split2">split2</a>, <a href="#head">head</a>,
  <a href="#head-genome">head-genome</a>, <a href="#range">range</a>, <a href="#pair">pair</a></li>
<li>Edit: <a href="#concat">concat</a>, <a href="#replace">replace</a>, <a href="#restart">restart</a>, <a href="#mutate">mutate</a>,
  <a href="#rename">rename</a></li>
<li>Ordering: <a href="#sort">sort</a>, <a href="#shuffle">shuffle</a></li>
<li>BAM processing: <a href="#bam">bam</a></li>
<li>Others: <a href="#sum">sum</a>, <a href="#merge-slides">merge-slides</a></li>
</ul>
<h2 id="technical-details-and-guides-for-use">Technical details and guides for use</h2>
<h3 id="fastaq-format-parsing-and-writing">FASTA/Q format parsing and writing</h3>
<blockquote>
<p><strong>Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0</strong>.
<strong>Bzip2 format is supported since v2.4.0</strong>.</p>
</blockquote>
<p>SeqKit uses the author's lightweight and high-performance bioinformatics package
<a href="https://github.com/shenwei356/bio">bio</a> for FASTA/Q parsing,
which has <a href="https://github.com/shenwei356/bio#fastaq-parsing">high performance</a>
close to the
famous C lib <a href="https://github.com/attractivechaos/klib/">klib</a> (<a href="https://github.com/attractivechaos/klib/blob/master/kseq.h">kseq.h</a>).</p>
<p><img src="https://github.com/shenwei356/bio/raw/master/benchmark/fastx/benchmark.tsv.png" alt="" width="700" align="center" /></p>
<p>Notes:</p>
<ul>
<li><code>seqkit</code> uses 4 threads by default.</li>
<li><code>seqkit_t1</code> uses 1 thread.</li>
<li><code>seqtk</code> is single-threaded.</li>
<li><code>seqtk+gzip</code>: <code>seqtk</code> pipes data to the single-threaded <code>gzip</code>.</li>
<li><code>seqtk+pigz</code>: <code>seqtk</code> pipes data to the multithreaded <code>pigz</code> which uses 4 threads here.</li>
</ul>
<h3 id="input-and-output-files">Input and output files</h3>
<p>Seqkit accepts input data from standard input (STDIN) and plain or gzip-compressed files.
Files can be given via positional arguments or the flag <code>--infile-list</code>. For example:</p>
<pre><code>seqkit seq   a.fasta b.fasta

seqkit seq --infile-list file-list.txt

seqkit seq --infile-list &lt;(find -name "*.fq.gz" directory)
</code></pre>
<p>Result are printed to standard ouput (STDOUT) by default, you can also specify the output file
via the flag <code>-o/--out-file</code>. The file name extension <code>.gz</code> is automatically recognized.
For example:</p>
<pre><code>seqkit seq a.fasta -o a.fasta.gz

seqkit grep -f IDs.txt read_1.fq.gz -o dir/read_1.fq.gz
</code></pre>
<p>Seqkit utlizies the <a href="https://github.com/klauspost/pgzip">pgzip</a> package to read and write gzip file,
and the outputted gzip file would be slighty larger than files generated by GNU <code>gzip</code>.</p>
<p><strong>Seqkit writes gzip files very fast, much faster than the multi-threaded <code>pigz</code>,
so there's no need to pipe the result to <code>gzip</code>/<code>pigz</code></strong>.</p>
<h3 id="sequence-formats-and-types">Sequence formats and types</h3>
<p>SeqKit seamlessly support FASTA and FASTQ format.
Sequence format is automatically detected.
All subcommands except for <code>faidx</code> and <code>bam</code> can handle both formats.
And only when some commands (<code>subseq</code>, <code>split</code>, <code>sort</code> and <code>shuffle</code>)
which utilise FASTA index to improve perfrmance for large files in two pass mode
(by flag <code>--two-pass</code>), only FASTA format is supported.</p>
<p>Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences
of the first sequences in file or STDIN. The length of the leading subsequences
is configurable by global flag <code>--alphabet-guess-seq-length</code> with default value
of 10000. If length of the sequences is less than that, whole sequences will
be checked.</p>
<h3 id="sequence-id">Sequence ID</h3>
<p>By default, most softwares, including <code>seqkit</code>, take the leading non-space
letters as sequence identifier (ID). For example,</p>
<table>
<thead>
<tr>
<th style="text-align: left;">FASTA header</th>
<th style="text-align: left;">ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">&gt;123456 gene name</td>
<td style="text-align: left;">123456</td>
</tr>
<tr>
<td style="text-align: left;">&gt;longname</td>
<td style="text-align: left;">longname</td>
</tr>
<tr>
<td style="text-align: left;">&gt;gi&#124;110645304&#124;ref&#124;NC_002516.2&#124; Pseudomona</td>
<td style="text-align: left;">gi&#124;110645304&#124;ref&#124;NC_002516.2&#124;</td>
</tr>
</tbody>
</table>
<p>But for some sequences from NCBI,
e.g. <code>&gt;gi|110645304|ref|NC_002516.2| Pseudomona</code>, the ID is <code>NC_002516.2</code>.
In this case, we could set sequence ID parsing regular expression by global flag
<code>--id-regexp "\|([^\|]+)\| "</code> or just use flag <code>--id-ncbi</code>. If you want
the <code>gi</code> number, then use <code>--id-regexp "^gi\|([^\|]+)\|"</code>.</p>
<h3 id="fasta-index">FASTA index</h3>
<p>For some commands, including <code>subseq</code>, <code>split</code>, <code>sort</code> and <code>shuffle</code>,
when input files are (plain or gzipped) FASTA files,
FASTA index would be optional used for
rapid access of sequences and reducing memory occupation.</p>
<p>ATTENTION: the <code>.seqkit.fai</code> file created by SeqKit is a little different from <code>.fai</code> file
created by <code>samtools</code>. SeqKit uses full sequence head instead of just ID as key.</p>
<h3 id="parallelization-of-cpu-intensive-jobs">Parallelization of CPU intensive jobs</h3>
<p>The validation of sequences bases and complement process of sequences
are parallelized for large sequences.</p>
<p>Parsing of line-based files, including BED/GFF file and ID list file are also parallelized.</p>
<p>The <code>pgzip</code> package reads and write gzip files in parallel.</p>
<p>The Parallelization is implemented by multiple goroutines in golang
 which are similar to but much
lighter weight than threads. The concurrency number is configurable with global
flag <code>-j</code> or <code>--threads</code> (default value: 4).</p>
<p><strong>Using four threads is fast enough for most commands where FASTA/Q reading and writing is the
performance bottleneck, and using more threads will not increase the speed</strong>. </p>
<p>Few commands could benefit from multiple (&gt;4) threads:</p>
<ul>
<li><code>stats</code></li>
<li><code>scat</code></li>
<li><code>grep -s -m</code></li>
<li><code>locate -s -m</code></li>
<li><code>amplicon -s -m</code></li>
</ul>
<h3 id="memory-occupation">Memory occupation</h3>
<p>Most of the subcommands do not read whole FASTA/Q records in to memory,
including <code>stat</code>, <code>fq2fa</code>, <code>fx2tab</code>, <code>tab2fx</code>, <code>grep</code>, <code>locate</code>, <code>replace</code>,
 <code>seq</code>, <code>sliding</code>, <code>subseq</code>.</p>
<p>Note that when using <code>subseq --gtf | --bed</code>, if the GTF/BED files are too
big, the memory usage will increase.
You could use <code>--chr</code> to specify chromesomes and <code>--feature</code> to limit features.</p>
<p>Some subcommands could either read all records or read the files twice by flag
<code>-2</code> (<code>--two-pass</code>), including <code>sample</code>, <code>split</code>, <code>shuffle</code> and <code>sort</code>.
They use FASTA index for rapid acccess of sequences and reducing memory occupation.</p>
<h3 id="reproducibility">Reproducibility</h3>
<p>Subcommands <code>sample</code> and <code>shuffle</code> use random function, random seed could be
given by flag <code>-s</code> (<code>--rand-seed</code>). This makes sure that sampling result could be
reproduced in different environments with same random seed.</p>
<h2 id="seqkit">seqkit</h2>
<pre><code class="language-text">SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation

Version: 2.8.0

Author: Wei Shen &lt;shenwei356@gmail.com&gt;

Documents  : http://bioinf.shenwei.me/seqkit
Source code: https://github.com/shenwei356/seqkit
Please cite: https://doi.org/10.1371/journal.pone.0163962


Seqkit utlizies the pgzip (https://github.com/klauspost/pgzip) package to
read and write gzip file, and the outputted gzip file would be slighty
larger than files generated by GNU gzip.

Seqkit writes gzip files very fast, much faster than the multi-threaded pigz,
therefore there's no need to pipe the result to gzip/pigz.

Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0.
Bzip2 format is supported since v2.4.0.

Compression level:
  format   range   default  comment
  gzip     1-9     5        https://github.com/klauspost/pgzip sets 5 as the default value.
  xz       NA      NA       https://github.com/ulikunitz/xz does not support.
  zstd     1-4     2        roughly equals to zstd 1, 3, 7, 11, respectively.
  bzip     1-9     6        https://github.com/dsnet/compress

Usage:
  seqkit [command]

Commands for Basic Operation:
  faidx           create the FASTA index file and extract subsequences
  scat            real time recursive concatenation and streaming of fastx files
  seq             transform sequences (extract ID, filter by length, remove gaps, reverse complement...)
  sliding         extract subsequences in sliding windows
  stats           simple statistics of FASTA/Q files
  subseq          get subsequences by region/gtf/bed, including flanking sequences
  translate       translate DNA/RNA to protein sequence (supporting ambiguous bases)
  watch           monitoring and online histograms of sequence features

Commands for Format Conversion:
  convert         convert FASTQ quality encoding between Sanger, Solexa and Illumina
  fa2fq           retrieve corresponding FASTQ records by a FASTA file
  fq2fa           convert FASTQ to FASTA
  fx2tab          convert FASTA/Q to tabular format (and length, GC content, average quality...)
  tab2fx          convert tabular format to FASTA/Q format

Commands for Searching:
  amplicon        extract amplicon (or specific region around it) via primer(s)
  fish            look for short sequences in larger sequences using local alignment
  grep            search sequences by ID/name/sequence/sequence motifs, mismatch allowed
  locate          locate subsequences/motifs, mismatch allowed

Commands for Set Operation:
  common          find common/shared sequences of multiple files by id/name/sequence
  duplicate       duplicate sequences N times
  head            print first N FASTA/Q records
  head-genome     print sequences of the first genome with common prefixes in name
  pair            match up paired-end reads from two fastq files
  range           print FASTA/Q records in a range (start:end)
  rmdup           remove duplicated sequences by ID/name/sequence
  sample          sample sequences by number or proportion
  split           split sequences into files by id/seq region/size/parts (mainly for FASTA)
  split2          split sequences into files by size/parts (FASTA, PE/SE FASTQ)

Commands for Edit:
  concat          concatenate sequences with the same ID from multiple files
  mutate          edit sequence (point mutation, insertion, deletion)
  rename          rename duplicated IDs
  replace         replace name/sequence by regular expression
  restart         reset start position for circular genome
  sana            sanitize broken single line FASTQ files

Commands for Ordering:
  shuffle         shuffle sequences
  sort            sort sequences by id/name/sequence/length

Commands for BAM Processing:
  bam             monitoring and online histograms of BAM record features

Commands for Miscellaneous:
  merge-slides    merge sliding windows generated from seqkit sliding
  sum             compute message digest for all sequences in FASTA/Q files

Additional Commands:
  genautocomplete generate shell autocompletion script (bash|zsh|fish|powershell)
  version         print version information and check for update

Flags:
      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on
                                        which seqkit guesses the sequence type (0 for whole seq)
                                        (default 10000)
      --compress-level int              compression level for gzip, zstd, xz and bzip2. type &quot;seqkit -h&quot;
                                        for the range and default value for each format (default -1)
  -h, --help                            help for seqkit
      --id-ncbi                         FASTA head is NCBI-style, e.g. &gt;gi|110645304|ref|NC_002516.2|
                                        Pseud...
      --id-regexp string                regular expression for parsing ID (default &quot;^(\\S+)\\s?&quot;)
  -X, --infile-list string              file of input files list (one file per line), if given, they are
                                        appended to files from cli arguments
  -w, --line-width int                  line width when outputting FASTA format (0 for no wrap) (default 60)
  -o, --out-file string                 out file (&quot;-&quot; for stdout, suffix .gz for gzipped out) (default &quot;-&quot;)
      --quiet                           be quiet and do not show extra information
  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it
                                        automatically detect by the first sequence) (default &quot;auto&quot;)
  -j, --threads int                     number of CPUs. can also set with environment variable
                                        SEQKIT_THREADS) (default 4)

Use &quot;seqkit [command] --help&quot; for more information about a command.
</code></pre>
<h3 id="datasets">Datasets</h3>
<p>Datasets from <a href="ftp://mirbase.org/pub/mirbase/21/">The miRBase Sequence Database -- Release 21</a></p>
<ul>
<li><a href="ftp://mirbase.org/pub/mirbase/21/hairpin.fa.gz"><code>hairpin.fa.gz</code></a></li>
<li><a href="ftp://mirbase.org/pub/mirbase/21/mature.fa.gz"><code>mature.fa.gz</code></a></li>
<li><a href="ftp://mirbase.org/pub/mirbase/21/miRNA.diff.gz"><code>miRNA.diff.gz</code></a></li>
</ul>
<p>Human genome from <a href="http://uswest.ensembl.org/info/data/ftp/index.html">ensembl</a>
(For <code>seqkit subseq</code>)</p>
<ul>
<li><a href="ftp://ftp.ensembl.org/pub/release-84/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz"><code>Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz</code></a></li>
<li><a href="ftp://ftp.ensembl.org/pub/release-84/gtf/homo_sapiens/Homo_sapiens.GRCh38.84.gtf.gz"><code>Homo_sapiens.GRCh38.84.gtf.gz</code></a></li>
<li><code>Homo_sapiens.GRCh38.84.bed.gz</code> is converted from <code>Homo_sapiens.GRCh38.84.gtf.gz</code>
by <a href="http://bedops.readthedocs.org/en/latest/content/reference/file-management/conversion/gtf2bed.html?highlight=gtf2bed"><code>gtf2bed</code></a>
with the command<pre><code>zcat Homo_sapiens.GRCh38.84.gtf.gz \
    | gtf2bed --do-not-sort \
    | gzip -c &gt; Homo_sapiens.GRCh38.84.bed.gz
</code></pre>
</li>
</ul>
<p>Only DNA and gtf/bed data of Chr1 were used:</p>
<ul>
<li>
<p><code>chr1.fa.gz</code></p>
<pre><code>seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz
</code></pre>
</li>
<li>
<p><code>chr1.gtf.gz</code></p>
<pre><code>zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c &gt; chr1.gtf.gz
</code></pre>
</li>
<li>
<p><code>chr1.bed.gz</code></p>
<pre><code>zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c &gt; chr1.bed.gz
</code></pre>
</li>
</ul>
<h2 id="seq">seq</h2>
<p>Usage</p>
<pre><code class="language-text">transform sequences (extract ID, filter by length, remove gaps, reverse complement...)

Usage:
  seqkit seq [flags] 

Flags:
  -k, --color                 colorize sequences - to be piped into &quot;less -R&quot;
  -p, --complement            complement sequence, flag '-v' is recommended to switch on
      --dna2rna               DNA to RNA
  -G, --gap-letters string    gap letters to be removed with -g/--remove-gaps (default &quot;- \t.&quot;)
  -h, --help                  help for seq
  -l, --lower-case            print sequences in lower case
  -M, --max-len int           only print sequences shorter than or equal to the maximum length (-1 for
                              no limit) (default -1)
  -R, --max-qual float        only print sequences with average quality less than this limit (-1 for no
                              limit) (default -1)
  -m, --min-len int           only print sequences longer than or equal to the minimum length (-1 for no
                              limit) (default -1)
  -Q, --min-qual float        only print sequences with average quality greater or equal than this limit
                              (-1 for no limit) (default -1)
  -n, --name                  only print names/sequence headers
  -i, --only-id               print IDs instead of full headers
  -q, --qual                  only print qualities
  -b, --qual-ascii-base int   ASCII BASE, 33 for Phred+33 (default 33)
  -g, --remove-gaps           remove gaps letters set by -G/--gap-letters, e.g., spaces, tabs, and
                              dashes (gaps &quot;-&quot; in aligned sequences)
  -r, --reverse               reverse sequence
      --rna2dna               RNA to DNA
  -s, --seq                   only print sequences
  -u, --upper-case            print sequences in upper case
  -v, --validate-seq          validate bases according to the alphabet

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Read and print</p>
<ul>
<li>
<p>From file:</p>
<pre><code>$ seqkit seq hairpin.fa.gz
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA

$ seqkit seq reads_1.fq.gz
@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG
TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG
+
HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII
</code></pre>
</li>
<li>
<p>From stdin:</p>
<pre><code>zcat hairpin.fa.gz | seqkit seq
</code></pre>
</li>
</ul>
</li>
<li>
<p>Sequence types</p>
<ul>
<li>
<p>By default, <code>seqkit seq</code> automatically detect the sequence type</p>
<pre><code>$ echo -e "&gt;seq\nacgtryswkmbdhvACGTRYSWKMBDHV" | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   DNA          1       28       28       28       28

$ echo -e "&gt;seq\nACGUN ACGUN" | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA          1       11       11       11       11

$ echo -e "&gt;seq\nabcdefghijklmnpqrstvwyz" | seqkit stats
file  format  type     num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   Protein         1       23       23       23       23

$ echo -e "@read\nACTGCN\n+\n@IICCG" | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTQ   DNA          1        6        6        6        6
</code></pre>
</li>
<li>
<p>You can also set sequence type by flag <code>-t</code> (<code>--seq-type</code>).
  But this only take effect on subcommands <code>seq</code> and <code>locate</code>.</p>
<pre><code>$ echo -e "&gt;seq\nabcdefghijklmnpqrstvwyz" | seqkit seq -t dna
[INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on
[ERRO] error when parsing seq: seq (invalid DNAredundant letter: e)
</code></pre>
</li>
</ul>
</li>
<li>
<p>Only print names</p>
<ul>
<li>
<p>Full name:</p>
<pre><code>$ seqkit seq hairpin.fa.gz -n
cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop
cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop
</code></pre>
</li>
<li>
<p>Only ID:</p>
<pre><code>$ seqkit seq hairpin.fa.gz -n -i
cel-let-7
cel-lin-4
cel-mir-1
</code></pre>
</li>
<li>
<p>Custom ID region by regular expression (this could be applied to all subcommands):</p>
<pre><code>$ seqkit seq hairpin.fa.gz -n -i --id-regexp "^[^\s]+\s([^\s]+)\s"
MI0000001
MI0000002
MI0000003
</code></pre>
</li>
</ul>
</li>
<li>
<p>Only print seq (global flag <code>-w</code> defines the output line width, <code>0</code> for no wrap)</p>
<pre><code>$ seqkit seq hairpin.fa.gz -s -w 0
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU
AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU
</code></pre>
</li>
<li>
<p>Convert multi-line FASTQ to 4-line FASTQ</p>
<pre><code>$ seqkit seq reads_1.fq.gz -w 0
</code></pre>
</li>
<li>
<p>Reverse comlement sequence</p>
<pre><code>$ seqkit seq hairpin.fa.gz -r -p
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC
AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA
</code></pre>
</li>
<li>
<p>Remove gaps and to lower/upper case</p>
<pre><code>$ echo -e "&gt;seq\nACGT-ACTGC-ACC" | seqkit seq -g -u
&gt;seq
ACGTACTGCACC
</code></pre>
</li>
<li>
<p>RNA to DNA</p>
<pre><code>$ echo -e "&gt;seq\nUCAUAUGCUUGUCUCAAAGAUUA" | seqkit seq --rna2dna
&gt;seq
TCATATGCTTGTCTCAAAGATTA
</code></pre>
</li>
<li>
<p>Filter by sequence length</p>
<pre><code>$ cat hairpin.fa | seqkit seq | seqkit stats
file  format  type  num_seqs    sum_len  min_len  avg_len  max_len
-     FASTA   RNA     28,645  2,949,871       39      103    2,354

$ cat hairpin.fa | seqkit seq -m 100 | seqkit stats
file  format  type  num_seqs    sum_len  min_len  avg_len  max_len
-     FASTA   RNA     10,975  1,565,486      100    142.6    2,354

$ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats
file  format  type  num_seqs    sum_len  min_len  avg_len  max_len
-     FASTA   RNA     10,972  1,560,270      100    142.2      938
</code></pre>
</li>
</ol>
<h2 id="subseq">subseq</h2>
<p>Usage</p>
<pre><code class="language-text">get subsequences by region/gtf/bed, including flanking sequences.

Attention:
  1. Use &quot;seqkit grep&quot; for extract subsets of sequences.
     &quot;seqtk subseq seqs.fasta id.txt&quot; equals to
     &quot;seqkit grep -f id.txt seqs.fasta&quot;

Recommendation:
  1. Use plain FASTA file, so seqkit could utilize FASTA index.
  2. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file.

The definition of region is 1-based and with some custom design.

Examples:

 1-based index    1 2 3 4 5 6 7 8 9 10
negative index    0-9-8-7-6-5-4-3-2-1
           seq    A C G T N a c g t n
           1:1    A
           2:4      C G T
         -4:-2                c g t
         -4:-1                c g t n
         -1:-1                      n
          2:-2      C G T N a c g t
          1:-1    A C G T N a c g t n
          1:12    A C G T N a c g t n
        -12:-1    A C G T N a c g t n

Usage:
  seqkit subseq [flags] 

Flags:
      --bed string        by tab-delimited BED file
      --chr strings       select limited sequence with sequence IDs when using --gtf or --bed (multiple
                          value supported, case ignored)
  -d, --down-stream int   down stream length
      --feature strings   select limited feature types (multiple value supported, case ignored, only
                          works with GTF)
      --gtf string        by GTF (version 2.2) file
      --gtf-tag string    output this tag as sequence comment (default &quot;gene_id&quot;)
  -h, --help              help for subseq
  -f, --only-flank        only return up/down stream sequence
  -r, --region string     by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for
                          cutting first 12 bases. type &quot;seqkit subseq -h&quot; for more examples
  -R, --region-coord      append coordinates to sequence ID for -r/--region
  -u, --up-stream int     up stream length
  -U, --update-faidx      update the fasta index file if it exists. Use this if you are not sure whether
                          the fasta file changed

</code></pre>
<p>Examples</p>
<p><strong><em>Recommendation: use plain FASTA file, so seqkit could utilize FASTA index.</em></strong></p>
<ol>
<li>
<p>First 12 bases</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit subseq -r 1:12
</code></pre>
</li>
<li>
<p>Last 12 bases</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit subseq -r -12:-1
</code></pre>
</li>
<li>
<p>Subsequences without first and last 12 bases</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit subseq -r 13:-13
</code></pre>
</li>
<li>
<p>Get subsequence by GTF file</p>
<pre><code>$ cat t.fa
&gt;seq
actgACTGactgn

$ cat t.gtf
seq     test    CDS     5       8       .       .       .       gene_id "A"; transcript_id "";
seq     test    CDS     5       8       .       -       .       gene_id "B"; transcript_id "";

$ seqkit subseq --gtf t.gtf t.fa
&gt;seq_5:8:. A
ACTG
&gt;seq_5:8:- B
CAGT
</code></pre>
<p>Human genome example:</p>
<p><strong><em>AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,
the uncompressed data are so big and may exhaust your RAM.</em></strong></p>
<p>We could specify chromesomes and features.</p>
<pre><code>$ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds  hsa.fa &gt; chr1.gtf.cds.fa

$ seqkit stats chr1.gtf.cds.fa
file             format  type  num_seqs    sum_len  min_len  avg_len  max_len
chr1.gtf.cds.fa  FASTA   DNA     65,012  9,842,274        1    151.4   12,045
</code></pre>
</li>
<li>
<p>Get CDS and 3bp up-stream sequences</p>
<pre><code>$ seqkit subseq --gtf t.gtf t.fa -u 3
&gt;seq_5:8:._us:3 A
ctgACTG
&gt;seq_5:8:-_us:3 B
agtCAGT
</code></pre>
</li>
<li>
<p>Get 3bp up-stream sequences of CDS, not including CDS</p>
<pre><code>$ seqkit subseq --gtf t.gtf t.fa -u 3 -f
&gt;seq_5:8:._usf:3 A
ctg
&gt;seq_5:8:-_usf:3 B
agt
</code></pre>
</li>
<li>
<p>Get subsequences by BED file.</p>
<p><strong><em>AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,
the uncompressed data are so big and may exhaust your RAM.</em></strong></p>
<pre><code>$ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \
    &gt;  chr1.bed.gz.fa
</code></pre>
<p>We may need to remove duplicated sequences</p>
<pre><code>$ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \
    | seqkit rmdup &gt; chr1.bed.rmdup.fa
[INFO] 141060 duplicated records removed
</code></pre>
<p>Summary:</p>
<pre><code>$ seqkit stats chr1.gz.*.gz
file               seq_format   seq_type   num_seqs   min_len   avg_len     max_len
chr1.gz.fa         FASTA        DNA         231,974         1   3,089.5   1,551,957
chr1.gz.rmdup.fa   FASTA        DNA          90,914         1   6,455.8   1,551,957
</code></pre>
</li>
</ol>
<h2 id="sliding">sliding</h2>
<p>Usage</p>
<pre><code class="language-text">extract subsequences in sliding windows

Usage:
  seqkit sliding [flags]

Flags:
  -c, --circular          circular genome (same to -C/--circular-genome)
  -C, --circular-genome   circular genome (same to -c/--circular)
  -g, --greedy            greedy mode, i.e., exporting last subsequences even shorter than the windows size
  -h, --help              help for sliding
  -s, --step int          step size
  -S, --sufix string      suffix added to the sequence ID
  -W, --window int        window size

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>General use</p>
<pre><code>$ echo -e "&gt;seq\nACGTacgtNN" | seqkit sliding -s 3 -W 6
&gt;seq_sliding:1-6
ACGTac
&gt;seq_sliding:4-9
TacgtN
</code></pre>
</li>
<li>
<p>Greedy mode</p>
<pre><code>$ echo -e "&gt;seq\nACGTacgtNN" | seqkit sliding -s 3 -W 6 -g
&gt;seq_sliding:1-6
ACGTac
&gt;seq_sliding:4-9
TacgtN
&gt;seq_sliding:7-12
gtNN
&gt;seq_sliding:10-15
N
</code></pre>
</li>
<li>
<p>Circular genome</p>
<pre><code>$ echo -e "&gt;seq\nACGTacgtNN" | seqkit sliding -s 3 -W 6 -C
&gt;seq_sliding:1-6
ACGTac
&gt;seq_sliding:4-9
TacgtN
&gt;seq_sliding:7-2
gtNNAC
&gt;seq_sliding:10-5
NACGTa
</code></pre>
</li>
<li>
<p>Generate GC content for ploting</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit sliding -s 5 -W 30 \
    | seqkit fx2tab -n -g
cel-let-7_sliding:1-30          50.00
cel-let-7_sliding:6-35          46.67
cel-let-7_sliding:11-40         43.33
cel-let-7_sliding:16-45         36.67
cel-let-7_sliding:21-50         33.33
cel-let-7_sliding:26-55         40.00
...
</code></pre>
</li>
</ol>
<h2 id="stats">stats</h2>
<p>Usage</p>
<pre><code class="language-text">simple statistics of FASTA/Q files

Columns:

  1.  file      input file, &quot;-&quot; for STDIN
  2.  format    FASTA or FASTQ
  3.  type      DNA, RNA, Protein or Unlimit
  4.  num_seqs  number of sequences
  5.  sum_len   number of bases or residues       , with gaps or spaces counted
  6.  min_len   minimal sequence length           , with gaps or spaces counted
  7.  avg_len   average sequence length           , with gaps or spaces counted
  8.  max_len   miximal sequence length           , with gaps or spaces counted
  9.  Q1        first quartile of sequence length , with gaps or spaces counted
  10. Q2        median of sequence length         , with gaps or spaces counted
  11. Q3        third quartile of sequence length , with gaps or spaces counted
  12. sum_gap   number of gaps
  13. N50       N50. https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics#N50
  14. N50_num   N50_num or L50. https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics#L50
  15. Q20(%)    percentage of bases with the quality score greater than 20
  16. Q30(%)    percentage of bases with the quality score greater than 30
  17. AvgQual   average quality
  18. GC(%)     percentage of GC content

Attention:
  1. Sequence length metrics (sum_len, min_len, avg_len, max_len, Q1, Q2, Q3)
     count the number of gaps or spaces. You can remove them with &quot;seqkit seq -g&quot;:
         seqkit seq -g input.fasta | seqkit stats

Tips:
  1. For lots of small files (especially on SDD), use big value of '-j' to
     parallelize counting.
  2. Extract one metric with csvtk (https://github.com/shenwei356/csvtk):
         seqkit stats -Ta input.fastq.gz | csvtk cut -t -f &quot;Q30(%)&quot; | csvtk del-header

Usage:
  seqkit stats [flags]

Aliases:
  stats, stat

Flags:
  -N, --N strings            other N50-like stats. value range [0, 100], multiple values supported,
                             e.g., -N 50,90 or -N 50 -N 90
  -a, --all                  all statistics, including quartiles of seq length, sum_gap, N50
  -b, --basename             only output basename of files
  -E, --fq-encoding string   fastq quality encoding. available values: 'sanger', 'solexa',
                             'illumina-1.3+', 'illumina-1.5+', 'illumina-1.8+'. (default &quot;sanger&quot;)
  -G, --gap-letters string   gap letters (default &quot;- .&quot;)
  -h, --help                 help for stats
  -e, --skip-err             skip error, only show warning message
  -S, --skip-file-check      skip input file checking when given files or a file list.
  -i, --stdin-label string   label for replacing default &quot;-&quot; for stdin (default &quot;-&quot;)
  -T, --tabular              output in machine-friendly tabular format

</code></pre>
<p>Eexamples</p>
<ol>
<li>
<p>General use</p>
<pre><code>$ seqkit stats *.f{a,q}.gz
file           format  type  num_seqs    sum_len  min_len  avg_len  max_len
hairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354
mature.fa.gz   FASTA   RNA     35,828    781,222       15     21.8       34
reads_1.fq.gz  FASTQ   DNA      2,500    567,516      226      227      229
reads_2.fq.gz  FASTQ   DNA      2,500    560,002      223      224      225
</code></pre>
</li>
<li>
<p>Machine-friendly tabular format</p>
<pre><code>$ seqkit stats *.f{a,q}.gz -T
file    format  type    num_seqs        sum_len min_len avg_len max_len
hairpin.fa.gz   FASTA   RNA     28645   2949871 39      103.0   2354
mature.fa.gz    FASTA   RNA     35828   781222  15      21.8    34
Illimina1.8.fq.gz       FASTQ   DNA     10000   1500000 150     150.0   150
reads_1.fq.gz   FASTQ   DNA     2500    567516  226     227.0   229
reads_2.fq.gz   FASTQ   DNA     2500    560002  223     224.0   225

# So you can process the result with tools like csvtk: http://bioinf.shenwei.me/csvtk

$ seqkit stats *.f{a,q}.gz -T | csvtk pretty -t
file                format   type   num_seqs   sum_len   min_len   avg_len   max_len
-----------------   ------   ----   --------   -------   -------   -------   -------
hairpin.fa.gz       FASTA    RNA    28645      2949871   39        103.0     2354
mature.fa.gz        FASTA    RNA    35828      781222    15        21.8      34
Illimina1.8.fq.gz   FASTQ    DNA    10000      1500000   150       150.0     150
reads_1.fq.gz       FASTQ    DNA    2500       567516    226       227.0     229
reads_2.fq.gz       FASTQ    DNA    2500       560002    223       224.0     225

# To markdown

$ seqkit stats *.f{a,q}.gz -T | csvtk csv2md -t
|file             |format|type|num_seqs|sum_len|min_len|avg_len|max_len|
|:----------------|:-----|:---|:-------|:------|:------|:------|:------|
|hairpin.fa.gz    |FASTA |RNA |28645   |2949871|39     |103.0  |2354   |
|mature.fa.gz     |FASTA |RNA |35828   |781222 |15     |21.8   |34     |
|Illimina1.8.fq.gz|FASTQ |DNA |10000   |1500000|150    |150.0  |150    |
|reads_1.fq.gz    |FASTQ |DNA |2500    |567516 |226    |227.0  |229    |
|reads_2.fq.gz    |FASTQ |DNA |2500    |560002 |223    |224.0  |225    |
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: left;">file</th>
<th style="text-align: left;">format</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">num_seqs</th>
<th style="text-align: left;">sum_len</th>
<th style="text-align: left;">min_len</th>
<th style="text-align: left;">avg_len</th>
<th style="text-align: left;">max_len</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">hairpin.fa.gz</td>
<td style="text-align: left;">FASTA</td>
<td style="text-align: left;">RNA</td>
<td style="text-align: left;">28645</td>
<td style="text-align: left;">2949871</td>
<td style="text-align: left;">39</td>
<td style="text-align: left;">103.0</td>
<td style="text-align: left;">2354</td>
</tr>
<tr>
<td style="text-align: left;">mature.fa.gz</td>
<td style="text-align: left;">FASTA</td>
<td style="text-align: left;">RNA</td>
<td style="text-align: left;">35828</td>
<td style="text-align: left;">781222</td>
<td style="text-align: left;">15</td>
<td style="text-align: left;">21.8</td>
<td style="text-align: left;">34</td>
</tr>
<tr>
<td style="text-align: left;">Illimina1.8.fq.gz</td>
<td style="text-align: left;">FASTQ</td>
<td style="text-align: left;">DNA</td>
<td style="text-align: left;">10000</td>
<td style="text-align: left;">1500000</td>
<td style="text-align: left;">150</td>
<td style="text-align: left;">150.0</td>
<td style="text-align: left;">150</td>
</tr>
<tr>
<td style="text-align: left;">reads_1.fq.gz</td>
<td style="text-align: left;">FASTQ</td>
<td style="text-align: left;">DNA</td>
<td style="text-align: left;">2500</td>
<td style="text-align: left;">567516</td>
<td style="text-align: left;">226</td>
<td style="text-align: left;">227.0</td>
<td style="text-align: left;">229</td>
</tr>
<tr>
<td style="text-align: left;">reads_2.fq.gz</td>
<td style="text-align: left;">FASTQ</td>
<td style="text-align: left;">DNA</td>
<td style="text-align: left;">2500</td>
<td style="text-align: left;">560002</td>
<td style="text-align: left;">223</td>
<td style="text-align: left;">224.0</td>
<td style="text-align: left;">225</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Extra information</p>
<pre><code>$ seqkit stats *.f{a,q}.gz -a
file               format  type  num_seqs    sum_len  min_len  avg_len  max_len   Q1   Q2   Q3  sum_gap  N50  N50_num  Q20(%)  Q30(%)  AvgQual  GC(%)
hairpin.fa.gz      FASTA   RNA     28,645  2,949,871       39      103    2,354   76   91  111        0  101      380       0       0        0  45.77
mature.fa.gz       FASTA   RNA     35,828    781,222       15     21.8       34   21   22   22        0   22       12       0       0        0   47.6
Illimina1.8.fq.gz  FASTQ   DNA     10,000  1,500,000      150      150      150  150  150  150        0  150        1   96.16   89.71    24.82  49.91
nanopore.fq.gz     FASTQ   DNA      4,000  1,798,723      153    449.7    6,006  271  318  391        0  395      585   40.79   12.63     9.48  46.66
reads_1.fq.gz      FASTQ   DNA      2,500    567,516      226      227      229  227  227  227        0  227        3   91.24   86.62    15.45  53.63
reads_2.fq.gz      FASTQ   DNA      2,500    560,002      223      224      225  224  224  224        0  224        2   91.06   87.66    14.62  54.77
</code></pre>
</li>
<li>
<p><strong>Parallelize counting files, it's much faster for lots of small files, especially for files on SSD</strong></p>
<pre><code>seqkit stats -j 10 refseq/virual/*.fna.gz
</code></pre>
</li>
<li>
<p>Skip error</p>
<pre><code>$ seqkit stats tests/*
[ERRO] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format

$ seqkit stats tests/* -e
[WARN] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format
[WARN] tests/hairpin.fa.seqkit.fai: fastx: invalid FASTA/Q format
[WARN] tests/miRNA.diff.gz: fastx: invalid FASTA/Q format
[WARN] tests/test.sh: fastx: invalid FASTA/Q format
file                     format  type  num_seqs    sum_len  min_len  avg_len  max_len
tests/contigs.fa         FASTA   DNA          9         54        2        6       10
tests/hairpin.fa         FASTA   RNA     28,645  2,949,871       39      103    2,354
tests/Illimina1.5.fq     FASTQ   DNA          1        100      100      100      100
tests/Illimina1.8.fq.gz  FASTQ   DNA     10,000  1,500,000      150      150      150
tests/hairpin.fa.gz      FASTA   RNA     28,645  2,949,871       39      103    2,354
tests/reads_1.fq.gz      FASTQ   DNA      2,500    567,516      226      227      229
tests/mature.fa.gz       FASTA   RNA     35,828    781,222       15     21.8       34
tests/reads_2.fq.gz      FASTQ   DNA      2,500    560,002      223      224      225
</code></pre>
</li>
<li>
<p>Output basename instead of full path (<code>-b/--basename</code>)</p>
</li>
</ol>
<h2 id="sum">sum</h2>
<p>Usage</p>
<pre><code class="language-text">compute message digest for all sequences in FASTA/Q files

Attention:
  1. Sequence headers and qualities are skipped, only sequences matter.
  2. The order of sequences records does not matter.
  3. Circular complete genomes are supported with the flag -c/--circular.
     - The same double-stranded genomes with different start positions or
       in reverse complement strand will not affect the result.
     - For single-stranded genomes like ssRNA genomes, use -s/--single-strand.
     - The message digest would change with different values of k-mer size.
  4. Multiple files are processed in parallel (-j/--threads).

Method:
  1. Converting the sequences to low cases, optionally removing gaps (-g).
  2. Computing the hash (xxhash) for all sequences or k-mers of a circular
     complete genome (-c/--circular).
  3. Sorting all hash values, for ignoring the order of sequences.
  4. Computing MD5 digest from the hash values, sequences length, and
     the number of sequences.

Following the seqhash in Poly (https://github.com/TimothyStiles/poly/),
We add meta information to the message digest, with the format of:

    seqkit.&lt;version&gt;_&lt;seq type&gt;&lt;seq structure&gt;&lt;strand&gt;_&lt;kmer size&gt;_&lt;seq digest&gt;

    &lt;version&gt;:       digest version
    &lt;seq type&gt;:      'D' for DNA, 'R' for RNA, 'P' for protein, 'N' for others
    &lt;seq structure&gt;: 'L' for linear sequence, 'C' for circular genome
    &lt;strand&gt;:        'D' for double-stranded, 'S' for single-stranded
    &lt;kmer size&gt;:     0 for linear sequence, other values for circular genome

Examples:

    seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94    DNA.fq.gz
    seqkit.v0.1_PLS_k0_c244954e4960dd2a1409cd8ee53d92b9    Protein.fasta
    seqkit.v0.1_RLS_k0_0f1fb263f0c05a259ae179a61a80578d    single-stranded RNA.fasta

    seqkit.v0.1_DCD_k31_e59dad6d561f1f1f28ebf185c6f4c183   double-stranded-circular DNA.fasta
    seqkit.v0.1_DCS_k31_dd050490cd62ea5f94d73d4d636b7d60   single-stranded-circular DNA.fasta

Usage:
  seqkit sum [flags]

Flags:
  -a, --all                  show all information, including the sequences length and the number of sequences
  -b, --basename             only output basename of files
  -c, --circular             the file contains a single cicular genome sequence
  -G, --gap-letters string   gap letters to delete with the flag -g/--remove-gaps (default &quot;- \t.*&quot;)
  -h, --help                 help for sum
  -k, --kmer-size int        k-mer size for processing circular genomes (default 1000)
  -g, --remove-gaps          remove gap characters set in the option -G/gap-letters
      --rna2dna              convert RNA to DNA
  -s, --single-strand        only consider the positive strand of a circular genome, e.g., ssRNA virus
                             genomes

</code></pre>
<p>Examples:</p>
<p>A, B, C, D are the same vircular genomes with different starting positions or strands:</p>
<pre><code>$ cat virus-{A,B,C,D}.fasta
&gt;seq
TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA
&gt;seq.revcom
TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA
&gt;seq.new-start
GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT
&gt;seq.revcom.new-start
TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT

# cat to one file
$ cat virus-{A,B,C,D}.fasta &gt; virues.fasta

# shuffle and rename
$ cat virus-{A,B,C,D}.fasta \
    | seqkit shuffle \
    | seqkit replace -p '.*' -r '{nr}' \
    | tee virues.shuffled.fasta
&gt;1
TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT
&gt;2
TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA
&gt;3
GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT
&gt;4
TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA
</code></pre>
<p>Sum of all files (the sequences order does not matter):</p>
<pre><code>$ seqkit sum viru*.fasta
seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17    virues.fasta
seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17    virues.shuffled.fasta
seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94    virus-A.fasta
seqkit.v0.1_DLS_k0_7a813339f9ae686b376b1df55cd596ca    virus-B.fasta
seqkit.v0.1_DLS_k0_0fd51028bfbfa85ddbdd2b86ef7bd1c1    virus-C.fasta
seqkit.v0.1_DLS_k0_88b1d20dd0fe0dbf41c00b075fee4e4e    virus-D.fasta
</code></pre>
<p>Circular genomes (the same genomes with different start positions or in reverse
complement strand will not affect the result):</p>
<pre><code>$ seqkit sum -c -k 21  virus-*.fasta
seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc   virus-A.fasta
seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc   virus-B.fasta
seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc   virus-C.fasta
seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc   virus-D.fasta

$ seqkit sum -c -k 51  virus-*.fasta
seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11   virus-A.fasta
seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11   virus-B.fasta
seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11   virus-C.fasta
seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11   virus-D.fasta

# collect files with the same genomes
$ seqkit sum -c -k 51  virus-*.fasta | csvtk fold -Ht -f 1 -v 2 
seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11   virus-A.fasta; virus-B.fasta; virus-C.fasta; virus-D.fasta
</code></pre>
<h2 id="faidx">faidx</h2>
<p>Usage</p>
<pre><code class="language-text">create the FASTA index file and extract subsequences

This command is similar with &quot;samtools faidx&quot; but has some extra features:

  1. output full header line with the flag -f
  2. support regular expression as sequence ID with the flag -r
  3. if you have large number of IDs, you can use:
        seqkit faidx seqs.fasta -l IDs.txt

Attention:
  1. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file.

The definition of region is 1-based and with some custom design.

Examples:

 1-based index    1 2 3 4 5 6 7 8 9 10
negative index    0-9-8-7-6-5-4-3-2-1
           seq    A C G T N a c g t n
           1:1    A
           2:4      C G T
         -4:-2                c g t
         -4:-1                c g t n
         -1:-1                      n
          2:-2      C G T N a c g t
          1:-1    A C G T N a c g t n
          1:12    A C G T N a c g t n
        -12:-1    A C G T N a c g t n

Usage:
  seqkit faidx [flags] &lt;fasta-file&gt; [regions...]

Flags:
  -f, --full-head            print full header line instead of just ID. New fasta index file ending with
                             .seqkit.fai will be created
  -h, --help                 help for faidx
  -i, --ignore-case          ignore case
  -I, --immediate-output     print output immediately, do not use write buffer
  -l, --region-file string   file containing a list of regions
  -U, --update-faidx         update the fasta index file if it exists. Use this if you are not sure
                             whether the fasta file changed
  -r, --use-regexp           IDs are regular expression. But subseq region is not supported here.

</code></pre>
<p>Example</p>
<ol>
<li>
<p>common usage like <code>samtools faidx</code></p>
<pre><code>$ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2
&gt;hsa-let-7a-1
UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU
ACAAUCUACUGUCUUUCCUA
&gt;hsa-let-7a-2
AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU
CCUAGCUUUCCU
</code></pre>
</li>
<li>
<p>output full header, not supported by <code>samtools faidx</code></p>
<pre><code>$ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 -f
&gt;hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop
UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU
ACAAUCUACUGUCUUUCCUA
&gt;hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop
AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU
CCUAGCUUUCCU
</code></pre>
</li>
<li>
<p>extract subsequence of specific region</p>
<pre><code>$ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1-10
&gt;hsa-let-7a-1:1-10
UGGGAUGAGG

$ seqkit faidx tests/hairpin.fa hsa-let-7a-1:-10--1
&gt;hsa-let-7a-1:-10--1
GUCUUUCCUA

$ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1
&gt;hsa-let-7a-1:1-1
U
</code></pre>
</li>
<li>
<p>supporting <code>begin</code> &gt; <code>start</code>, i.e., returning reverse complement sequence, not supported by <code>samtools faidx</code></p>
<pre><code>$ seqkit faidx tests/hairpin.fa hsa-let-7a-1:10-1
&gt;hsa-let-7a-1:10-1
CCUCAUCCCA
</code></pre>
</li>
<li>
<p>use regular expression</p>
<pre><code>$ seqkit faidx tests/hairpin.fa hsa -r | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA      1,881  154,002       41     81.9      180
</code></pre>
</li>
</ol>
<h2 id="watch">watch</h2>
<p>Usage</p>
<pre><code class="language-text">monitoring and online histograms of sequence features

Usage:
  seqkit watch [flags]

Flags:
  -B, --bins int              number of histogram bins (default -1)
  -W, --delay int             sleep this many seconds after online plotting (default 1)
  -y, --dump                  print histogram data to stderr instead of plotting
  -f, --fields string         target fields, available values: ReadLen, MeanQual, GC, GCSkew (default
                              &quot;ReadLen&quot;)
  -h, --help                  help for watch
  -O, --img string            save histogram to this PDF/image file
  -H, --list-fields           print out a list of available fields
  -L, --log                   log10(x+1) transform numeric values
  -x, --pass                  pass through mode (write input to stdout)
  -p, --print-freq int        print/report after this many records (-1 for print after EOF) (default -1)
  -b, --qual-ascii-base int   ASCII BASE, 33 for Phred+33 (default 33)
  -Q, --quiet-mode            supress all plotting to stderr
  -R, --reset                 reset histogram after every report
  -v, --validate-seq          validate bases according to the alphabet

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Histogram of sequence length</p>
<pre><code>seqkit watch --fields ReadLen nanopore.fq.gz -O len.png
</code></pre>
<p><img alt="" src="../files/usage/watch.p0.png" /></p>
</li>
<li>
<p>Dynamic histogram of log sequence length</p>
<pre><code>seqkit watch --log --fields ReadLen nanopore.fq.gz
</code></pre>
<p><img alt="" src="../files/usage/watch.p1.png" /></p>
</li>
<li>
<p>Histogram of mean base qualities every 500 record, also saved as png</p>
<pre><code>seqkit watch -p 500 -O qhist.png -f MeanQual nanopore.fq.gz
</code></pre>
</li>
</ol>
<h2 id="sana">sana</h2>
<p>Usage</p>
<pre><code class="language-text">sanitize broken single line FASTQ files

Usage:
  seqkit sana [flags]

Flags:
  -A, --allow-gaps            allow gap character (-) in sequences
  -i, --format string         input and output format: fastq or fasta (default &quot;fastq&quot;)
  -h, --help                  help for sana
  -I, --in-format string      input format: fastq or fasta
  -O, --out-format string     output format: fastq or fasta
  -b, --qual-ascii-base int   ASCII BASE, 33 for Phred+33 (default 33)
</code></pre>
<p>Examples</p>
<ol>
<li>Rescue usable reads from fastq file with malformed records.<pre><code>seqkit sana broken.fq.gz -o rescued.fq.gz
</code></pre>
</li>
</ol>
<h2 id="scat">scat</h2>
<p>Usage</p>
<pre><code class="language-text">real time recursive concatenation and streaming of fastx files

Usage:
  seqkit scat [flags]

Flags:
  -A, --allow-gaps            allow gap character (-) in sequences
  -d, --delta int             minimum size increase in kilobytes to trigger parsing (default 5)
  -D, --drop-time string      Notification drop interval (default &quot;500ms&quot;)
  -f, --find-only             concatenate exisiting files and quit
  -i, --format string         input and output format: fastq or fasta (fastq) (default &quot;fastq&quot;)
  -g, --gz-only               only look for gzipped files (.gz suffix)
  -h, --help                  help for scat
  -I, --in-format string      input format: fastq or fasta (fastq)
  -O, --out-format string     output format: fastq or fasta
  -b, --qual-ascii-base int   ASCII BASE, 33 for Phred+33 (default 33)
  -r, --regexp string         regexp for watched files, by default guessed from the input format
  -T, --time-limit string     quit after inactive for this time period
  -p, --wait-pid int          after process with this PID exited (default -1)

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Concatenate all fastq files recursively under a directory</p>
<pre><code>seqkit scat -j 4 -f fastq_dir &gt; all_records.fq
</code></pre>
</li>
<li>
<p>Watch a directory and stream fastq records in real time until interrupt is recieved and plot read lengths using <code>seqkit watch</code>:</p>
<pre><code>seqkit scat -j 4 fastq_dir | seqkit watch -f ReadLen -
</code></pre>
</li>
<li>
<p>Watch a directory and stream fastq records in real time until there is no write activity under the directory for 5 seconds:</p>
<pre><code>seqkit scat -j 4 -T "5s" fastq_dir &gt; all_records.fq
</code></pre>
</li>
<li>
<p>Watch a directory and stream fastq records in real time until a process with a specified PID is alive:</p>
<pre><code>seqkit scat -j 4 -p $PID fastq_dir &gt; all_records.fq
</code></pre>
</li>
</ol>
<p><strong>Notes</strong>: You might need to increase the <code>ulimit</code> allowance on open files if you intend to stream fastx records from a large number of files.</p>
<h2 id="fq2fa">fq2fa</h2>
<p>Usage</p>
<pre><code class="language-text">convert FASTQ to FASTA

Usage:
  seqkit fq2fa [flags]

</code></pre>
<p>Examples</p>
<pre><code>seqkit fq2fa reads_1.fq.gz -o reads_1.fa.gz
</code></pre>
<h2 id="fa2fq">fa2fq</h2>
<p>Usage</p>
<pre><code class="language-text">retrieve corresponding FASTQ records by a FASTA file

Attention:
  1. We assume the FASTA file comes from the FASTQ file,
     so they share sequence IDs, and sequences in FASTA
     should be subseq of sequences in FASTQ file.

Usage:
  seqkit fa2fq [flags]

Flags:
  -f, --fasta-file string      FASTA file)
  -h, --help                   help for fa2fq
  -P, --only-positive-strand   only search on positive strand
</code></pre>
<h2 id="fx2tab-tab2fx">fx2tab &amp; tab2fx</h2>
<p>Usage (fx2tab)</p>
<pre><code class="language-text">convert FASTA/Q to tabular format, and provide various information,
like sequence length, GC content/GC skew.

Attention:
  1. Fixed three columns (ID, sequence, quality) are outputted for either FASTA
     or FASTQ, except when flag -n/--name is on. This is for format compatibility.

Usage:
  seqkit fx2tab [flags]

Flags:
  -a, --alphabet               print alphabet letters
  -q, --avg-qual               print average quality of a read
  -B, --base-content strings   print base content. (case ignored, multiple values supported) e.g. -B AT -B N
  -C, --base-count strings     print base count. (case ignored, multiple values supported) e.g. -C AT -C N
  -I, --case-sensitive         calculate case sensitive base content/sequence hash
  -g, --gc                     print GC content
  -G, --gc-skew                print GC-Skew
  -H, --header-line            print header line
  -h, --help                   help for fx2tab
  -l, --length                 print sequence length
  -n, --name                   only print names (no sequences and qualities)
  -Q, --no-qual                only output two column even for FASTQ file
  -i, --only-id                print ID instead of full head
  -b, --qual-ascii-base int    ASCII BASE, 33 for Phred+33 (default 33)
  -s, --seq-hash               print hash (MD5) of sequence

</code></pre>
<p>Usage (tab2fx)</p>
<pre><code class="language-text">convert tabular format (first two/three columns) to FASTA/Q format

Usage:
  seqkit tab2fx [flags] 

Flags:
  -b, --buffer-size string            size of buffer, supported unit: K, M, G. You need increase the
                                      value when &quot;bufio.Scanner: token too long&quot; error reported (default
                                      &quot;1G&quot;)
  -p, --comment-line-prefix strings   comment line prefix (default [#,//])
  -h, --help                          help for tab2fx

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Default output</p>
<pre><code>$ seqkit fx2tab hairpin.fa.gz | head -n 2
cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop      UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU
</code></pre>
</li>
<li>
<p>Print sequence length, GC content, and only print names (no sequences),
we could also print title line by flag <code>-H</code>.</p>
<pre><code>$ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '&amp;' pretty
#name       seq   qual   length   GC
cel-let-7                99       43.43
cel-lin-4                94       54.26
cel-mir-1                96       40.62
</code></pre>
</li>
<li>
<p>Use fx2tab and tab2fx in pipe</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx

$ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx
</code></pre>
</li>
<li>
<p>Sort sequences by length (use <code>seqkit sort -l</code>)</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit fx2tab -l \
    | sort -t"`echo -e '\t'`" -n -k4,4 \
    | seqkit tab2fx
&gt;cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop
UUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC
&gt;mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop
UGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU
&gt;cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop
ACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU

$ seqkit sort -l hairpin.fa.gz
</code></pre>
<p>Sorting or filtering by GC (or other base by -flag <code>-B</code>) content could also achieved in similar way.</p>
</li>
<li>
<p>Get first 1000 sequences (use <code>seqkit head -n 1000</code>)</p>
<pre><code>$ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx

$ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx
</code></pre>
</li>
</ol>
<p><strong>Extension</strong></p>
<p>After converting FASTA to tabular format with <code>seqkit fx2tab</code>,
it could be handled with CSV/TSV tools,
 e.g. <a href="https://github.com/shenwei356/csvtkt">csvtk</a>, a cross-platform, efficient and practical CSV/TSV toolkit</p>
<ul>
<li><code>csvtk grep</code> could be used to filter sequences (similar with <code>seqkit grep</code>)</li>
<li><code>csvtk inter</code>
computates intersection of multiple files. It could achieve similar function
as <code>seqkit common -n</code> along with shell.</li>
<li><code>csvtk join</code> joins multiple CSV/TSV files by multiple IDs.</li>
</ul>
<h2 id="convert">convert</h2>
<p>Usage</p>
<pre><code class="language-text">convert FASTQ quality encoding between Sanger, Solexa and Illumina

Usage:
  seqkit convert [flags]

Flags:
  -d, --dry-run                         dry run
  -f, --force                           for Illumina-1.8+ -&gt; Sanger, truncate scores &gt; 40 to 40
      --from string                     source quality encoding. if not given, we'll guess it
  -h, --help                            help for convert
  -n, --nrecords int                    number of records for guessing quality encoding (default 1000)
  -N, --thresh-B-in-n-most-common int   threshold of 'B' in top N most common quality for guessing
                                        Illumina 1.5. (default 2)
  -F, --thresh-illumina1.5-frac float   threshold of faction of Illumina 1.5 in the leading N records
                                        (default 0.1)
      --to string                       target quality encoding (default &quot;Sanger&quot;)
</code></pre>
<p>Examples:</p>
<p>Note that <code>seqkit convert</code> always output sequences.</p>
<p>The test dataset contains score 41 (<code>J</code>):</p>
<pre><code>$ seqkit head -n 1 tests/Illimina1.8.fq.gz
@ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA
NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG
+
#AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJJJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;
</code></pre>
<p>By default, nothing changes when converting Illumina 1.8 to Sanger. A warning message show that source and target quality encoding match.</p>
<pre><code>$ seqkit convert tests/Illimina1.8.fq.gz  | seqkit head -n 1
[INFO] possible quality encodings: [Illumina-1.8+]
[INFO] guessed quality encoding: Illumina-1.8+
[INFO] converting Illumina-1.8+ -&gt; Sanger
[WARN] source and target quality encoding match.
@ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA
NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG
+
#AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJJJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;
</code></pre>
<p>When switching flag <code>--force</code> on,  <code>J</code> (41) was converted to <code>I</code> (40).</p>
<pre><code>$ seqkit convert tests/Illimina1.8.fq.gz -f | seqkit head -n 1
[INFO] possible quality encodings: [Illumina-1.8+]
[INFO] guessed quality encoding: Illumina-1.8+
[INFO] converting Illumina-1.8+ -&gt; Sanger
@ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA
NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG
+
#AAAFAAIFFFIII&lt;IIIIIFFFIFIIIIIFIIAIIIFIIFIFIIIIFAFI&lt;IA&lt;FFI7FIIFIIAAIIII&lt;IIIIIIIFIIIAIIIIIFII77&lt;IIII-F7A-FIFFIIIIII&lt;FFI-&lt;7FIIIFII)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;
</code></pre>
<p>Other cases:</p>
<p>To Illumina-1.5.</p>
<pre><code>$ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1
[INFO] possible quality encodings: [Illumina-1.8+]
[INFO] guessed quality encoding: Illumina-1.8+
[INFO] converting Illumina-1.8+ -&gt; Illumina-1.5+
@ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA
NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG
+
B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iiiiieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[
</code></pre>
<p>To Illumina-1.5 and back to Sanger.</p>
<pre><code>$ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit convert | seqkit head -n 1
[INFO] possible quality encodings: [Illumina-1.8+]
[INFO] guessed quality encoding: Illumina-1.8+
[INFO] converting Illumina-1.8+ -&gt; Illumina-1.5+
[INFO] possible quality encodings: [Illumina-1.5+]
[INFO] guessed quality encoding: Illumina-1.5+
[INFO] converting Illumina-1.5+ -&gt; Sanger
@ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA
NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG
+
!AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJJJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;
</code></pre>
<p>Checking encoding</p>
<pre><code>$ seqkit convert tests/Illimina1.8.fq.gz --from Solexa
[INFO] converting Solexa -&gt; Sanger
[ERRO] seq: invalid Solexa quality
</code></pre>
<p>Real Illumina 1.5+ data</p>
<pre><code>$ seqkit seq tests/Illimina1.5.fq
@HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1
TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT
+
efcfffffcfeefffcffffffddf`feed]`]_Ba_^__[YBBBBBBBBBBRTT\]][]dddd`ddd^dddadd^BBBBBBBBBBBBBBBBBBBBBBBB

$ seqkit convert tests/Illimina1.5.fq | seqkit head -n 1
[INFO] possible quality encodings: [Illumina-1.5+]
[INFO] guessed quality encoding: Illumina-1.5+
[INFO] converting Illumina-1.5+ -&gt; Sanger
@HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1
TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT
+
FGDGGGGGDGFFGGGDGGGGGGEEGAGFFE&gt;A&gt;@!B@?@@&lt;:!!!!!!!!!!355=&gt;&gt;&lt;&gt;EEEEAEEE?EEEBEE?!!!!!!!!!!!!!!!!!!!!!!!!
</code></pre>
<h2 id="translate">translate</h2>
<p>Usage</p>
<pre><code class="language-text">translate DNA/RNA to protein sequence (supporting ambiguous bases)

Note:

  1. This command supports codons containing any ambiguous base.
     Please switch on flag -L INT for details. e.g., for standard table:

        ACN -&gt; T
        CCN -&gt; P
        CGN -&gt; R
        CTN -&gt; L
        GCN -&gt; A
        GGN -&gt; G
        GTN -&gt; V
        TCN -&gt; S

        MGR -&gt; R
        YTR -&gt; L

Translate Tables/Genetic Codes:

    # https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes

     1: The Standard Code
     2: The Vertebrate Mitochondrial Code
     3: The Yeast Mitochondrial Code
     4: The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code
     5: The Invertebrate Mitochondrial Code
     6: The Ciliate, Dasycladacean and Hexamita Nuclear Code
     9: The Echinoderm and Flatworm Mitochondrial Code
    10: The Euplotid Nuclear Code
    11: The Bacterial, Archaeal and Plant Plastid Code
    12: The Alternative Yeast Nuclear Code
    13: The Ascidian Mitochondrial Code
    14: The Alternative Flatworm Mitochondrial Code
    16: Chlorophycean Mitochondrial Code
    21: Trematode Mitochondrial Code
    22: Scenedesmus obliquus Mitochondrial Code
    23: Thraustochytrium Mitochondrial Code
    24: Pterobranchia Mitochondrial Code
    25: Candidate Division SR1 and Gracilibacteria Code
    26: Pachysolen tannophilus Nuclear Code
    27: Karyorelict Nuclear
    28: Condylostoma Nuclear
    29: Mesodinium Nuclear
    30: Peritrich Nuclear
    31: Blastocrithidia Nuclear

Usage:
  seqkit translate [flags]

Flags:
  -x, --allow-unknown-codon                     translate unknown code to 'X'. And you may not use flag
                                                --trim which removes 'X'
  -F, --append-frame                            append frame information to sequence ID
      --clean                                   change all STOP codon positions from the '*' character
                                                to 'X' (an unknown residue)
  -f, --frame strings                           frame(s) to translate, available value: 1, 2, 3, -1, -2,
                                                -3, and 6 for all six frames (default [1])
  -h, --help                                    help for translate
  -M, --init-codon-as-M                         translate initial codon at beginning to 'M'
  -l, --list-transl-table int                   show details of translate table N, 0 for all (default -1)
  -L, --list-transl-table-with-amb-codons int   show details of translate table N (including ambigugous
                                                codons), 0 for all.  (default -1)
  -m, --min-len int                             the minimum length of amino acid sequence
  -s, --out-subseqs                             output individual amino acid subsequences seperated by
                                                the stop symbol &quot;*&quot;
  -T, --transl-table int                        translate table/genetic code, type 'seqkit translate
                                                --help' for more details (default 1)
      --trim                                    remove all 'X' and '*' characters from the right end of
                                                the translation

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>common usage</p>
<pre><code>$ seqkit translate tests/mouse-p53-cds.fna
&gt;lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]
MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA
LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM
CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS
DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM
GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS
AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR
AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD*
</code></pre>
</li>
<li>
<p>trim the <code>*</code></p>
<pre><code>$ seqkit translate tests/mouse-p53-cds.fna --trim
&gt;lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]
MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA
LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM
CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS
DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM
GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS
AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR
AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD
</code></pre>
</li>
<li>
<p>different translate table</p>
<pre><code>$ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \
    | seqkit translate -T 11 --trim
&gt;CAC80166.1 hypothetical protein [Lactococcus phage BK5-T]
MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT
LAVTVIGYLFTKIRF
</code></pre>
</li>
<li>
<p>different frame</p>
<pre><code>$ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \
    | seqkit translate -T 11 --frame -1
&gt;CAC80166.1 hypothetical protein [Lactococcus phage BK5-T]
SESNFSE*ITNNSYGKSKHKAPSPLIISFHFFYKFRI*LSY*ERSFCFISNCFIVI*LCF
NSS*TFEDFSPCLFLH

$ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \
    | seqkit seq -r -p \
    | seqkit translate -T 11 --frame -1
&gt;CAC80166.1 hypothetical protein [Lactococcus phage BK5-T]
MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT
LAVTVIGYLFTKIRF*
</code></pre>
</li>
<li>
<p>show details of translate table 1</p>
<pre><code>$ seqkit translate -l 1
The Standard Code (transl_table=1)
Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1

Initiation Codons:
    ATG, CTG, TTG

Stop Codons:
    TAA, TAG, TGA

Stranslate Table:
    AAA: K, AAC: N, AAG: K, AAT: N
    ACA: T, ACC: T, ACG: T, ACT: T
    AGA: R, AGC: S, AGG: R, AGT: S
    ATA: I, ATC: I, ATG: M, ATT: I

    CAA: Q, CAC: H, CAG: Q, CAT: H
    CCA: P, CCC: P, CCG: P, CCT: P
    CGA: R, CGC: R, CGG: R, CGT: R
    CTA: L, CTC: L, CTG: L, CTT: L

    GAA: E, GAC: D, GAG: E, GAT: D
    GCA: A, GCC: A, GCG: A, GCT: A
    GGA: G, GGC: G, GGG: G, GGT: G
    GTA: V, GTC: V, GTG: V, GTT: V

    TAA: *, TAC: Y, TAG: *, TAT: Y
    TCA: S, TCC: S, TCG: S, TCT: S
    TGA: *, TGC: C, TGG: W, TGT: C
    TTA: L, TTC: F, TTG: L, TTT: F
</code></pre>
</li>
<li>
<p>show details of translate table 1, including ambigugous codons</p>
<pre><code>$ seqkit translate -L 1
The Standard Code (transl_table=1)
Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1

Initiation Codons:
    ATG, CTG, TTG

Stop Codons:
    TAA, TAG, TGA

Stranslate Table:
    AAA: K, AAC: N, AAG: K, AAR: K, AAT: N, AAY: N
    ACA: T, ACC: T, ACM: T, ACG: T, ACR: T, ACS: T, ACV: T, ACT: T, ACW: T, ACY: T, ACH: T, ACK: T, ACD: T, ACB: T, ACN: T
    AGA: R, AGC: S, AGG: R, AGR: R, AGT: S, AGY: S
    ATA: I, ATC: I, ATM: I, ATG: M, ATT: I, ATW: I, ATY: I, ATH: I

    CAA: Q, CAC: H, CAG: Q, CAR: Q, CAT: H, CAY: H
    CCA: P, CCC: P, CCM: P, CCG: P, CCR: P, CCS: P, CCV: P, CCT: P, CCW: P, CCY: P, CCH: P, CCK: P, CCD: P, CCB: P, CCN: P
    CGA: R, CGC: R, CGM: R, CGG: R, CGR: R, CGS: R, CGV: R, CGT: R, CGW: R, CGY: R, CGH: R, CGK: R, CGD: R, CGB: R, CGN: R
    CTA: L, CTC: L, CTM: L, CTG: L, CTR: L, CTS: L, CTV: L, CTT: L, CTW: L, CTY: L, CTH: L, CTK: L, CTD: L, CTB: L, CTN: L

    MGA: R, MGG: R, MGR: R

    GAA: E, GAC: D, GAG: E, GAR: E, GAT: D, GAY: D
    GCA: A, GCC: A, GCM: A, GCG: A, GCR: A, GCS: A, GCV: A, GCT: A, GCW: A, GCY: A, GCH: A, GCK: A, GCD: A, GCB: A, GCN: A
    GGA: G, GGC: G, GGM: G, GGG: G, GGR: G, GGS: G, GGV: G, GGT: G, GGW: G, GGY: G, GGH: G, GGK: G, GGD: G, GGB: G, GGN: G
    GTA: V, GTC: V, GTM: V, GTG: V, GTR: V, GTS: V, GTV: V, GTT: V, GTW: V, GTY: V, GTH: V, GTK: V, GTD: V, GTB: V, GTN: V

    TAA: *, TAC: Y, TAG: *, TAR: *, TAT: Y, TAY: Y
    TCA: S, TCC: S, TCM: S, TCG: S, TCR: S, TCS: S, TCV: S, TCT: S, TCW: S, TCY: S, TCH: S, TCK: S, TCD: S, TCB: S, TCN: S
    TGA: *, TGC: C, TGG: W, TGT: C, TGY: C
    TRA: *
    TTA: L, TTC: F, TTG: L, TTR: L, TTT: F, TTY: F

    YTA: L, YTG: L, YTR: L
</code></pre>
</li>
</ol>
<h2 id="grep">grep</h2>
<p>Usage</p>
<pre><code class="language-text">search sequences by ID/name/sequence/sequence motifs, mismatch allowed

Attention:

  0. By default, we match sequence ID with patterns, use &quot;-n/--by-name&quot;
     for matching full name instead of just ID.
  1. Unlike POSIX/GNU grep, we compare the pattern to the whole target
     (ID/full header) by default. Please switch &quot;-r/--use-regexp&quot; on
     for partly matching.
  2. When searching by sequences, it's partly matching, and both positive
     and negative strands are searched.
     Please switch on &quot;-P/--only-positive-strand&quot; if you would like to
     search only on the positive strand.
     Mismatch is allowed using flag &quot;-m/--max-mismatch&quot;, you can increase
     the value of &quot;-j/--threads&quot; to accelerate processing.
  3. Degenerate bases/residues like &quot;RYMM..&quot; are also supported by flag -d.
     But do not use degenerate bases/residues in regular expression, you need
     convert them to regular expression, e.g., change &quot;N&quot; or &quot;X&quot;  to &quot;.&quot;.
  4. When providing search patterns (motifs) via flag '-p',
     please use double quotation marks for patterns containing comma,
     e.g., -p '&quot;A{2,}&quot;' or -p &quot;\&quot;A{2,}\&quot;&quot;. Because the command line argument
     parser accepts comma-separated-values (CSV) for multiple values (motifs).
     Patterns in file do not follow this rule.
  5. The order of sequences in result is consistent with that in original
     file, not the order of the query patterns.
     But for FASTA file, you can use:
        seqkit faidx seqs.fasta --infile-list IDs.txt
  6. For multiple patterns, you can either set &quot;-p&quot; multiple times, i.e.,
     -p pattern1 -p pattern2, or give a file of patterns via &quot;-f/--pattern-file&quot;.

You can specify the sequence region for searching with the flag -R (--region).
The definition of region is 1-based and with some custom design.

Examples:

 1-based index    1 2 3 4 5 6 7 8 9 10
negative index    0-9-8-7-6-5-4-3-2-1
           seq    A C G T N a c g t n
           1:1    A
           2:4      C G T
         -4:-2                c g t
         -4:-1                c g t n
         -1:-1                      n
          2:-2      C G T N a c g t
          1:-1    A C G T N a c g t n
          1:12    A C G T N a c g t n
        -12:-1    A C G T N a c g t n

Usage:
  seqkit grep [flags]

Flags:
  -D, --allow-duplicated-patterns   output records multiple times when duplicated patterns are given
  -n, --by-name                     match by full name instead of just ID
  -s, --by-seq                      search subseq on seq. Both positive and negative strand are searched
                                    by default, you might use -P/--only-positive-strand. Mismatch
                                    allowed using flag -m/--max-mismatch
  -c, --circular                    circular genome
  -C, --count                       just print a count of matching records. with the -v/--invert-match
                                    flag, count non-matching records
  -d, --degenerate                  pattern/motif contains degenerate base
      --delete-matched              delete a pattern right after being matched, this keeps the firstly
                                    matched data and speedups when using regular expressions
  -h, --help                        help for grep
  -i, --ignore-case                 ignore case
  -I, --immediate-output            print output immediately, do not use write buffer
  -v, --invert-match                invert the sense of matching, to select non-matching records
  -m, --max-mismatch int            max mismatch when matching by seq. For large genomes like human
                                    genome, using mapping/alignment tools would be faster
  -P, --only-positive-strand        only search on the positive strand
  -p, --pattern strings             search pattern (multiple values supported. Attention: use double
                                    quotation marks for patterns containing comma, e.g., -p '&quot;A{2,}&quot;')
  -f, --pattern-file string         pattern file (one record per line)
  -R, --region string               specify sequence region for searching. e.g 1:12 for first 12 bases,
                                    -12:-1 for last 12 bases
  -r, --use-regexp                  patterns are regular expression

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Searching with list of sequence IDs (do not contain whitespace)</p>
<pre><code>$ seqkit grep -f id.txt seqs.fq.gz -o result.fq.gz

# ignore case
$ seqkit grep -i -f id.txt seqs.fq.gz -o result.fq.gz
</code></pre>
</li>
<li>
<p>Just print the matched number, like GNU grep (<code>grep -c</code>) </p>
<pre><code>$ seqkit grep -f id.txt seqs.fq.gz -C
</code></pre>
</li>
<li>
<p>Serching non-canonical sequence IDs, Using <code>--id-regexp</code> to capture IDs. 
   Refer to <a href="#sequence-id">section Sequence ID</a> and <a href="#seq">seqkit seq</a> for examples.</p>
</li>
<li>
<p>Searching with list of sequence names (they may contain whitespace).</p>
<pre><code>$ seqkit grep -n -f name.txt seqs.fa.gz -o result.fa.gz
</code></pre>
</li>
<li>
<p>Useq <code>-r/--use-regexp</code> for partly matching, but <strong>this may produce "false positive" matches</strong>.
   For example, <code>seq_1</code> matches <code>seq_10</code> with <code>-nri</code>.</p>
</li>
<li>
<p>Extract human hairpins (i.e. sequences with name starting with <code>hsa</code>)</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa
&gt;hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop
UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU
ACAAUCUACUGUCUUUCCUA
&gt;hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop
AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU
CCUAGCUUUCCU
</code></pre>
</li>
<li>
<p>Remove human and mice hairpins (invert match with <code>-v</code>)</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v
</code></pre>
</li>
<li>
<p>Extract new entries by information from miRNA.diff.gz</p>
<ol>
<li>
<p>Get IDs of new entries.</p>
<pre><code>$ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 &gt; list
$ more list
cfa-mir-486
cfa-mir-339-1
pmi-let-7
</code></pre>
</li>
<li>
<p>Extract by ID list file</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -f list &gt; new.fa
</code></pre>
</li>
</ol>
</li>
<li>
<p>Extract sequences containing AGGCG</p>
<pre><code>$ cat hairpin.fa.gz | seqkit grep -s -i -p aggcg
</code></pre>
</li>
<li>
<p>Circular genome</p>
<pre><code>$ echo -e "&gt;seq\nACGTTGCA" 
&gt;seq
ACGTTGCA

$ echo -e "&gt;seq\nACGTTGCA"  | seqkit grep -s -i -p AA

$ echo -e "&gt;seq\nACGTTGCA"  | seqkit grep -s -i -p AA -c
&gt;seq
ACGTTGCA
</code></pre>
</li>
<li>
<p>Extract sequences containing AGGCG (allow mismatch)</p>
<pre><code>$ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA      1,181  145,789       49    123.4    2,354

real    0m0.058s
user    0m0.100s
sys     0m0.017s

$ time zcat hairpin.fa.gz | seqkit grep -s -i -p aggcg -m 1 | seqkit stats
file  format  type  num_seqs    sum_len  min_len  avg_len  max_len
-     FASTA   RNA     22,290  2,375,819       39    106.6    2,354

real    0m1.081s
user    0m1.305s
sys     0m0.158s
</code></pre>
</li>
<li>
<p>Extract sequences starting with AGGCG</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg
</code></pre>
</li>
<li>
<p>Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G.</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA
</code></pre>
<p>It's equal to but simpler than:</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA
</code></pre>
</li>
<li>
<p>Specify sequence regions for searching. e.g., leading 30 bases.</p>
<pre><code>$ seqkit grep -s -R 1:30 -i -r -p GCTGG
</code></pre>
</li>
</ol>
<h2 id="locate">locate</h2>
<p>Usage</p>
<pre><code class="language-text">locate subsequences/motifs, mismatch allowed

Attention:

  1. Motifs could be EITHER plain sequence containing &quot;ACTGN&quot; OR regular
     expression like &quot;A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)&quot; for ORFs.     
  2. Degenerate bases/residues like &quot;RYMM..&quot; are also supported by flag -d.
     But do not use degenerate bases/residues in regular expression, you need
     convert them to regular expression, e.g., change &quot;N&quot; or &quot;X&quot;  to &quot;.&quot;.
  3. When providing search patterns (motifs) via flag '-p',
     please use double quotation marks for patterns containing comma, 
     e.g., -p '&quot;A{2,}&quot;' or -p &quot;\&quot;A{2,}\&quot;&quot;. Because the command line argument
     parser accepts comma-separated-values (CSV) for multiple values (motifs).
     Patterns in file do not follow this rule.     
  4. Mismatch is allowed using flag &quot;-m/--max-mismatch&quot;,
     you can increase the value of &quot;-j/--threads&quot; to accelerate processing.
  5. When using flag --circular, end position of matched subsequence that 
     crossing genome sequence end would be greater than sequence length.

Usage:
  seqkit locate [flags]

Flags:
      --bed                    output in BED6 format
  -c, --circular               circular genome. type &quot;seqkit locate -h&quot; for details
  -d, --degenerate             pattern/motif contains degenerate base
      --gtf                    output in GTF format
  -h, --help                   help for locate
  -M, --hide-matched           do not show matched sequences
  -i, --ignore-case            ignore case
  -I, --immediate-output       print output immediately, do not use write buffer
  -s, --max-len-to-show int    show at most X characters for the search pattern or matched sequences
  -m, --max-mismatch int       max mismatch when matching by seq. For large genomes like human genome,
                               using mapping/alignment tools would be faster
  -G, --non-greedy             non-greedy mode, faster but may miss motifs overlapping with others
  -P, --only-positive-strand   only search on positive strand
  -p, --pattern strings        pattern/motif (multiple values supported. Attention: use double quotation
                               marks for patterns containing comma, e.g., -p '&quot;A{2,}&quot;')
  -f, --pattern-file string    pattern/motif file (FASTA format)
  -F, --use-fmi                use FM-index for much faster search of lots of sequence patterns
  -r, --use-regexp             patterns/motifs are regular expression

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Locating subsequences (mismatch allowed)</p>
<pre><code>$ cat t.fa
&gt;seq
agctggagctacc

$ cat t.fa \
  | seqkit locate -p agc \
  | csvtk pretty -t
seqID   patternName   pattern   strand   start   end   matched
seq     agc           agc       +        1       3     agc
seq     agc           agc       +        7       9     agc
seq     agc           agc       -        8       10    agc
seq     agc           agc       -        2       4     agc

# do not show matched sequences
$ cat t.fa \
  | seqkit locate -p agc -M \
  | csvtk pretty -t
seqID   patternName   pattern   strand   start   end
seq     agc           agc       +        1       3
seq     agc           agc       +        7       9
seq     agc           agc       -        8       10
seq     agc           agc       -        2       4

# max mismatch: 1
$ cat t.fa \
  | seqkit locate -p agc -m 1 \
  | csvtk pretty -t
seqID   patternName     pattern strand  start   end    matched
seq     agc           agc       +        1       3     agc
seq     agc           agc       +        7       9     agc
seq     agc           agc       +        11      13    acc
seq     agc           agc       -        8       10    agc
seq     agc           agc       -        2       4     agc

# max mismatch: 2
$ cat t.fa \
  | seqkit locate -p agc -m 2 \
  | csvtk pretty -t
seqID   patternName   pattern   strand   start   end   matched
seq     agc           agc       +        1       3     agc
seq     agc           agc       +        4       6     tgg
seq     agc           agc       +        5       7     gga
seq     agc           agc       +        7       9     agc
seq     agc           agc       +        10      12    tac
seq     agc           agc       +        11      13    acc
seq     agc           agc       -        11      13    ggt
seq     agc           agc       -        8       10    agc
seq     agc           agc       -        6       8     ctc
seq     agc           agc       -        5       7     tcc
seq     agc           agc       -        2       4     agc
</code></pre>
</li>
<li>
<p>Locate ORFs.</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit locate -i -p "A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)" -r \
    | head -n 4 \
    | csvtk pretty -t
seqID       patternName                        pattern                            strand   start   end   matched
cel-lin-4   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   +        1       36    AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA
cel-mir-1   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   +        54      95    AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG
cel-mir-1   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)   -        43      51    AUGAUAUAG
</code></pre>
</li>
<li>
<p>Locate Motif.</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit locate -i -d -p AUGGACUN \
    | head -n 4 \
    | csvtk pretty -t 
seqID         patternName   pattern    strand   start   end   matched
cel-mir-58a   AUGGACUN      AUGGACUN   +        81      88    AUGGACUG
ath-MIR163    AUGGACUN      AUGGACUN   -        122     129   AUGGACUC
cel-mir-270   AUGGACUN      AUGGACUN   +        84      91    AUGGACUG
</code></pre>
</li>
<li>
<p>Output in <code>GTF</code> or <code>BED6</code> format, which you can use in <code>seqkit subseq</code></p>
<pre><code>$ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --bed
cel-mir-58a     80      88      AUGGACUN        0       +
ath-MIR163      121     129     AUGGACUN        0       -

$ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --gtf
cel-mir-58a     SeqKit  location        81      88      0       +       .       gene_id "AUGGACUN";
ath-MIR163      SeqKit  location        122     129     0       -       .       gene_id "AUGGACUN";
</code></pre>
</li>
<li>
<p>Greedy mode (default)</p>
<pre><code> $ echo -e '&gt;seq\nACGACGACGA' | seqkit locate -p ACGA | csvtk -t pretty
 seqID   patternName   pattern   strand   start   end   matched
 seq     ACGA          ACGA      +        1       4     ACGA
 seq     ACGA          ACGA      +        4       7     ACGA
 seq     ACGA          ACGA      +        7       10    ACGA
</code></pre>
</li>
<li>
<p>Non-greedy mode (<code>-G</code>)</p>
<pre><code>$ echo -e '&gt;seq\nACGACGACGA' | seqkit locate -p ACGA -G | csvtk -t pretty
seqID   patternName   pattern   strand   start   end   matched
seq     ACGA          ACGA      +        1       4     ACGA
seq     ACGA          ACGA      +        7       10    ACGA
</code></pre>
</li>
<li>
<p>Circular genome. Note that end position of matched subsequence that 
crossing genome sequence end would be greater than sequence length.</p>
<pre><code>$ echo -e "&gt;seq\nACGTTGCA"
&gt;seq
ACGTTGCA

$ echo -e "&gt;seq\nACGTTGCA" \
    | seqkit locate -i -p aa
seqID   patternName     pattern strand  start   end     matched
seq     aa      aa      -       4       5       aa

$ echo -e "&gt;seq\nACGTTGCA" \
    | seqkit locate -i -p aa -c \
    | csvtk pretty -t
seqID   patternName   pattern   strand   start   end   matched
seq     aa            aa        +        8       9     aa
seq     aa            aa        -        4       5     aa
</code></pre>
</li>
</ol>
<h2 id="fish">fish</h2>
<p>Usage</p>
<pre><code class="language-text">look for short sequences in larger sequences using local alignment

Attention:
  1. output coordinates are BED-like 0-based, left-close and right-open.
  2. alignment information are printed to STDERR.

Usage:
  seqkit fish [flags]

Flags:
  -a, --all                      search all
  -p, --aln-params string        alignment parameters in format
                                 &quot;&lt;match&gt;,&lt;mismatch&gt;,&lt;gap_open&gt;,&lt;gap_extend&gt;&quot; (default &quot;4,-4,-2,-1&quot;)
  -h, --help                     help for fish
  -i, --invert                   print out references not matching with any query
  -q, --min-qual float           minimum mapping quality (default 5)
  -b, --out-bam string           save aligmnets to this BAM file (memory intensive)
  -x, --pass                     pass through mode (write input to stdout)
  -g, --print-aln                print sequence alignments
  -D, --print-desc               print full sequence header
  -f, --query-fastx string       query fasta
  -F, --query-sequences string   query sequences
  -r, --ranges string            target ranges, for example: &quot;:10,30:40,-20:&quot;
  -s, --stranded                 search + strand only
  -v, --validate-seq             validate bases according to the alphabet

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Find best local alignment of a short sequence in reads in a fasta file, print results as tabular</p>
<pre><code>$ seqkit fish -q 4.7 -F GGCGGCTGTGACC -g mouse-p53-cds.fna
</code></pre>
</li>
<li>
<p>Compare to <code>seqkit locate</code>:</p>
<pre><code>$ echo -e '&gt;seq\nACGACGACGA' \
    | seqkit locate -p ACGA -G | csvtk -t pretty
seqID   patternName   pattern   strand   start   end   matched
seq     ACGA          ACGA      +        1       4     ACGA
seq     ACGA          ACGA      +        7       10    ACGA

$ echo -e '&gt;seq\nACGACGACGA' \
    | seqkit fish -F ACGA -a 2&gt;&amp;1 | csvtk -t pretty 
Ref   RefStart   RefEnd   Query   QueryStart   QueryEnd   Strand   MapQual   RawScore   Acc      ClipAcc   QueryCov
seq   6          10       q0      0            4          +        60.00     16         100.00   100.00    100.00
seq   0          4        q0      0            4          +        60.00     16         100.00   100.00    100.00
</code></pre>
</li>
<li>
<p>Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM</p>
<pre><code>seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna
</code></pre>
</li>
</ol>
<h2 id="amplicon">amplicon</h2>
<p>Usage</p>
<pre><code class="language-text">extract amplicon (or specific region around it) via primer(s).

Attention:
  1. Only one (the longest) matching location is returned for every primer pair.
  2. Mismatch is allowed, but the mismatch location (5' or 3') is not controled. 
     You can increase the value of &quot;-j/--threads&quot; to accelerate processing.
  3. Degenerate bases/residues like &quot;RYMM..&quot; are also supported.
     But do not use degenerate bases/residues in regular expression, you need
     convert them to regular expression, e.g., change &quot;N&quot; or &quot;X&quot;  to &quot;.&quot;.

Examples:
  0. no region given.

                    F
        -----===============-----
             F             R
        -----=====-----=====-----

             ===============         amplicon

  1. inner region (-r x:y).

                    F
        -----===============-----
             1 3 5                    x/y
                      -5-3-1          x/y
             F             R
        -----=====-----=====-----     x:y

             ===============          1:-1
             =======                  1:7
               =====                  3:7
                  =====               6:10
                  =====             -10:-6
                     =====           -7:-3
                                     -x:y (invalid)

  2. flanking region (-r x:y -f)

                    F
        -----===============-----
         -3-1                        x/y
                            1 3 5    x/y
             F             R
        -----=====-----=====-----

        =====                        -5:-1
        ===                          -5:-3
                            =====     1:5
                              ===     3:5
            =================        -1:1
        =========================    -5:5
                                      x:-y (invalid)

Usage:
  seqkit amplicon [flags]

Flags:
      --bed                    output in BED6+1 format with amplicon as the 7th column
  -f, --flanking-region        region is flanking region
  -F, --forward string         forward primer (5'-primer-3'), degenerate bases allowed
  -h, --help                   help for amplicon
  -I, --immediate-output       print output immediately, do not use write buffer
  -m, --max-mismatch int       max mismatch when matching primers, no degenerate bases allowed
  -P, --only-positive-strand   only search on positive strand
  -M, --output-mismatches      append the total mismatches and mismatches of 5' end and 3' end
  -p, --primer-file string     3- or 2-column tabular primer file, with first column as primer name
  -r, --region string          specify region to return. type &quot;seqkit amplicon -h&quot; for detail
  -R, --reverse string         reverse primer (5'-primer-3'), degenerate bases allowed
  -u, --save-unmatched         also save records that do not match any primer
  -s, --strict-mode            strict mode, i.e., discarding seqs not fully matching (shorter) given
                               region range

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>No region given.</p>
<pre><code>$ echo -ne "&gt;seq\nacgcccactgaaatga\n" 
&gt;seq
acgcccactgaaatga

$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt
&gt;seq
cccactgaaa

$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt

# BED6+1
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt --bed
seq     3       13      .       0       +       cccactgaaa

# supporting degenerate bases.
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccR -R ttt --bed
seq     4       13      .       0       +       ccactgaaa
</code></pre>
</li>
<li>
<p>Output mismatches:</p>
<pre><code>$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -M
&gt;seq mismatches=0(0+0)
cccactgaaa

$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -m 1 -M
&gt;seq mismatches=2(1+1)
cgcccactgaaat

$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -m 1 -M --bed
seq     1       14      .       0       +       cgcccactgaaat   2       1       1
</code></pre>
</li>
<li>
<p>Load primers from 3- or 2-column tabular primer file, with first column as primer name.</p>
<pre><code>$ cat seqs4amplicon.fa 
&gt;seq1
ACGCCCACTGAAATGA
&gt;seq2
ACGTACGGTCAGATCCA

$ cat primers.tsv 
p1      ccc     ttt
p2      ttt     ccc
p3      ttt

p4      CG      TG
P5      CG      GA

# containing degenerate bases
p6      TRC     WGG

$ cat seqs4amplicon.fa | seqkit amplicon -p primers.tsv --bed
seq1    3       13      p1      0       +       CCCACTGAAA
seq1    1       7       p4      0       +       CGCCCA
seq1    3       13      p2      0       -       TTTCAGTGGG
seq1    10      13      p3      0       -       TTT
seq2    1       17      p4      0       +       CGTACGGTCAGATCCA
seq2    1       15      P5      0       +       CGTACGGTCAGATC
seq2    3       17      p6      0       +       TACGGTCAGATCCA
</code></pre>
</li>
<li>
<p>Inner region</p>
<pre><code># region right behind forward primer
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -r 4:7
&gt;seq
actg

# BED
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -r 4:7 --bed
seq     6       10      .       0       +       actg

# more common case is triming primers
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -R ttt -r 4:-4
&gt;seq
actg
</code></pre>
</li>
<li>
<p>flanking region</p>
<pre><code># in one of my sequencing data, I only care about 
# region downstream of forward primer
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -f -r 3:6
&gt;seq
tgaa

$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F ccc -f -r 3:6 --bed
seq     8       12      .       0       +       tgaa

# if given region if out scope of sequence. e.g,
# 2-5bp downstream of aaa, we can get part of region (2-4) by default
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F aaa -f -r 2:5
&gt;seq
ga

# you can also use strict mode to discard those cases
$ echo -ne "&gt;seq\nacgcccactgaaatga\n" \
    | seqkit amplicon -F aaa -f -r 2:5 -s
</code></pre>
</li>
</ol>
<h2 id="duplicate">duplicate</h2>
<p>Usage</p>
<pre><code class="language-text">duplicate sequences N times

You may need &quot;seqkit rename&quot; to make the the sequence IDs unique.

Usage:
  seqkit duplicate [flags]

Aliases:
  duplicate, dup

Flags:
  -h, --help        help for duplicate
  -n, --times int   duplication number (default 1)

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Data</p>
<pre><code>$ cat tests/hairpin.fa | seqkit head -n 1
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
</code></pre>
</li>
<li>
<p>Duplicate 2 times</p>
<pre><code>$ cat tests/hairpin.fa | seqkit head -n 1 \
    | seqkit duplicate -n 2
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
</code></pre>
</li>
<li>
<p>use <code>seqkit rename</code> to make the the sequence IDs unique.</p>
<pre><code>$ cat tests/hairpin.fa | seqkit head -n 1 \
    | seqkit duplicate -n 2 | seqkit rename
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
&gt;cel-let-7_2 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
</code></pre>
</li>
</ol>
<h2 id="rmdup">rmdup</h2>
<p>Usage</p>
<pre><code class="language-text">remove duplicated sequences by ID/name/sequence

Attention:
  1. When comparing by sequences, both positive and negative strands are
     compared. Switch on -P/--only-positive-strand for considering the
     positive strand only.
  2. Only the first record is saved for duplicates.

Usage:
  seqkit rmdup [flags]

Flags:
  -n, --by-name                by full name instead of just id
  -s, --by-seq                 by seq
  -D, --dup-num-file string    file to save numbers and ID lists of duplicated seqs
  -d, --dup-seqs-file string   file to save duplicated seqs
  -h, --help                   help for rmdup
  -i, --ignore-case            ignore case
  -P, --only-positive-strand   only considering positive strand when comparing by sequence

</code></pre>
<p>Examples</p>
<p>Similar to <code>common</code>.</p>
<ol>
<li>
<p>General use</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz
[INFO] 2226 duplicated records removed

$ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz
[INFO] 1086 duplicated records removed
</code></pre>
</li>
<li>
<p>Save duplicated sequences to file</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit rmdup -s -i -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt

$ cat duplicated.detail.txt   # here is not the entire list
3   hsa-mir-424, mml-mir-424, ppy-mir-424
3   hsa-mir-342, mml-mir-342, ppy-mir-342
2   ngi-mir-932, nlo-mir-932
2   ssc-mir-9784-1, ssc-mir-9784-2
</code></pre>
</li>
</ol>
<h2 id="common">common</h2>
<p>Usage</p>
<pre><code class="language-text">find common sequences of multiple files by id/name/sequence

Note:
  1. 'seqkit common' is designed to support 2 and MORE files.
  2. When comparing by sequences,
     a) Both positive and negative strands are compared. You can switch on
        -P/--only-positive-strand for considering the positive strand only.
     b) You can switch on -e/--check-embedded-seqs to check embedded sequences.
          e.g, for file A and B, the reverse complement sequence of CCCC from file B
          is a part of TTGGGGTT from file A, we will extract and output GGGG from file A.
          If sequences CCC exist in other files except file A, we will skip it,
          as it is an embedded subsequence of GGGG.
        It is recommended to put the smallest file as the first file, for saving
        memory usage.
  3. For 2 files, 'seqkit grep' is much faster and consumes lesser memory:
       seqkit grep -f &lt;(seqkit seq -n -i small.fq.gz) big.fq.gz # by seq ID
     But note that searching by sequence would be much slower, as it's partly
     string matching.
       seqkit grep -s -f &lt;(seqkit seq -s small.fq.gz) big.fq.gz # much slower!!!!
  4. Some records in one file may have same sequences/IDs. They will ALL be
     retrieved if the sequence/ID was shared in multiple files.
     So the records number may be larger than that of the smallest file.

Usage:
  seqkit common [flags]

Flags:
  -n, --by-name                match by full name instead of just id
  -s, --by-seq                 match by sequence
  -e, --check-embedded-seqs    check embedded sequences, e.g., if a sequence is part of another one,
                               we'll keep the shorter one
  -h, --help                   help for common
  -i, --ignore-case            ignore case
  -P, --only-positive-strand   only considering the positive strand when comparing by sequence

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>By ID (default)</p>
<pre><code>seqkit common file*.fa -o common.fasta
</code></pre>
</li>
<li>
<p>By full name</p>
<pre><code>seqkit common file*.fa -n -o common.fasta
</code></pre>
</li>
<li>
<p>By sequence</p>
<pre><code>seqkit common file*.fa -s -i -o common.fasta

# seqkit common file*.fa -s -i -o common.fasta
seqkit common file*.fa -s -i -o common.fasta -P
</code></pre>
</li>
<li>
<p>Since v2.6.0, we can use the new flag <code>-e/--check-embedded-seqs</code> to detect embedded sequences.</p>
<pre><code>$ cat common_a.fasta
&gt;A_a
ACTTTGA
&gt;A_b
ACC
&gt;A_c
GGG
&gt;A_d
CCCCCCCCCCCCC
&gt;A_c1
AGGGCCC
&gt;A_x
gggg
&gt;A_y
ACGTAC

$ cat common_b.fasta
&gt;B_a
AAA
&gt;B_b
GGT
&gt;B_c
AGGGCC
&gt;B_e
ACCCCCGGGAACC
&gt;B_z
TTT

$ cat common_c.fasta
&gt;C_a
ACTTTGA
&gt;C_b
ACC
&gt;C_c
GGG
&gt;C_d
CCCCCCCCCCCCC
&gt;C_c1
AGGGCCC
&gt;C_x
gggg
&gt;C_y
ACGTAC

# excactly same sequences

$ seqkit common -s -i common_a.fasta common_b.fasta common_c.fasta
[INFO] read file 1/3: common_a.fasta
[INFO] read file 2/3: common_b.fasta
[INFO] read file 3/3: common_c.fasta
[INFO] find common seqs ...
[INFO] 1 unique sequences found in 3 files, which belong to 1 records in the first file: common_a.fasta
[INFO] retrieve 1 seqs from the first file: common_a.fasta
&gt;A_b
ACC

# with -e

$ seqkit common -s -i common_a.fasta common_b.fasta common_c.fasta -e
[INFO] read file 1/3: common_a.fasta
[INFO]   7 seqs loaded
[INFO] read file 2/3: common_b.fasta
[INFO]   5 seqs left
[INFO] read file 3/3: common_c.fasta
[INFO]   5 seqs left
[INFO] 5 unique sequences found in 3 files, which belong to 5 records in the first file: common_a.fasta
[INFO] 5 common/shared sequences saved to: -
&gt;A_a:3-5
TTT
&gt;A_b
ACC
&gt;A_c
GGG
&gt;A_c1:1-6
AGGGCC
&gt;A_x
gggg

# change the order of file, the sequences are the same

$ seqkit common -s -i common_c.fasta common_b.fasta common_a.fasta -e
[INFO] read file 1/3: common_c.fasta
[INFO]   7 seqs loaded
[INFO] read file 2/3: common_b.fasta
[INFO]   5 seqs left
[INFO] read file 3/3: common_a.fasta
[INFO]   5 seqs left
[INFO] 5 unique sequences found in 3 files, which belong to 5 records in the first file: common_c.fasta
[INFO] 5 common/shared sequences saved to: -
&gt;C_a:3-5
TTT
&gt;C_b
ACC
&gt;C_c
GGG
&gt;C_c1:1-6
AGGGCC
&gt;C_x
gggg
</code></pre>
</li>
</ol>
<h2 id="split">split</h2>
<p>Usage</p>
<pre><code class="language-text">split sequences into files by name ID, subsequence of given region,
part size or number of parts.

If you just want to split by parts or sizes, please use &quot;seqkit split2&quot;,
which can apply to paired- and single-end FASTQ.

If you want to cut a sequence into multiple segments.
  1. For cutting into even chunks, please use 'kmcp utils split-genomes'
     (https://bioinf.shenwei.me/kmcp/usage/#split-genomes).
     E.g., cutting into 4 segments of equal size, with no overlap between adjacent segments:
        kmcp utils split-genomes -m 1 -k 1 --split-number 4 --split-overlap 0 input.fasta -O out
  2. For cutting into multiple chunks of fixed size, please using 'seqkit sliding'.
     E.g., cutting into segments of 40 bp and keeping the last segment which can be shorter than 40 bp.
        seqkit sliding -g -s 40 -W 40 input.fasta -o out.fasta

Attention:
  1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to
     ensure the .fai file matches the FASTA file.

The definition of region is 1-based and with some custom design.

Examples:

 1-based index    1 2 3 4 5 6 7 8 9 10
negative index    0-9-8-7-6-5-4-3-2-1
           seq    A C G T N a c g t n
           1:1    A
           2:4      C G T
         -4:-2                c g t
         -4:-1                c g t n
         -1:-1                      n
          2:-2      C G T N a c g t
          1:-1    A C G T N a c g t n
          1:12    A C G T N a c g t n
        -12:-1    A C G T N a c g t n

Usage:
  seqkit split [flags]

Flags:
  -i, --by-id                     split squences according to sequence ID
      --by-id-prefix string       file prefix for --by-id
  -p, --by-part int               split sequences into N parts
      --by-part-prefix string     file prefix for --by-part
  -r, --by-region string          split squences according to subsequence of given region. e.g 1:12 for
                                  first 12 bases, -12:-1 for last 12 bases. type &quot;seqkit split -h&quot; for
                                  more examples
      --by-region-prefix string   file prefix for --by-region
  -s, --by-size int               split sequences into multi parts with N sequences
      --by-size-prefix string     file prefix for --by-size
  -d, --dry-run                   dry run, just print message and no files will be created.
  -e, --extension string          set output file extension, e.g., &quot;.gz&quot;, &quot;.xz&quot;, or &quot;.zst&quot;
  -f, --force                     overwrite output directory
  -h, --help                      help for split
  -k, --keep-temp                 keep temporary FASTA and .fai file when using 2-pass mode
  -O, --out-dir string            output directory (default value is $infile.split)
  -2, --two-pass                  two-pass mode read files twice to lower memory usage. (only for FASTA
                                  format)
  -U, --update-faidx              update the fasta index file if it exists. Use this if you are not sure
                                  whether the fasta file changed
</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Split sequences into parts with at most 10000 sequences</p>
<pre><code>$ seqkit split hairpin.fa.gz -s 10000
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz
[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz
[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz
</code></pre>
</li>
<li>
<p>Split sequences into 4 parts</p>
<pre><code>$ seqkit split hairpin.fa.gz -p 4
[INFO] split into 4 parts
[INFO] read sequences ...
[INFO] read 28645 sequences
[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz
[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz
[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz
[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz
</code></pre>
<p><strong><em>To reduce memory usage when spliting big file, we should alwasy use flag <code>--two-pass</code></em></strong></p>
<pre><code>$ seqkit split hairpin.fa.gz -p 4 -2
[INFO] split into 4 parts
[INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ...
[INFO] 28645 sequences saved
[INFO] create or read FASTA index ...
[INFO] create FASTA index for hairpin.fa.gz.fastx
[INFO]   28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai
[INFO] write 7162 sequences to file: hairpin.part_001.fa.gz
[INFO] write 7162 sequences to file: hairpin.part_002.fa.gz
[INFO] write 7162 sequences to file: hairpin.part_003.fa.gz
[INFO] write 7159 sequences to file: hairpin.part_004.fa.gz
</code></pre>
</li>
<li>
<p>Split sequences by species. i.e. by custom IDs (first three letters)</p>
<pre><code>$ seqkit split hairpin.fa.gz -i --id-regexp "^([\w]+)\-" -2
[INFO] split by ID. idRegexp: ^([\w]+)\-
[INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ...
[INFO] 28645 sequences saved
[INFO] create or read FASTA index ...
[INFO] create FASTA index for hairpin.fa.gz.fastx
[INFO]   28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai
[INFO] write 48 sequences to file: hairpin.id_cca.fa.gz
[INFO] write 3 sequences to file: hairpin.id_hci.fa.gz
[INFO] write 106 sequences to file: hairpin.id_str.fa.gz
[INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz
...
</code></pre>
</li>
<li>
<p>Split sequences by sequence region (for example, sequence barcode)</p>
<pre><code>$ seqkit split hairpin.fa.gz -r 1:3 -2
[INFO] split by region: 1:3
[INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ...
[INFO] 28645 sequences saved
[INFO] read sequence IDs and sequence region from FASTA file ...
[INFO] create or read FASTA index ...
[INFO] create FASTA index for hairpin.fa.gz.fastx
[INFO]   28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai
[INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz
[INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz
[INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz
</code></pre>
<p>Sequence suffix could be defined as <code>-r -12:-1</code></p>
</li>
</ol>
<h2 id="split2">split2</h2>
<p>Usage</p>
<pre><code class="language-text">split sequences into files by part size or number of parts

This command supports FASTA and paired- or single-end FASTQ with low memory
occupation and fast speed.

The prefix of output files:
  1. For stdin: stdin
  2. Others: same to the input file
  3. Set via the options: --by-length-prefix, --by-part-prefix, or --by-size-prefix

The extension of output files:
  1. For stdin: .fast[aq]
  2. Others: same to the input file
  3. Additional extension via the option -e/--extension, e.g. outputting
     gzipped files for plain text input:
         seqkit split2 -p 2 -O test tests/hairpin.fa -e .gz


If you want to cut a sequence into multiple segments.
  1. For cutting into even chunks, please use 'kmcp utils split-genomes'
     (https://bioinf.shenwei.me/kmcp/usage/#split-genomes).
     E.g., cutting into 4 segments of equal size, with no overlap between adjacent segments:
        kmcp utils split-genomes -m 1 -k 1 --split-number 4 --split-overlap 0 input.fasta -O out
  2. For cutting into multiple chunks of fixed size, please using 'seqkit sliding'.
     E.g., cutting into segments of 40 bp and keeping the last segment which can be shorter than 40 bp.
        seqkit sliding -g -s 40 -W 40 input.fasta -o out.fasta

Usage:
  seqkit split2 [flags]

Flags:
  -l, --by-length string          split sequences into chunks of &gt;=N bases, supports K/M/G suffix
      --by-length-prefix string   file prefix for --by-length
  -p, --by-part int               split sequences into N parts
      --by-part-prefix string     file prefix for --by-part
  -s, --by-size int               split sequences into multi parts with N sequences
      --by-size-prefix string     file prefix for --by-size
  -e, --extension string          set output file extension, e.g., &quot;.gz&quot;, &quot;.xz&quot;, or &quot;.zst&quot;
  -f, --force                     overwrite output directory
  -h, --help                      help for split2
  -O, --out-dir string            output directory (default value is $infile.split)
  -1, --read1 string              (gzipped) read1 file
  -2, --read2 string              (gzipped) read2 file
</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Split sequences into parts with at most 10000 sequences:</p>
<pre><code>$ seqkit split2 hairpin.fa -s 10000
[INFO] split seqs from hairpin.fa
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_001.fa
[INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_002.fa
[INFO] write 8645 sequences to file: hairpin.fa.split/hairpin.part_003.fa
</code></pre>
</li>
<li>
<p>Force compression for plain text input by adding an extra extension:</p>
<pre><code># gzip
$ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz
[INFO] split seqs from hairpin.fa
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: test/hairpin.part_001.fa.gz
[INFO] write 10000 sequences to file: test/hairpin.part_002.fa.gz
[INFO] write 8645 sequences to file: test/hairpin.part_003.fa.gz

# xz
$ seqkit split2 hairpin.fa -O test -f -s 10000 -e .xz
[INFO] split seqs from hairpin.fa
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: test/hairpin.part_001.fa.xz
[INFO] write 10000 sequences to file: test/hairpin.part_002.fa.xz
[INFO] write 8645 sequences to file: test/hairpin.part_003.fa.xz

# zstd
$ seqkit split2 hairpin.fa -O test -f -s 10000 -e .zst
[INFO] split seqs from hairpin.fa
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: test/hairpin.part_001.fa.zst
[INFO] write 10000 sequences to file: test/hairpin.part_002.fa.zst
[INFO] write 8645 sequences to file: test/hairpin.part_003.fa.zst
</code></pre>
</li>
<li>
<p>Change the prefix of output files:</p>
<pre><code>$ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz -o xxx
[INFO] split seqs from hairpin.fa
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: test/xxx.part_001.fa.gz
[INFO] write 10000 sequences to file: test/xxx.part_002.fa.gz
[INFO] write 8645 sequences to file: test/xxx.part_003.fa.gz

# here, we also change the compression format from xz to zstd
$ cat hairpin.fa.xz | seqkit split2 -O test -f -s 10000 -e .zst
[INFO] split seqs from stdin
[INFO] split into 10000 seqs per file
[INFO] write 10000 sequences to file: test/stdin.part_001.fasta.zst
[INFO] write 10000 sequences to file: test/stdin.part_002.fasta.zst
[INFO] write 8645 sequences to file: test/stdin.part_003.fasta.zst
</code></pre>
</li>
<li>
<p>Split sequences into 4 parts</p>
<pre><code>$ seqkit split hairpin.fa.gz -p 4 -f
[INFO] split into 4 parts
[INFO] read sequences ...
[INFO] read 28645 sequences
[INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_001.fa.gz
[INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_002.fa.gz
[INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_003.fa.gz
[INFO] write 7159 sequences to file: hairpin.fa.gz.split/hairpin.part_004.fa.gz
</code></pre>
</li>
<li>
<p>For FASTQ files (paired-end)</p>
<pre><code>$ seqkit split2 -1 reads_1.fq.gz -2 reads_2.fq.gz -p 2 -O out -f
[INFO] split seqs from reads_1.fq.gz and reads_2.fq.gz
[INFO] split into 2 parts
[INFO] write 1250 sequences to file: out/reads_2.part_001.fq.gz
[INFO] write 1250 sequences to file: out/reads_2.part_002.fq.gz
[INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz
[INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz
</code></pre>
</li>
<li>
<p>For FASTA files (single-end)</p>
<pre><code>$ seqkit split2 -1 reads_1.fq.gz reads_2.fq.gz -p 2 -O out -f
[INFO] flag -1/--read1 given, ignore: reads_2.fq.gz
[INFO] split seqs from reads_1.fq.gz
[INFO] split into 2 parts
[INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz
[INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz

$ seqkit split2 reads_1.fq.gz -p 2 -O out -f
[INFO] split seqs from reads_1.fq.gz
[INFO] split into 2 parts
[INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz
[INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz
</code></pre>
</li>
</ol>
<h2 id="pair">pair</h2>
<p>Usage</p>
<pre><code class="language-text">match up paired-end reads from two fastq files

Attention:
1. Orders of headers in the two files better be the same (not shuffled),
   otherwise, it consumes a huge number of memory for buffering reads in memory.
2. Unpaired reads are optional outputted with the flag -u/--save-unpaired.
3. If the flag -O/--out-dir is not given, the output will be saved in the same directory
   of input, with the suffix &quot;paired&quot;, e.g., read_1.paired.fq.gz.
   Otherwise, names are kept untouched in the given output directory.
4. Paired gzipped files may be slightly larger than original files, because
   of using a different gzip package/library, don't worry.

Tips:
1. Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI.
   You can simply specify the regular expression for extracting sequence IDs:
     --id-regexp '^(\S+)\/[12]'

Usage:
  seqkit pair [flags]

Flags:
  -f, --force            overwrite output directory
  -h, --help             help for pair
  -O, --out-dir string   output directory
  -1, --read1 string     (gzipped) read1 file
  -2, --read2 string     (gzipped) read2 file
  -u, --save-unpaired    save unpaired reads if there are
</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Simple one</p>
<pre><code>$ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz

# output
reads_1.paired.fq.gz
reads_2.paired.fq.gz
</code></pre>
</li>
<li>
<p>Set output directory, file names are kept untouched.</p>
<pre><code>$ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result

$ tree result        
result/
 reads_1.fq.gz
 reads_2.fq.gz
</code></pre>
</li>
<li>
<p>Save unpaired reads if there are.</p>
<pre><code>$ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result -u

$ tree result
result
 reads_1.fq.gz
 reads_1.unpaired.fq.gz
 reads_2.fq.gz
 reads_2.unpaired.fq.gz
</code></pre>
</li>
<li>
<p>Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI.
   You can simply specify the regular expression for extracting sequence IDs:</p>
<pre><code>seqkit pair --id-regexp '^(\S+)\/[12]' -1 reads_1.fq.gz -2 reads_2.fq.gz
</code></pre>
</li>
</ol>
<h2 id="sample">sample</h2>
<p>Usage</p>
<pre><code class="language-text">sample sequences by number or proportion.

Attention:
1. Do not use '-n' on large FASTQ files, it loads all seqs into memory!
   use 'seqkit sample -p 0.1 seqs.fq.gz | seqkit head -n N' instead!

Usage:
  seqkit sample [flags]

Flags:
  -h, --help               help for sample
  -n, --number int         sample by number (result may not exactly match), DO NOT use on large FASTQ files.
  -p, --proportion float   sample by proportion
  -s, --rand-seed int      random seed. For paired-end data, use the same seed across fastq files to
                           sample the same read pairs (default 11)
  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading
                           from stdin

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Sample by proportion</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz
[INFO] sample by proportion
[INFO] 2814 sequences outputed
</code></pre>
</li>
<li>
<p>Sample by number</p>
<pre><code>$ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz
[INFO] sample by number
[INFO] 949 sequences outputed
</code></pre>
<p>949 != 1000 ??? see <a href="http:bioinf.shenwei.me/seqkit/note/#effect-of-random-seed-on-results-of-seqkit-sample">Effect of random seed on results of <code>seqkit sample</code></a></p>
<p><strong><em>To reduce memory usage when spliting big file, we could use flag <code>--two-pass</code></em></strong></p>
<p><strong><em>We can also use <code>seqkit sample -p</code> followed with <code>seqkit head -n</code>:</em></strong></p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit sample -p 0.1 \
    | seqkit head -n 1000 -o sample.fa.gz
</code></pre>
</li>
<li>
<p>Set rand seed to reproduce the result</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit sample -p 0.1 -s 11
</code></pre>
</li>
<li>
<p>Most of the time, we could shuffle after sampling</p>
<pre><code>$ zcat hairpin.fa.gz \
    | seqkit sample -p 0.1 \
    | seqkit shuffle -o sample.fa.gz
</code></pre>
</li>
</ol>
<p>Note that when sampling on FASTQ files, make sure using same random seed by
flag <code>-s</code> (<code>--rand-seed</code>)</p>
<h2 id="head">head</h2>
<p>Usage</p>
<pre><code class="language-text">print first N FASTA/Q records

For returning the last N records, use:
    seqkit range -r -N:-1 seqs.fasta

Usage:
  seqkit head [flags]

Flags:
  -n, --number int   print first N FASTA/Q records (default 10)

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>FASTA</p>
<pre><code>$ seqkit head -n 1 hairpin.fa.gz
&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop
UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC
UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA
</code></pre>
</li>
<li>
<p>FASTQ</p>
<pre><code>$ seqkit head -n 1 reads_1.fq.gz
@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG
TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA
+
HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII
</code></pre>
</li>
</ol>
<h2 id="head-genome">head-genome</h2>
<p>Usage</p>
<pre><code class="language-text">
print sequences of the first genome with common prefixes in name

For a FASTA file containing multiple contigs of strains (see example below),
these's no list of IDs available for retrieving sequences of a certain strain,
while descriptions of each strain share the same prefix.

This command is used to restrieve sequences of the first strain,
i.e., &quot;Vibrio cholerae strain M29&quot;.

&gt;NZ_JFGR01000001.1 Vibrio cholerae strain M29 Contig_1, whole genome shotgun sequence
&gt;NZ_JFGR01000002.1 Vibrio cholerae strain M29 Contig_2, whole genome shotgun sequence
&gt;NZ_JFGR01000003.1 Vibrio cholerae strain M29 Contig_3, whole genome shotgun sequence
&gt;NZ_JSTP01000001.1 Vibrio cholerae strain 2012HC-12 NODE_79, whole genome shotgun sequence
&gt;NZ_JSTP01000002.1 Vibrio cholerae strain 2012HC-12 NODE_78, whole genome shotgun sequence

Attention:

  1. Sequences in file should be well organized.

Usage:
  seqkit head-genome [flags]

Flags:
  -h, --help                    help for head-genome
  -m, --mini-common-words int   minimal shared prefix words (default 4)

</code></pre>
<h2 id="range">range</h2>
<p>Usage</p>
<pre><code class="language-text">print FASTA/Q records in a range (start:end)

Examples:
  1. leading 100 records (head -n 100)
      seqkit range -r 1:100
  2. last 100 records (tail -n 100)
      seqkit range -r -100:-1
  3. remove leading 100 records (tail -n +101)
      seqkit range -r 101:-1
  4. other ranges:
      seqkit range -r 10:100
      seqkit range -r -100:-10

Usage:
  seqkit range [flags]

Flags:
  -h, --help           help for range
  -r, --range string   range. e.g., 1:12 for first 12 records (head -n 12), -12:-1 for last 12 records (tail -n 12)
</code></pre>
<p>Examples</p>
<ol>
<li>
<p>leading N records (head)</p>
<pre><code>$ cat tests/hairpin.fa | seqkit head -n 100 | md5sum
f65116af7d9298d93ba4b3d19077bbf1  -
$ cat tests/hairpin.fa | seqkit range -r 1:100 | md5sum
f65116af7d9298d93ba4b3d19077bbf1  -
</code></pre>
</li>
<li>
<p>last N records (tail)</p>
<pre><code>$ cat tests/hairpin.fa | seqkit range -r -100:-1 | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA        100    8,656       58     86.6      172
</code></pre>
</li>
<li>
<p>remove leading 100 records (tail -n +101)</p>
<pre><code>$ seqkit range -r 101:-1 tests/hairpin.fa | seqkit sum -a
seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db     -       28545   2940929

$ seqkit fx2tab tests/hairpin.fa | tail -n +101 | seqkit tab2fx | seqkit sum -a
seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db     -       28545   2940929
</code></pre>
</li>
<li>
<p>Other ranges</p>
<pre><code>$ cat tests/hairpin.fa | seqkit range -r 101:150 | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA         50    3,777       63     75.5       96

$ cat tests/hairpin.fa | seqkit range -r -100:-2 | seqkit stats
file  format  type  num_seqs  sum_len  min_len  avg_len  max_len
-     FASTA   RNA         99    8,484       58     85.7      146
</code></pre>
</li>
</ol>
<h2 id="replace">replace</h2>
<p>Usage</p>
<pre><code class="language-text">replace name/sequence by regular expression.

Note that the replacement supports capture variables.
e.g. $1 represents the text of the first submatch.
ATTENTION: use SINGLE quote NOT double quotes in *nix OS.

Examples: Adding space to all bases.

    seqkit replace -p &quot;(.)&quot; -r '$1 ' -s

Or use the \ escape character.

    seqkit replace -p &quot;(.)&quot; -r &quot;\$1 &quot; -s

more on: http://bioinf.shenwei.me/seqkit/usage/#replace

Special replacement symbols (only for replacing name not sequence):

    {nr}    Record number, starting from 1
    {kv}    Corresponding value of the key (captured variable $n) by key-value file,
            n can be specified by flag -I (--key-capt-idx) (default: 1)

Special cases:
  1. If replacements contain '$', 
    a). If using '{kv}', you need use '$$$$' instead of a single '$':
            -r '{kv}' -k &lt;(sed 's/\$/$$$$/' kv.txt)
    b). If not, use '$$':
            -r 'xxx$$xx'

Filtering records to edit:
  You can use flags similar to those in &quot;seqkit grep&quot; to choose partly records to edit.

Usage:
  seqkit replace [flags]

Flags:
  -s, --by-seq                   replace seq (only FASTA)
      --f-by-name                [target filter] match by full name instead of just ID
      --f-by-seq                 [target filter] search subseq on seq, both positive and negative strand
                                 are searched, and mismatch allowed using flag -m/--max-mismatch
      --f-ignore-case            [target filter] ignore case
      --f-invert-match           [target filter] invert the sense of matching, to select non-matching records
      --f-only-positive-strand   [target filter] only search on positive strand
      --f-pattern strings        [target filter] search pattern (multiple values supported. Attention:
                                 use double quotation marks for patterns containing comma, e.g., -p
                                 '&quot;A{2,}&quot;')
      --f-pattern-file string    [target filter] pattern file (one record per line)
      --f-use-regexp             [target filter] patterns are regular expression
  -h, --help                     help for replace
  -i, --ignore-case              ignore case
  -K, --keep-key                 keep the key as value when no value found for the key (only for
                                 sequence name)
  -U, --keep-untouch             do not change anything when no value found for the key (only for
                                 sequence name)
  -I, --key-capt-idx int         capture variable index of key (1-based) (default 1)
  -m, --key-miss-repl string     replacement for key with no corresponding value
  -k, --kv-file string           tab-delimited key-value file for replacing key with value when using
                                 &quot;{kv}&quot; in -r (--replacement) (only for sequence name)
      --nr-width int             minimum width for {nr} in flag -r/--replacement. e.g., formatting &quot;1&quot;
                                 to &quot;001&quot; by --nr-width 3 (default 1)
  -p, --pattern string           search regular expression
  -r, --replacement string       replacement. supporting capture variables.  e.g. $1 represents the text
                                 of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT
                                 double quotes or use the \ escape character. Record number is also
                                 supported by &quot;{nr}&quot;.use ${1} instead of $1 when {kv} given!

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Prepend or append to the header</p>
<pre><code>$ echo -e "&gt;seq1 abc-123\nACGT-ACGT"
&gt;seq1 abc-123
ACGT-ACGT

# prefix
$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p ^ -r _prefix_
&gt;_prefix_seq1 abc-123
ACGT-ACGT

# suffix
$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p $ -r _suffix_
&gt;seq1 abc-123_suffix_
ACGT-ACGT
$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit seq -i \
    | seqkit replace -p $ -r _suffix_
&gt;seq1_suffix_
ACGT-ACGT
</code></pre>
</li>
<li>
<p>Remove descriptions</p>
<pre><code>$ echo -e "&gt;seq1 abc-123\nACGT-ACGT"
&gt;seq1 abc-123
ACGT-ACGT

$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p "\s.+"
&gt;seq1
ACGT-ACGT
</code></pre>
</li>
<li>
<p>Replace "-" with "="</p>
<pre><code>$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p "\-" -r '='
&gt;seq1 abc=123
ACGT-ACGT
</code></pre>
</li>
<li>
<p>Remove gaps in sequences.</p>
<pre><code>$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p " |-" -s
&gt;seq1 abc-123
ACGTACGT
</code></pre>
</li>
<li>
<p>Add space to every base. <strong>ATTENTION: use SINGLE quote NOT double quotes in *nix OS</strong></p>
<pre><code>$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p "(.)" -r '$1 ' -s
&gt;seq1 abc-123
A C G T - A C G T

$ echo -e "&gt;seq1 abc-123\nACGT-ACGT" \
    | seqkit replace -p "(.)" -r "\$1 " -s
&gt;seq1 abc-123
A C G T - A C G T
</code></pre>
</li>
<li>
<p>Transpose sequence with <a href="https://github.com/shenwei356/csvtk">csvtk</a></p>
<pre><code>$ echo -e "&gt;seq1\nACTGACGT\n&gt;seq2\nactgccgt" \
    | seqkit replace -p "(.)" -r     "\$1 " -s \
    | seqkit seq -s -u \
    | csvtk space2tab \
    | csvtk -t transpose
A       A
C       C
T       T
G       G
A       C
C       C
G       G
T       T
</code></pre>
</li>
<li>
<p><strong>Rename with number of record</strong></p>
<pre><code>$ echo -e "&gt;abc\nACTG\n&gt;123\nATTT" \
    |  seqkit replace -p .+ -r "seq_{nr}"
&gt;seq_1
ACTG
&gt;seq_2
ATTT

$ echo -e "&gt;abc\nACTG\n&gt;123\nATTT" \
    |  seqkit replace -p .+ -r "seq_{nr}" --nr-width 5
&gt;seq_00001
ACTG
&gt;seq_00002
ATTT
</code></pre>
</li>
<li>
<p>Replace key with value by key-value file</p>
<pre><code>$ more test.fa
&gt;seq1 name1
CCCCAAAACCCCATGATCATGGATC
&gt;seq2 name2
CCCCAAAACCCCATGGCATCATTCA
&gt;seq3 name3
CCCCAAAACCCCATGTTGCTACTAG

$ more alias.txt
name0   ABC
name1   123
name3   Hello
name4   World

$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa
[INFO] read key-value file: alias.txt
[INFO] 4 pairs of key-value loaded
&gt;seq1 123
CCCCAAAACCCCATGATCATGGATC
&gt;seq2
CCCCAAAACCCCATGGCATCATTCA
&gt;seq3 Hello
CCCCAAAACCCCATGTTGCTACTAG

$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key
[INFO] read key-value file: alias.txt
[INFO] 4 pairs of key-value loaded
&gt;seq1 123
CCCCAAAACCCCATGATCATGGATC
&gt;seq2 name2
CCCCAAAACCCCATGGCATCATTCA
&gt;seq3 Hello
CCCCAAAACCCCATGTTGCTACTAG
</code></pre>
<p>If the target to replace is the sequence ID, meanwhile you would like to keep the description. 
Please use this:</p>
<pre><code># ^(\S+)   # ID
# (.+)$    # description
seqkit replace -p '^(\S+)(.+?)$' -r '{kv}$2' -k alias.txt test.fa
</code></pre>
</li>
<li>
<p>convert fasta to genbank style</p>
<pre><code>$ cat seq.fa
&gt;seq1
TTTAAAGAGACCGGCGATTCTAGTGAAATCGAACGGGCAGGTCAATTTCCAACCAGCGAT
GACGTAATAGATAGATACAAGGAAGTCATTTTTCTTTTAAAGGATAGAAACGGTTAATGC
TCTTGGGACGGCGCTTTTCTGTGCATAACT
&gt;seq2
AAGGATAGAAACGGTTAATGCTCTTGGGACGGCGCTTTTCTGTGCATAACTCGATGAAGC
CCAGCAATTGCGTGTTTCTCCGGCAGGCAAAAGGTTGTCGAGAACCGGTGTCGAGGCTGT
TTCCTTCCTGAGCGAAGCCTGGGGATGAACG

$ cat seq.fa \
    | seqkit replace -s -p '(\w{10})' -r '$1 ' -w 66 \
    | perl -ne 'if (/^&gt;/) {print; $n=1} else {s/ \r?\n$/\n/; printf "%9d %s", $n, $_; $n+=60;}'
&gt;seq1
        1 TTTAAAGAGA CCGGCGATTC TAGTGAAATC GAACGGGCAG GTCAATTTCC AACCAGCGAT
       61 GACGTAATAG ATAGATACAA GGAAGTCATT TTTCTTTTAA AGGATAGAAA CGGTTAATGC
      121 TCTTGGGACG GCGCTTTTCT GTGCATAACT
&gt;seq2
        1 AAGGATAGAA ACGGTTAATG CTCTTGGGAC GGCGCTTTTC TGTGCATAAC TCGATGAAGC
       61 CCAGCAATTG CGTGTTTCTC CGGCAGGCAA AAGGTTGTCG AGAACCGGTG TCGAGGCTGT
      121 TTCCTTCCTG AGCGAAGCCT GGGGATGAAC G
</code></pre>
</li>
<li>
<p>only edit some of the records via patterns. Eight flags starting with <code>--f-</code> (with the same usage to these in <code>seqkit grep</code>) can be used 
  to filter records to edit.</p>
<pre><code># prepend some text to header
$ echo -e "&gt;abc\nACTG\n&gt;123\nATTT" \
    | seqkit replace -p ^ -r _
&gt;_abc
ACTG
&gt;_123
ATTT

# only edit some records
$ echo -e "&gt;abc\nACTG\n&gt;123\nATTT" \
    | seqkit replace -p ^ -r _ --f-use-regexp --f-pattern abc
[INFO] 1 records matched by the filter
&gt;_abc
ACTG
&gt;123
ATTT

$ echo -e "&gt;abc\nACTG\n&gt;123\nATTT" \
    | seqkit replace -p ^ -r _ --f-use-regexp --f-invert-match --f-pattern abc 
[INFO] 1 records matched by the filter
&gt;abc
ACTG
&gt;_123
ATTT
</code></pre>
</li>
</ol>
<h2 id="rename">rename</h2>
<p>Usage</p>
<pre><code class="language-text">rename duplicated IDs

Attention:
  1. This command only appends &quot;_N&quot; to duplicated sequence IDs to make them unique.
  2. Use &quot;seqkit replace&quot; for editing sequence IDs/headers using regular expression.

Example:

    $ seqkit seq seqs.fasta 
    &gt;id comment
    actg
    &gt;id description
    ACTG

    $ seqkit rename seqs.fasta
    &gt;id comment
    actg
    &gt;id_2 description
    ACTG

Usage:
  seqkit rename [flags]

Flags:
  -n, --by-name             check duplication by full name instead of just id
  -f, --force               overwrite output directory
  -h, --help                help for rename
  -m, --multiple-outfiles   write results into separated files for multiple input files
  -O, --out-dir string      output directory (default &quot;renamed&quot;)
  -1, --rename-1st-rec      rename the first record as well
  -s, --separator string    separator between original ID/name and the counter (default &quot;_&quot;)
  -N, --start-num int       starting count number for *duplicated* IDs/names, should be greater than
                            zero (default 2

</code></pre>
<p>Examples</p>
<pre><code class="language-sh">$ echo -e &quot;&gt;a comment\nacgt\n&gt;b comment of b\nACTG\n&gt;a comment\naaaa&quot;
&gt;a comment
acgt
&gt;b comment of b
ACTG
&gt;a comment
aaaa

$ echo -e &quot;&gt;a comment\nacgt\n&gt;b comment of b\nACTG\n&gt;a comment\naaaa&quot; \
    | seqkit rename
&gt;a comment
acgt
&gt;b comment of b
ACTG
&gt;a_2 comment
aaaa

$ echo -e &quot;&gt;a comment\nacgt\n&gt;b comment of b\nACTG\n&gt;a comment\naaaa&quot;  \
    | seqkit rename -s '|' -N 2 -1
&gt;a|1 comment
acgt
&gt;b|1 comment of b
ACTG
&gt;a|2 comment
aaaa

</code></pre>
<h2 id="restart">restart</h2>
<p>Usage</p>
<pre><code class="language-text">reset start position for circular genome

Examples

    $ echo -e &quot;&gt;seq\nacgtnACGTN&quot;
    &gt;seq
    acgtnACGTN

    $ echo -e &quot;&gt;seq\nacgtnACGTN&quot; | seqkit restart -i 2
    &gt;seq
    cgtnACGTNa

    $ echo -e &quot;&gt;seq\nacgtnACGTN&quot; | seqkit restart -i -2
    &gt;seq
    TNacgtnACG

Usage:
  seqkit restart [flags]

Flags:
  -i, --new-start int   new start position (1-base, supporting negative value counting from the end) (default 1)

</code></pre>
<h2 id="concat">concat</h2>
<p>Usage</p>
<pre><code class="language-text">concatenate sequences with same ID from multiple files

Attention:
   1. By default, only sequences with IDs that appear in all files are outputted.
      use -f/--full to output all sequences.
   2. If there are more than one sequences of the same ID, we output the Cartesian
      product of sequences.
   3. Description are also concatenated with a separator (-s/--separator).
   4. Order of sequences with different IDs are random.

Usage:
  seqkit concat [flags]

Aliases:
  concat, concate

Flags:
  -f, --full               keep all sequences, like full/outer join
  -h, --help               help for concat
  -s, --separator string   separator for descriptions of records with the same ID (default &quot;|&quot;)

</code></pre>
<p>Examples</p>
<pre><code>$ cat a.fa 
&gt;A 1
a1-
&gt;A 2
a2-
&gt;B 1
b1-

$ cat b.fa 
&gt;A x
ax-
&gt;C 1
c1-

$ seqkit concat a.fa b.fa 
&gt;A 1|x
a1-ax-
&gt;A 2|x
a2-ax-

$ seqkit concat a.fa b.fa --full
&gt;C 1
c1-
&gt;A 1|x
a1-ax-
&gt;A 2|x
a2-ax-
&gt;B 1
b1-

</code></pre>
<h2 id="mutate">mutate</h2>
<p>Usage</p>
<pre><code class="language-text">edit sequence (point mutation, insertion, deletion)

Attention:

  1. Mutiple point mutations (-p/--point) are allowed, but only single 
     insertion (-i/--insertion) OR single deletion (-d/--deletion) is allowed.
  2. Point mutation takes place before insertion/deletion.

Notes:

  1. You can choose certain sequences to edit using similar flags in
     'seqkit grep'.

The definition of position is 1-based and with some custom design.

Examples:

 1-based index    1 2 3 4 5 6 7 8 9 10
negative index    0-9-8-7-6-5-4-3-2-1
           seq    A C G T N a c g t n
           1:1    A
           2:4      C G T
         -4:-2                c g t
         -4:-1                c g t n
         -1:-1                      n
          2:-2      C G T N a c g t
          1:-1    A C G T N a c g t n
          1:12    A C G T N a c g t n
        -12:-1    A C G T N a c g t n

Usage:
  seqkit mutate [flags]

Flags:
  -n, --by-name               [match seqs to mutate] match by full name instead of just id
  -d, --deletion string       deletion mutation: deleting subsequence in a range. e.g., -d 1:2 for
                              deleting leading two bases, -d -3:-1 for removing last 3 bases
  -h, --help                  help for mutate
  -I, --ignore-case           [match seqs to mutate] ignore case of search pattern
  -i, --insertion string      insertion mutation: inserting bases behind of given position, e.g., -i
                              0:ACGT for inserting ACGT at the beginning, -1:* for add * to the end
  -v, --invert-match          [match seqs to mutate] invert the sense of matching, to select
                              non-matching records
  -s, --pattern strings       [match seqs to mutate] search pattern (multiple values supported.
                              Attention: use double quotation marks for patterns containing comma, e.g.,
                              -p '&quot;A{2,}&quot;'))
  -f, --pattern-file string   [match seqs to mutate] pattern file (one record per line)
  -p, --point strings         point mutation: changing base at given position. e.g., -p 2:C for setting
                              2nd base as C, -p -1:A for change last base as A
  -r, --use-regexp            [match seqs to mutate] search patterns are regular expression

</code></pre>
<p>Examples:</p>
<ol>
<li>
<p>Point mutation:</p>
<pre><code>$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n"
&gt;1
ACTGNactgn
&gt;2
actgnACTGN

# first base
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -p 1:x
[INFO] edit seq: 1
[INFO] edit seq: 2
&gt;1
xCTGNactgn
&gt;2
xctgnACTGN

# 5th base
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -p 5:x --quiet
&gt;1
ACTGxactgn
&gt;2
actgxACTGN

# last base
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -p -1:x --quiet
&gt;1
ACTGNactgx
&gt;2
actgnACTGx

# mutiple locations:

$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -p 1:x -p -1:x --quiet
&gt;1
xCTGNactgx
&gt;2
xctgnACTGx
</code></pre>
</li>
<li>
<p>Deletion</p>
<pre><code># first base
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -d 1:1 --quiet
&gt;1
CTGNactgn
&gt;2
ctgnACTGN

# last 3 bases
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -d -3:-1 --quiet
&gt;1
ACTGNac
&gt;2
actgnAC
</code></pre>
</li>
<li>
<p>Insertion: inserting bases <strong>behind</strong> of given position</p>
<pre><code># at the beginning
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -i 0:xx --quiet
&gt;1
xxACTGNactgn
&gt;2
xxactgnACTGN

# at the end
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -i -1:xx --quiet
&gt;1
ACTGNactgnxx
&gt;2
actgnACTGNxx

# behind of 5th base
$ echo -ne "&gt;1\nACTGNactgn\n&gt;2\nactgnACTGN\n" \
    | seqkit mutate -i 5:x --quiet
&gt;1
ACTGNxactgn
&gt;2
actgnxACTGN
</code></pre>
</li>
<li>
<p><strong>Choosing which sequences to edit</strong>, using similar flags in <code>seqkit grep</code>.</p>
<pre><code>$ cat tests/hsa.fa
&gt;chr1 1th seq
ACTGNactgn
&gt;chr2 2nd seq
actgnACTGN
&gt;chr11 11th seq
ACTGNACTGN
&gt;MT mitochondrial seq
actgnactgn

# only edit chr1 and chr2
# or cat tests/hsa.fa | seqkit mutate -p -1:X -s chr1 -s chr2
$ cat tests/hsa.fa \
    | seqkit mutate -p -1:X -s chr1,chr2
[INFO] edit seq: chr1 1th seq
[INFO] edit seq: chr2 2nd seq
&gt;chr1 1th seq
ACTGNactgX
&gt;chr2 2nd seq
actgnACTGX
&gt;chr11 11th seq
ACTGNACTGN
&gt;MT mitochondrial seq
actgnactgn

# using regular expression to match.
# e,g., editing all chrosomes:
$ cat tests/hsa.fa \
    | seqkit mutate -p -1:X -r -s chr
[INFO] edit seq: chr1 1th seq
[INFO] edit seq: chr2 2nd seq
[INFO] edit seq: chr11 11th seq
&gt;chr1 1th seq
ACTGNactgX
&gt;chr2 2nd seq
actgnACTGX
&gt;chr11 11th seq
ACTGNACTGX
&gt;MT mitochondrial seq
actgnactgn

# excluding seqs
$ cat tests/hsa.fa \
    | seqkit mutate -p -1:X -s chr1 -s chr2 -v 
[INFO] edit seq: chr11 11th seq
[INFO] edit seq: MT mitochondrial seq
&gt;chr1 1th seq
ACTGNactgn
&gt;chr2 2nd seq
actgnACTGN
&gt;chr11 11th seq
ACTGNACTGX
&gt;MT mitochondrial seq
actgnactgX
</code></pre>
</li>
</ol>
<h2 id="shuffle">shuffle</h2>
<p>Usage</p>
<pre><code class="language-text">shuffle sequences.

By default, all records will be readed into memory.
For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not
supported.

Firstly, seqkit reads the sequence IDs. If the file is not plain FASTA file,
seqkit will write the sequences to temporary files, and create FASTA index.

Secondly, seqkit shuffles sequence IDs and extract sequences by FASTA index.

Attention:
  1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to
     ensure the .fai file matches the FASTA file.

Usage:
  seqkit shuffle [flags]

Flags:
  -h, --help            help for shuffle
  -k, --keep-temp       keep temporary FASTA and .fai file when using 2-pass mode
  -s, --rand-seed int   rand seed for shuffle (default 23)
  -2, --two-pass        two-pass mode read files twice to lower memory usage. (only for FASTA format)
  -U, --update-faidx    update the fasta index file if it exists. Use this if you are not sure whether
                        the fasta file changed

</code></pre>
<p>Examples</p>
<ol>
<li>
<p>General use.</p>
<pre><code>$ seqkit shuffle hairpin.fa.gz &gt; shuffled.fa
[INFO] read sequences ...
[INFO] 28645 sequences loaded
[INFO] shuffle ...
[INFO] output ...
</code></pre>
</li>
<li>
<p><strong><em>For big genome, you'd better use two-pass mode</em></strong> so seqkit could use
   FASTA index to reduce memory usage</p>
<pre><code>$ time seqkit shuffle -2 hsa.fa &gt; shuffle.fa
[INFO] create and read FASTA index ...
[INFO] create FASTA index for hsa.fa
[INFO] read sequence IDs from FASTA index ...
[INFO] 194 sequences loaded
[INFO] shuffle ...
[INFO] output ...

real    0m35.080s
user    0m45.521s
sys     0m3.411s
</code></pre>
</li>
</ol>
<p>Note that when sampling on FASTQ files, make sure using same random seed by
flag <code>-s</code> (<code>--rand-seed</code>) for read 1 and 2 files.</p>
<h2 id="sort">sort</h2>
<p>Usage</p>
<pre><code class="language-text">sort sequences by id/name/sequence/length.

By default, all records will be readed into memory.
For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not
supported.

Firstly, seqkit reads the sequence head and length information.
If the file is not plain FASTA file,
seqkit will write the sequences to temporary files, and create FASTA index.

Secondly, seqkit sorts sequence by head and length information
and extracts sequences by FASTA index.

Attention:
  1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to
     ensure the .fai file matches the FASTA file.

Usage:
  seqkit sort [flags]

Flags:
  -b, --by-bases                by non-gap bases
  -l, --by-length               by sequence length
  -n, --by-name                 by full name instead of just id
  -s, --by-seq                  by sequence
  -G, --gap-letters string      gap letters (default &quot;- \t.&quot;)
  -h, --help                    help for sort
  -i, --ignore-case             ignore case
  -k, --keep-temp               keep temporary FASTA and .fai file when using 2-pass mode
  -N, --natural-order           sort in natural order, when sorting by IDs/full name
  -r, --reverse                 reverse the result
  -L, --seq-prefix-length int   length of sequence prefix on which seqkit sorts by sequences (0 for
                                whole sequence) (default 10000)
  -2, --two-pass                two-pass mode read files twice to lower memory usage. (only for FASTA format)
  -U, --update-faidx            update the fasta index file if it exists. Use this if you are not sure
                                whether the fasta file changed

</code></pre>
<p>Examples</p>
<p><strong><em>For FASTA format, use flag -2 (--two-pass) to reduce memory usage</em></strong></p>
<ol>
<li>
<p>sort by ID</p>
<pre><code>$ echo -e "&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA" \
    | seqkit sort --quiet
&gt;SEQ2
acgtnAAAA
&gt;seq1
ACGTNcccc
</code></pre>
</li>
<li>
<p>sort by ID and in natural order</p>
<pre><code>$ echo -e "&gt;3\na\n&gt;1\na\n&gt;Y\na\n&gt;x\na\n&gt;Mt\na\n&gt;11\na\n&gt;2\na\n" \
    | seqkit seq -n -i
3
1
Y
x
Mt
11
2

$ echo -e "&gt;3\na\n&gt;1\na\n&gt;Y\na\n&gt;x\na\n&gt;Mt\na\n&gt;11\na\n&gt;2\na\n" \
    | seqkit sort -N -i -2 \
    | seqkit seq -n -i
1
2
3
11
Mt
x
Y
</code></pre>
</li>
<li>
<p>sort by ID, ignoring case.</p>
<pre><code>$ echo -e "&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA" \
    | seqkit sort --quiet -i
&gt;seq1
ACGTNcccc
&gt;SEQ2
acgtnAAAA
</code></pre>
</li>
<li>
<p>sort by seq, ignoring case.</p>
<pre><code>$ echo -e "&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA" \
    | seqkit sort --quiet -s -i
&gt;SEQ2
acgtnAAAA
&gt;seq1
ACGTNcccc
</code></pre>
</li>
<li>
<p>sort by sequence length</p>
<pre><code>$ echo -e "&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAAnnn\n&gt;seq3\nacgt" \
    | seqkit sort --quiet -l
&gt;seq3
acgt
&gt;seq1
ACGTNcccc
&gt;SEQ2
acgtnAAAAnnn
</code></pre>
</li>
</ol>
<h2 id="bam">bam</h2>
<pre><code class="language-text">monitoring and online histograms of BAM record features

Usage:
  seqkit bam [flags]

Flags:
  -B, --bins int             number of histogram bins (default -1)
  -N, --bundle int           partition BAM file into loci (-1) or bundles with this minimum size
  -c, --count string         count reads per reference and save to this file
  -W, --delay int            sleep this many seconds after plotting (default 1)
  -y, --dump                 print histogram data to stderr instead of plotting
  -G, --exclude-ids string   exclude records with IDs contained in this file
  -e, --exec-after string    execute command after reporting
  -E, --exec-before string   execute command before reporting
  -f, --field string         target fields
  -g, --grep-ids string      only keep records with IDs contained in this file
  -h, --help                 help for bam
  -C, --idx-count            fast read per reference counting based on the BAM index
  -i, --idx-stat             fast statistics based on the BAM index
  -O, --img string           save histogram to this PDF/image file
  -H, --list-fields          list all available BAM record features
  -L, --log                  log10(x+1) transform numeric values
  -q, --map-qual int         minimum mapping quality
  -x, --pass                 passthrough mode (forward filtered BAM to output)
  -k, --pretty               pretty print certain TSV outputs
  -F, --prim-only            filter out non-primary alignment records
  -p, --print-freq int       print/report after this many records (-1 for print after EOF) (default -1)
  -Q, --quiet-mode           supress all plotting to stderr
  -M, --range-max float      discard record with field (-f) value greater than this flag (default NaN)
  -m, --range-min float      discard record with field (-f) value less than this flag (default NaN)
  -R, --reset                reset histogram after every report
  -Z, --silent-mode          supress TSV output to stderr
  -s, --stat                 print BAM satistics of the input files
  -T, --tool string          invoke toolbox in YAML format (see documentation)
  -@, --top-bam string       save the top -? records to this bam file
  -?, --top-size int         size of the top-mode buffer (default 100)
</code></pre>
<p>Examples</p>
<ol>
<li>
<p>Get detailed statistics from multiple BAM files.</p>
<pre><code>seqkit bam -s *.bam
</code></pre>
</li>
<li>
<p>Get rough statistics from multiple indexed BAM files.</p>
<pre><code>seqkit bam -i *.bam
</code></pre>
</li>
<li>
<p>Count reads mapped to references from a BAM stream.</p>
<pre><code>cat sample.bam | seqkit bam -c counts.tsv  -
</code></pre>
</li>
<li>
<p>Count reads mapped to references using the BAM index.</p>
<pre><code>seqkit bam -C sorted_indexed.bam
</code></pre>
</li>
<li>
<p>Monitor alignment accuracy from a bam stream and report after every 1000 records, use 20 bins.</p>
<pre><code>cat sample.bam | seqkit bam -B -f Acc -p 1000 -
</code></pre>
</li>
<li>
<p>Dump selected fields to TSV.</p>
<pre><code>seqkit bam -f Ref,Acc,RefCov,Strand sample.bam
</code></pre>
</li>
<li>
<p>Save the best 100 records in terms of alignment accuracy to a BAM file.</p>
<pre><code>seqkit bam -f Acc -@ top_acc_100.bam -? 100 -Q sample.bam
</code></pre>
</li>
<li>
<p>Inkvoke the BAM toolbox.</p>
</li>
</ol>
<p>The BAM toolbox is a collection of filters acting on a stream of BAM records, configured via YAML. 
The currently available tools can be listed by <code>seqkit bam -T help</code>:</p>
<pre><code class="language-text">Tool        Description
----        -----------
AccStats    calculates mean accuracy weighted by aligment lengths
AlnContext  filter records by the sequence context at start and end
Dump        dump various record properties in TSV format
help        list all tools with description
</code></pre>
<p>Example YAML configs:</p>
<p>Invoking the AccStats tool directly from the command line or YAML config:</p>
<pre><code class="language-text">seqkit bam -T '{AccStats: {Tsv: &quot;-&quot;}, Sink: True}' input.bam
seqkit bam -T '{Yaml: &quot;tests/examples/bam_tool_acc_stats.yml&quot;}' input.bam
</code></pre>
<p>Where the contents of <code>bam_tool_acc_stats.yml</code> are:</p>
<pre><code class="language-text">AccStats:
  Tsv: &quot;-&quot;
Sink: True
</code></pre>
<p>Invoking the AlnContext tool using YAML:</p>
<pre><code class="language-text">AlnContext:
  Tsv: &quot;-&quot;
  Ref: &quot;../SIRV_150601a.fasta&quot;
  LeftShift: -10
  RightShift: 10
  RegexStart: &quot;T{4,}&quot;
  RegexEnd: &quot;A{4,}&quot;
  Stranded: True
  Invert: True
Sink: True
</code></pre>
<p>Invoking the Dump tool using YAML:</p>
<pre><code class="language-text">Dump:
  Tsv: &quot;-&quot;
  Fields: [&quot;Read&quot;, &quot;Ref&quot;, &quot;Pos&quot;, &quot;EndPos&quot;, &quot;MapQual&quot;, &quot;Acc&quot;, &quot;Match&quot;, &quot;Mismatch&quot;, &quot;Ins&quot;, &quot;Del&quot;, &quot;AlnLen&quot;, &quot;  ReadLen&quot;, &quot;RefLen&quot;, &quot;RefAln&quot;, &quot;RefCov&quot;, &quot;ReadAln&quot;, &quot;ReadCov&quot;, &quot;Strand&quot;, &quot;MeanQual&quot;, &quot;LeftClip&quot;, &quot;RightClip&quot;, &quot;Flags&quot;, &quot;IsSec&quot;, &quot;  IsSup&quot;, &quot;ReadSeq&quot;, &quot;ReadAlnSeq&quot;, &quot;LeftSoftClipSeq&quot;, &quot;RightSoftClip&quot;, &quot;LeftHardClip&quot;, &quot;RightHardClip&quot;]
Sink: True
</code></pre>
<p>The tools can be chained together, for example the YAML using all three tools look like:</p>
<pre><code class="language-text">AlnContext:
  Tsv: &quot;context.tsv&quot;
  Ref: &quot;../SIRV_150601a.fasta&quot;
  LeftShift: -10
  RightShift: 10
  RegexStart: &quot;T{4,}&quot;
  RegexEnd: &quot;A{4,}&quot;
  Stranded: True
  Invert: True
Dump:
  Tsv: &quot;dump.tsv&quot;
  Fields: [&quot;Read&quot;, &quot;Ref&quot;, &quot;Pos&quot;, &quot;EndPos&quot;, &quot;MapQual&quot;, &quot;Acc&quot;, &quot;Match&quot;, &quot;Mismatch&quot;, &quot;Ins&quot;, &quot;Del&quot;, &quot;AlnLen&quot;, &quot;  ReadLen&quot;, &quot;RefLen&quot;, &quot;RefAln&quot;, &quot;RefCov&quot;, &quot;ReadAln&quot;, &quot;ReadCov&quot;, &quot;Strand&quot;, &quot;MeanQual&quot;, &quot;LeftClip&quot;, &quot;RightClip&quot;, &quot;Flags&quot;, &quot;IsSec&quot;, &quot;  IsSup&quot;, &quot;ReadSeq&quot;, &quot;ReadAlnSeq&quot;, &quot;LeftSoftClipSeq&quot;, &quot;RightSoftClip&quot;, &quot;LeftHardClip&quot;, &quot;RightHardClip&quot;]
AccStats:
  Tsv: &quot;-&quot;
</code></pre>
<p>If the "Sink" parameter is not specified in the last pipeline step, the output BAM records are streamed to the standard output and can be piped into standard tools, for example:</p>
<pre><code class="language-text">seqkit bam -T '{Yaml: &quot;bam_tool_pipeline.yml&quot;}' ../pcs109_5k_spliced.bam | samtools flagstat -
</code></pre>
<h2 id="merge-slides">merge-slides</h2>
<p>Usage</p>
<pre><code class="language-text">merge sliding windows generated from seqkit sliding

For example,

    ref.contig00001_sliding:454531-454680
    ref.contig00001_sliding:454561-454710
    ref.contig00001_sliding:454591-454740
    ref.contig00002_sliding:362281-362430
    ref.contig00002_sliding:362311-362460
    ref.contig00002_sliding:362341-362490
    ref.contig00002_sliding:495991-496140
    ref.contig00044_sliding:1-150
    ref.contig00044_sliding:31-180
    ref.contig00044_sliding:61-210
    ref.contig00044_sliding:91-240

could be merged into

    ref.contig00001 454530  454740
    ref.contig00002 362280  362490
    ref.contig00002 495990  496140
    ref.contig00044 0       240

Output (BED3 format):
    1. chrom      - chromosome name
    2. chromStart - starting position (0-based)
    3. chromEnd   - ending position (0-based)

Usage:
  seqkit merge-slides [flags]

Flags:
  -b, --buffer-size string            size of buffer, supported unit: K, M, G. You need increase the
                                      value when &quot;bufio.Scanner: token too long&quot; error reported (default
                                      &quot;1G&quot;)
  -p, --comment-line-prefix strings   comment line prefix (default [#,//])
  -h, --help                          help for merge-slides
  -g, --max-gap int                   maximum distance of starting positions of two adjacent regions, 0
                                      for no limitation, 1 for no merging.
  -l, --min-overlap int               minimum overlap of two adjacent regions, recommend
                                      $sliding_step_size - 1. (default 1)
  -r, --regexp string                 regular expression for extract the reference name and window
                                      position. (default &quot;^(.+)_sliding:(\\d+)\\-(\\d+)&quot;)

</code></pre>
<p>Example:</p>
<pre><code>seqkit merge-slides sliding_windows.tsv -l 50 -o sliding_windows.merged.tsv
</code></pre>
<h2 id="genautocomplete">genautocomplete</h2>
<p>Usage</p>
<pre><code class="language-text">generate shell autocompletion script

Supported shell: bash|zsh|fish|powershell

Bash:

    # generate completion shell
    seqkit genautocomplete --shell bash

    # configure if never did.
    # install bash-completion if the &quot;complete&quot; command is not found.
    echo &quot;for bcfile in ~/.bash_completion.d/* ; do source \$bcfile; done&quot; &gt;&gt; ~/.bash_completion
    echo &quot;source ~/.bash_completion&quot; &gt;&gt; ~/.bashrc

Zsh:

    # generate completion shell
    seqkit genautocomplete --shell zsh --file ~/.zfunc/_seqkit

    # configure if never did
    echo 'fpath=( ~/.zfunc &quot;${fpath[@]}&quot; )' &gt;&gt; ~/.zshrc
    echo &quot;autoload -U compinit; compinit&quot; &gt;&gt; ~/.zshrc

fish:

    seqkit genautocomplete --shell fish --file ~/.config/fish/completions/seqkit.fish

Usage:
  seqkit genautocomplete [flags]

Flags:
      --file string   autocompletion file (default &quot;/home/shenwei/.bash_completion.d/seqkit.sh&quot;)
  -h, --help          help for genautocomplete
      --type string   autocompletion type (currently only bash supported) (default &quot;bash&quot;)

</code></pre>
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//seqkit.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.81fa17fe.min.js"></script>
      
    
  </body>
</html>